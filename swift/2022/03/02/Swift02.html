<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>이번에는 덩치가 큰 클로저라는 친구를 다이어트 시키는 방법과 저를 곤란하게 만든 @escaping 클로저에 대해 알아보겠습니다</p>

<p>우리 클로저라는 친구는 덩치가 너무 큽니다.. 이전 게시물의 예시를 다시 가져와볼까요?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: { () -&gt; () in
    print("Hi! I'm Closure")
})
</code></pre></div></div>
<p>클로저를 인수로 받는 함수의 호출법입니다. 위 예시는 사실 아주 단순한 친구였죠?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(클로저)
</code></pre></div></div>
<p>네.. 가만히 한번 관찰해보면 이 친구는</p>

<p>() -&gt; ()</p>

<p>요 부분이라던지..</p>

<p>closure:</p>

<p>요 부분이라던지.. 불필요하게 명시되어 있는 여러 부분들이 보입니다. 마치 저의 몸에 붙어있는 불필요한 지방같죠. 😝</p>

<p>그래서 지금부터는 클로저의 체중 감량법을 알아보겠습니다.</p>

<hr>

<h3 id="trailing-closure-트레일링-클로저">Trailing Closure (트레일링 클로저)</h3>

<p>또 새로운 용어가 나왔지만 이해를 돕기 위한 도구로서 접근해봅시다. “Trailing = 끝에 붙은” 이라는 뜻이죠?</p>

<p>이 경량법은 <strong>함수의 마지막 인자로 클로저</strong>가 들어가있을 때 사용할 수 있습니다. 마지막 클로저를 빼내서 <strong>함수의 끝</strong>에 간략화해서 붙여쓰는 방법이죠. 이 때, 인자의 자리에서 뛰쳐나왔으니 <strong>인자명은 적지 않습니다</strong>.</p>

<p>역시 예시가 이해에 직빵이죠?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: { () -&gt; () in
    print("Hi! I'm Closure")
})
</code></pre></div></div>

<p>네 위의 예시와 같은 예시입니다. <strong>function({ … })</strong> 이렇게 괄호안에 중괄호가 들어가있어서 한 눈에 파악이 어려운 점이 있었습니다. 그래서 <strong>Trailing Closure</strong>를 사용해볼게요!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo() { () -&gt; () in
    print("Hi! I'm Closure")
}
</code></pre></div></div>

<p>이렇게!! <strong>function() { … }</strong> 형태로 바꿀 수 있고, <strong>closure:</strong> 와 같은 인자명도 생략할 수 있습니다.</p>

<p>그리고 여기에서 추가로! 인자가 클로저 단 하나일 경우에는 <strong>()</strong>까지 생략 가능합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo { () -&gt; () in
    print("Hi! I'm Closure")
}
</code></pre></div></div>
<p>이렇게 말이죠!</p>

<p>인자가 여러개인 경우도 한번 볼게요</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func fetchData(success: () -&gt; (), fail: () -&gt; ()) {
    // Tasks
}
</code></pre></div></div>
<p>위 함수는 아래와 같이 호출될겁니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetchData(success: { () -&gt; () in
    print("Success")
}, fail: { () -&gt; () in
    print("Fail")
})
</code></pre></div></div>
<p>이 호출법에 Trailing Closure를 활용해볼게요.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetchData(success: { () -&gt; () in
    print("Success")
}) { () -&gt; () in
    print("Fail")
}
</code></pre></div></div>
<p>이렇게! 마지막 클로저 인자만 뒤로 쏙 뺄 수 있죠.</p>

<p>정리해볼까요?</p>
<ol>
  <li>마지막 인자가 클로저인 경우, 해당 클로저를 인자에서 빼내서 함수 뒤에 붙일 수 있다.</li>
  <li>이 때, 인자명은 생략된다.</li>
  <li>만약 인자가 클로저 단 하나일 경우에는 함수 호출 구문인 () 또한 생략할 수 있다.</li>
</ol>

<hr>

<h3 id="----in-생략">() -&gt; () in 생략</h3>

<p>자.. 그런데 사실 저희 눈에 제일 거슬리는건 저런 마이너한 부분이 아닙니다. 본인이 클로저라고 당당히 소리치고 있는 <strong>() -&gt; () in</strong> 이 부분이죠.</p>

<p>너무 자기주장이 강해서 클로저 구문을 보면 저 부분부터 눈이 갑니다. 그래서 저 부분을 생략해볼겁니다.</p>

<p>자 아래와 같은 함수가 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func foo(closure: (Int, Int, Int) -&gt; (Int)) {
    closure(1, 2, 3)
}
</code></pre></div></div>
<p>인자로 Int형 1, 2, 3을 받아 Int형 Return Type을 내보내는 클로저를 인수로 갖는 함수 foo()이네요. 이 함수를 호출할 때는 어떻게 해야할까요?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {closure: (a: Int, b: Int, c: Int) -&gt; Int in
    return a + b + c
})
</code></pre></div></div>
<p>혹은 Trailing Closure를 사용해서</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo() { (a: Int, b: Int, c: Int) -&gt; Int in
    return a + b + c
}
</code></pre></div></div>
<p>이런식으로 주저리주저리.. 굉장히 길어집니다. 심지어 위 예시는 굉장히 간단한 예시이죠? 실전에선 더욱 복잡해지고 길어질겁니다. 그래서 이 친구를 총 다섯 단계에 걸쳐 축약해볼게요!</p>

<p><strong>1.. 데이터 타입을 생략한다.</strong></p>

<p>가장 만만한 데이터 타입부터 생략해봅시다. Swift는 현대 언어의 기본 소양인 “데이터타입 알아서 처리하기” 기능이 당연히 있습니다. 이를 적극적으로 활용한 방법이죠.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {closure: (a: Int, b: Int, c: Int) -&gt; Int in
    return a + b + c
})
</code></pre></div></div>
<p>여기서 Int 타입들을 전부 생략합니다!</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {closure: (a, b, c) in 
    return a + b + c
})
</code></pre></div></div>
<p>😮😮😮</p>

<p>벌써부터 엄청나게 줄어들었네요! 물론 데이터타입에 대해 엄격하게 관리하실거면 하나하나 적어주시는게 좋습니다.</p>

<p><strong>2.. 클로저의 인자명을 생략하고 shortand를 사용한다.</strong></p>

<p>우선 shortand가 무엇이냐 하면,</p>

<p><strong>($0, $1, $2)</strong></p>

<p>요 친구들입니다. 파이썬을 다뤄보신 분들이라면 익숙하실거에요. 각각 <strong>(첫 번째 인자, 두 번째 인자, 세 번째 인자)</strong>를 의미하죠.</p>

<p>이를 위 예시에 한 번 적용해볼까요?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {closure: (a, b, c) in 
    return a + b + c
})
</code></pre></div></div>
<p>쨔쟈쟌~</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {
    return $0 + $1 + $2
})
</code></pre></div></div>

<p>와우.. 이제 두 번째 단계인데 벌써 엄청나게 단순해졌어요.</p>

<p>물론 두 번째 방법에도 유의할 점은 있습니다. 인덱스 수와 인자의 수를 정확히 맞춰주셔야 해요!</p>

<p><strong>3.. 클로저 구문 안에 return만 있을 경우, 이 또한 생략한다.</strong></p>

<p>이건 빠르게 예시로 보고 넘어갑시다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {
    return $0 + $1 + $2
})
</code></pre></div></div>

<p>이렇게 클로저 안에 return 구문만 있는 경우에는?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {
    $0 + $1 + $2
})
</code></pre></div></div>
<p>이렇게 <strong>return</strong> 또한 생략해줄 수 있습니다.</p>

<p><strong>4.. Trailing Closure</strong></p>

<p>위에서 다룬 Trailing Closure를 적용해줍시다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {
    $0 + $1 + $2
})
</code></pre></div></div>

<p>마지막 인자를 함수 뒤로 빼버리죠!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo() {
    $0 + $1 + $2
}
</code></pre></div></div>

<p>ㅎㅎ;;;</p>

<p><strong>5.. 인자가 클로저 단 하나라면? ()도 생략한다.</strong></p>

<p>마찬가지로 위에서 다뤘었죠? 인자가 클로저 단 하나이고, Trailing Closure를 적용하면 () 안에는 아무것도 남아있지 않습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo() {
    $0 + $1 + $2
}
</code></pre></div></div>

<p>없어져라 ()!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo {
    $0 + $1 + $2
}
</code></pre></div></div>

<p>여기까지! 통통했던 클로저 친구가 이쑤시개가 되었습니다.. 드라마틱한 연출을 위해 비교해볼게요.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(closure: {closure: (a: Int, b: Int, c: Int) -&gt; Int in
    return a + b + c
})
</code></pre></div></div>
<p>이 친구가..</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo {
    $0 + $1 + $2
}
</code></pre></div></div>

<p>이렇게.. 이 정도면 클로저 친구의 건강을 걱정해야 하는거 아닌가 싶네요 😅</p>

<p>물론 위의 예시는 매우 극단적인 경우입니다. 실전에서 이렇게까지 축약되는 경우는 거의 없다고 보셔도 되지만, 한두가지만 적용해도 가시성이 훨씬 좋아지니 적극적으로 활용해줍시다!</p>

</body></html>
