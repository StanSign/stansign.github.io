<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>이번에는 @autoclosure와 @escaping에 대해 알아보겠습니다.</p>

<hr>
<h3 id="autoclosure">@autoclosure</h3>

<p>autoclosure도 우선 용어 자체를 살펴보겠습니다.</p>

<p>자동-클로저?</p>

<p>이게 대체 뭘까요?</p>

<p>이번에는 정의를 살펴봅시다.</p>

<p><strong>인자로서 전달된 일반구문/함수를 클로저로서 감싸는 것</strong></p>

<p>아무래도 일반구문/함수를 자동으로 클로저로서 취급한다.. 라는 의미인 것 같네요.</p>

<p>아직도 이해가 잘 가지 않으니 예제를 살펴보겠습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func foo(closure: @autoclosure () -&gt; ()) {
    // Tasks
}
</code></pre></div></div>

<p>@autoclosure가 사용되는 위치도 잘 기억해주세요. 인자명 뒤 타입 정의 바로 앞에 위치해있습니다!</p>

<p>자 그래서 대체 이게 무슨말이냐..</p>

<p><strong>@autoclosure</strong>를 사용하면 클로저 타입의 인자 <strong>closure</strong>는 클로저가 아닌 일밤구문/함수를 받아도 <strong>클로저로서 처리</strong>해줍니다.</p>

<p>우선 @autoclosure를 사용하지 않았을 때를 봅시다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func foo(_ closure: () -&gt; Void) {
    closure()
}
</code></pre></div></div>

<p>위 함수를 호출할 때 어떻게 호출할까요? 아래와 같이 호출합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo({ 
    print("Hi! I'm Closure")
})
</code></pre></div></div>

<p>이번엔 같은 함수에 @autoclosure를 사용해봅시다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func foo(_ closure: @autoclosure () -&gt; Void) {
    closure()
}
</code></pre></div></div>
<p>위 함수는 아래처럼 호출됩니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(print("Hi! I'm Closure"))
</code></pre></div></div>

<p><strong>{ … }</strong> 이 중괄호가 없어진 것을 볼 수 있죠.</p>

<p>클로저는 본인이 클로저임을 알리기 위해 중괄호가 무조건 필요합니다. @autoclosure는 클로저가 아닌 일반구문/함수를 중괄호로 감싼 역할을 해주는 것이죠.</p>

<p>단 유의할 점은 @autoclosure를 사용하기 위해서는 클로저의 인자가 없어야 합니다!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func foo(closure: @autoclosure (Int) -&gt; Void) {
    closure()
}
</code></pre></div></div>

<p>위와 경우 <strong>(Int) -&gt; Void</strong> 인자로 Int 타입이 들어가있죠?</p>

<p>따라서 오류가 납니다. 꼭 주의해주세요!</p>

<p>그렇다면 일반구문에 비해서 @autoclosure을 사용했을 때의 차이점은 무엇일까요?</p>

<p>일반구문은 원래 실행 순서가 되면 <strong>즉시 실행</strong>됩니다.</p>

<p>지연을 준다고 하더라도 지연을 주는 함수가 즉시 실행되었기 때문에 뒤에 따라오는 다른 함수들이 지연되는 것이죠.</p>

<p>그런데 클로저는 즉시 실행되지 않습니다. 함수 안에서 <strong>해당 인자가 사용될 때 실행</strong>되죠.</p>

<p>결론적으로 @escaping은 일반구문을 클로저처럼 사용하고 싶을 때 유용한 기능입니다.</p>

<h3 id="escaping">@escaping</h3>

<p>@escaping 클로저란 용어의 이름에서 유추할 수 있듯이, 함수에서 벗어나서도 실행될 수 있는 클로저입니다.</p>

<p>@escaping 클로저를 사용하면 다음과 같은 기능을 사용할 수 있습니다.</p>

<ol>
  <li>함수가 끝난 뒤에도 실행될 수 있다.</li>
  <li>중첩함수에서 중첩함수를 return 할 수 있다.</li>
  <li>변수/상수에 클로저를 대입할 수 있다.</li>
</ol>

<p>이 말은 지금까지 다뤘던 클로저들은 위의 경우들이 전부 불가능하다는 소리겠죠?</p>

<p>지금까지 다뤄온 클로저들 같이 @escaping 구문을 사용하지 않은 클로저들을 non-escaping closure라고 부릅니다.</p>

<p>API 라이브러리인 Alamofire의 예시를 보겠습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func dataGET(from url: URL, completion: @escaping (AnyObject) -&gt; ()) {
    DispatchQueue.global(qos: .background).async {
        Alamofire.request(url, method: .get).responseObject { (response: DataResponse&lt;FilmResponse&gt;) in 
        switch response.result {
        case .success(_):
            let res = response.result.value
            let resURL = res.results.imageID
            print(resURL ?? "No URL Found")
        case .failure(let error):
            print(error)
        }}
    }
}
</code></pre></div></div>

<p>굉장히 복잡해보이죠? 사실 다른건 다 필요없습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func dateGET(from url: URL, completion: @escaping (AnyObject) -&gt; ()) {
    DispatchQueue.global(qos: .background).async {
        // Blah Blah
    }
}
</code></pre></div></div>
<p>이렇게만 보면 됩니다.</p>

<p>이제 우리는 저 함수를 분석할 수 있습니다!</p>

<p>마지막 인자로 closure를 사용하여 <strong>Trailing Closure</strong> 방식이 채택되었네요. 또, <strong>@escaping</strong> 클로저가 사용된 것도 볼 수 있습니다. 왜 사용했을까요?</p>

<p>API 호출은 상대적으로 많은 시간이 소요됩니다. 그래서 보통 비동기성으로 실행하죠. 유저가 로딩이 다 될 때까지 먹통이 된 앱을 가만히 보고 있진 않을테니까요.</p>

<p>따라서 위 함수가 완료되기 전에 DispatchQueue로 실행한 구문들은 완료되었을 가능성이 거의 전무합니다. 여기서 @escaping 클로저가 아니라 non-escaping 클로저를 사용했다면..? <strong>함수가 종료됨과 동시에 함수 안에서 실행된 클로저까지 전부 종료되어 버립니다.</strong> 저희가 원하는 결과는 절대 아니죠.</p>

<p>그리고 애초에 XCode에서 이를 허용하지 않습니다. <strong>“Escaping closure captures non-escaping parameter”</strong>라는 에러 메시지를 출력하며 빌드 에러가 나죠.</p>

<hr>

<p>이렇게 @autoclosure와 @escaping 클로저까지 알아봤습니다. @escaping 클로저는 온라인으로 통신하는 앱에서는 거의 필수적으로 사용법을 알아둬야 하니 꼼꼼하게 기억해둘 필요가 있습니다. 저처럼 헤매지 않으려면 말이죠 ㅜㅜ</p>
</body></html>
