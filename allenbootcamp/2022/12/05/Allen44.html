<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>

<h1 id="result">Result</h1>

<p><code class="language-plaintext highlighter-rouge">Result</code> 타입은 열거형입니다.</p>

<p>내부적으로 <code class="language-plaintext highlighter-rouge">success(연관값)</code>과 <code class="language-plaintext highlighter-rouge">failure(연관값)</code>을 갖고 있어요.</p>

<p>성공했을 때와 실패했을 때의 정보를 모두 담고 있는 것이죠.</p>

<p>이 <code class="language-plaintext highlighter-rouge">Result</code> 타입을 사용하면 <code class="language-plaintext highlighter-rouge">do-catch</code>문을 활용한 에러 처리를 보다 편리하게 할 수 있습니다.</p>

<h2 id="result-타입을-활용한-에러의-처리">Result 타입을 활용한 에러의 처리</h2>

<pre><code class="language-Swift">func resultTypeCheckingHeight(hight: Int) -&gt; Result&lt;Bool, HeightError&gt; {
	if height &gt; 190 {
		return Result.failure(HeightError.maxHeight)
	} else if height &lt; 130 {
		return Result.failure(HeightError.minHeight)
	} else {
		if height &gt;= 160 {
			return Result.success(true)
		} else {
			return Result.success(false)
		}
	}
}

let result = resultTypeCheckingHeight(height: 200)

switch result {
case .success(let data):
	print("결과값은 \(data)입니다.")
case .failure(let error):
	print(error)
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">Result</code> 타입을 사용하면 결과를 처리할 때 코드가 상당히 깔끔해지는 이점이 있습니다.</p>

<p>연관값을 사용하여 바로 다른 작업을 수행할 수 있고, 에러를 하나의 <code class="language-plaintext highlighter-rouge">case</code>에서 통합하여 처리할 수 있게 됩니다.</p>

<pre><code class="language-Swift">do {
	let data = try result.get()
	print("결과값은 \(data)입니다.")
} catch {
	print(error)
}
</code></pre>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">get()</code>을 사용하여 에러를 다시 한번 던져줄수도 있습니다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Result</code> 타입을 왜 사용할까?</p>
</blockquote>

<p>성공과 실패의 경우를 명확하게 나누어 사용할 수 있습니다.</p>

<p>에러 타입을 명시적으로 선언해서 타입캐스팅이 필요없다는 이점이 있어요.</p>

<p>원래의 방식을 대체하려고 나온 것이 아니라 하나의 방법을 더 제안하는 방식으로 고안되었다고 합니다.</p>

<h2 id="네트워킹-코드에서-result-타입">네트워킹 코드에서 <code class="language-plaintext highlighter-rouge">Result</code> 타입</h2>

<p>예외 처리인만큼 네트워킹을 할 때 가장 많이 사용이 되겠죠.</p>

<p>네트워킹 예시를 비교해보고 마치도록 하겠습니다.</p>

<h3 id="result-타입-사용-전">Result 타입 사용 전</h3>

<pre><code class="language-Swift">enum NetworkError: Error {
	case someError
}

func performRequest(with url: String, completion: @escaping (Data?, NetworkError?) -&gt; Void) {
	guard let url = URL(string: url) else { return }
	URLSession.shared.dataTask(with: url) { data, response, error in
		if error != nil {
			print(error!)
			completion(nil, .someError)
			return
		}
		guard let safeData = data else {
			completion(nil, .someError)
			return
		}
		completion(safeData, nil)
	}.resume()
}

performRequest(with: "URL") {  data, error in
	if error != nil {
		print(error!)
	}

	// 데이터 처리 관련 코드
}
</code></pre>

<h3 id="result-타입-사용-후">Result 타입 사용 후</h3>

<pre><code class="language-Swift">func performRequest(with urlString: String, completion: @escaping (Result&lt;Data, NetworkError&gt;) -&gt; Void) {
	guard let url = URL(string: urlString) else { return }
	URLSession.shared.dataTask(with: url) { data, response, error in
		if error != nil {
			print(error!)
			completion(.failure(.someError))
			return
		}
		guard let safeData = data else {
			completion(.failure(.someError))
			return
		}
		completion(.success(safeData))
	}
}

performRequest(with: "URL") { result in
	switch result {
	case .success(let data):
		break
	case .failure(let error):
		break
	}
}
</code></pre>

</body></html>
