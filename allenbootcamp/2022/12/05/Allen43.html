<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>

<h1 id="제네릭-generics">제네릭 (Generics)</h1>

<h2 id="제네릭이-왜-필요한가">제네릭이 왜 필요한가?</h2>

<pre><code class="language-Swift">var num1 = 10
var num2 = 20

func swapTwoInts(_ a: inout  Int, _ b: inout Int) {
	let tempA = a
	a = b
	b = tempA
}

swapTwoInts(&amp;num1, &amp;num2)
print(num1) 
print(num2)
</code></pre>

<p>타입을 한정지어 메서드를 만든다면 위의 예시와 같이 만들면 되고, 아무런 문제가 없습니다.</p>

<p>그런데 만약 <code class="language-plaintext highlighter-rouge">Double</code> 타입도 파라미터로 받고 싶다면..?</p>

<p><code class="language-plaintext highlighter-rouge">String</code>까지도 받고 싶다면 어떻게 해야할까요?</p>

<p>타입별로 모든 메서드를 따로 만들어줘야겠죠.</p>

<p>그런데 이런 방법은 너무 번거롭습니다.</p>

<p>제네릭을 사용하면 여러 타입에 대해 대응이 가능하기 때문에 이런 번거로움이 줄일 수 있습니다.</p>

<pre><code class="language-Swift">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) -&gt; T {
	let tempA = a
	a = b
	b = tempA
	return a
}
</code></pre>

<h2 id="제네릭-문법">제네릭 문법</h2>

<p>제네릭 문법은 타입에 관계없이 한번의 구현으로 모든 타입에 대한 처리가 가능해서 유연한 함수를 작성할 수 있도록 해주는 문법입니다.</p>

<p>심지어 함수 뿐만 아니라 구조체, 클래스, 열거형 모두 일반화가 가능합니다.</p>

<p>타입 파라미터는 함수 내부에서 파라미터 형식이나 리턴형으로 사용할 수 있습니다.</p>

<p>보통 <code class="language-plaintext highlighter-rouge">T</code>(Type)로 사용하지만 다른 이름을 사용해도 문제는 없으며, 두 개 이상을 선언하는 것도 아무 문제가 없습니다.</p>

<h3 id="제네릭의-사용-예시-swift-문법">제네릭의 사용 예시 (Swift 문법)</h3>

<p>저희는 사실 이런 제네릭 문법을 지금까지 많이 사용했습니다.</p>

<p>Swift에서 컬렉션은 모두 제네릭 타입의 구조체로 구현되어 있기 떄문인데요..</p>

<pre><code class="language-Swift">let array1: [String] = [] 
let array2: Array&lt;String&gt; = []

let dictionary1: [String: Int] = ["Steve": 24]
let dictionary2: Dictionary&lt;String, Int&gt; = ["Alex": 25]

let optional1: String?
let optional2: Optional&lt;String&gt;
</code></pre>

<p>배열, 딕셔너리, 옵셔널 모두 사실은 제네릭 타입을 사용하고 있습니다.</p>

<pre><code class="language-Swift">[1, 2, 3].map(transform: (Int) throws -&gt; T)
</code></pre>

<p>또한 <code class="language-plaintext highlighter-rouge">map</code>과 같은 고차함수들도 모두 제네릭 타입을 사용하고 있습니다.</p>

<h2 id="제네릭-정의하기">제네릭 정의하기</h2>

<h3 id="구조체로-제네릭-정의하기">구조체로 제네릭 정의하기</h3>

<pre><code class="language-Swift">struct GenericMember&lt;T&gt; {
	var members: [T] = []
}
var member1 = GenericMember(members: ["Jobs", "Cook", "Musk"])
var member2 = GenericMember(members: [1, 2, 3])
</code></pre>

<h3 id="클래스로-제네릭-정의하기">클래스로 제네릭 정의하기</h3>

<pre><code class="language-Swift">class GridPoint&lt;A&gt; {
	var x: A
	var y: A

	init(x: A, y: A) {
		self.x = x
		self.y = y
	}
}

let aPoint = GridPoint(x: 10, y: 20)
let bPoint = GridPoint(x: 10.4, y: 20.5)
</code></pre>

<h3 id="열거형으로-제네릭-정의하기">열거형으로 제네릭 정의하기</h3>

<p>열거형에서는 연관값을 가질때만 제네릭으로 정의할 수 있습니다.</p>

<pre><code class="language-Swift">enum Pet&lt;T&gt; {
	case dog
	case cat
	case etc(T)
}

let animal = Pet.etc("고슴도치")
</code></pre>

<h3 id="제네릭-구조체의-확장">제네릭 구조체의 확장</h3>

<p>제네릭 타입을 확장할 떄는 <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>는 생략해야 합니다.</p>

<pre><code class="language-Swift">struct Coordinates&lt;T&gt; {
	var x: T
	var y: T
}

extension Coordinates { // Coordinates&lt;T&gt; (X)
	func getPlace() -&gt; (T, T) {
		return (x, y)
	}
}
</code></pre>

<p>또한 <code class="language-plaintext highlighter-rouge">where</code>절을 추가하여 제네릭 타입에 제한을 줄 수도 있습니다.</p>

<pre><code class="language-Swift">extension Coordinates where T == Int {
	func getIntArray() -&gt; [T] {
		return [x, y]
	}
}
</code></pre>

<h2 id="타입-제약">타입 제약</h2>

<p>제네릭을 사용하더라도 모든 타입에 대해서 열어두기는 싫을 때가 있겠죠.</p>

<p>그럴때는 타입 매개 변수 뒤에 콜론(<code class="language-plaintext highlighter-rouge">:</code>)을 붙이고 프로토콜이나 단일 클래스를 적어 제한을 둘 수 있습니다.</p>

<pre><code class="language-Swift">find findIndex&lt;T: Equatable&gt;(item: T, array: [T]) -&gt; Int? {
	for (index, value) in array.enumerated() {
		if item == value {
			return index
		}
	}
	return nil
}

let aNumber = 5
let someArray = [3, 4, 5, 6, 7]

if let index = findIndex(item: aNumber, array: someArray) {
	print("밸류 값과 같은 배열의 인덱스: \(index)") // 2
}
</code></pre>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">T</code> 타입은 <code class="language-plaintext highlighter-rouge">Equatable</code> 프로토콜을 채택한 타입들만 들어갈 수 있습니다.</p>

<h2 id="프로토콜에서의-제네릭-문법-사용">프로토콜에서의 제네릭 문법 사용</h2>

<pre><code class="language-Swift">protocol RemoteControl {
	associatedtype T
	func chnageChannel(to: T)
	func alert() -&gt; T?
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">protocol</code>에서도 제네릭 타입을 사용할 수 있지만, <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>와 같이 사용하는 것이 아니라 <code class="language-plaintext highlighter-rouge">associatedtype</code>을 사용합니다.</p>

<p>이 프로토콜을 사용하는 방법은 아래와 같습니다.</p>

<pre><code class="language-Swift">struct TV: RemoteControl {
	typealias T = Int // 생략 가능

	func changeChannel(to: Int) {
		print("TV 채널바꿈: \(to)")
	}

	func alert() -&gt; Int? {
		return 1
	}
}
</code></pre>
</body></html>
