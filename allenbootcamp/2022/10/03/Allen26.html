<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>

<h1 id="초기화와-생성자">초기화와 생성자</h1>

<h2 id="초기화-initialization">초기화 (Initialization)</h2>
<ul>
  <li>클래스, 구조체, 열거형의 인스턴스를 생성하는 과정</li>
  <li>각 저장 속성에 대한 초기값 설정</li>
  <li>인스턴스를 사용 가능한 상태로 만드는 과정</li>
</ul>

<h2 id="생성자-initializer">생성자 (Initializer)</h2>
<ul>
  <li>인스턴스의 모든 저장 속성이 초기값을 갖도록 하는 메서드</li>
  <li>컴파일러는 기본 생성자(<code class="language-plaintext highlighter-rouge">init()</code>)을 자동으로 생성하지만, 개발자가 직접적으로 생성자를 구현하면 자동으로 생성되지 않는다.</li>
  <li>소멸자
    <ul>
      <li>인스턴스가 해제되게 전에 수행하는 작업들을 정의한 메서드</li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">class Color {
	let red: Double
	let green: Double
	let blue: Double

	init() { // 기본 생성자, 저장 속성의 기본값을 설정하면 자동 구현
		red = 0.0
		green = 0.0
		blue = 0.0
	}
	// 저장 속성 기본값 예시) let red: Double = 1.0

	// 생성자 오버로딩 가능
	init(white: Double) {
		red = white
		green = white
		blue = white
	}

	init(red: Double, green: Double, blue: Double) {
		self.red = red
		self.green = green
		self.blue = blue
	}
}
</code></pre>

<h2 id="초기화의-경우의-수">초기화의 경우의 수</h2>
<ol>
  <li>저장 속성의 선언과 동시에 값을 저장하여 초기화</li>
  <li>저장 속성을 옵셔널로 선언하여 <code class="language-plaintext highlighter-rouge">nil</code>로 초기화</li>
  <li>생성자에서 값을 초기화</li>
</ol>

<h2 id="멤버와이즈-생성자-memberwise-initializer">멤버와이즈 생성자 (Memberwise Initializer)</h2>
<ul>
  <li>구조체의 특별한 생성자</li>
  <li>저장 속성들이 기본값을 갖고 있더라도 자동으로 제공</li>
</ul>

<pre><code class="language-Swift">struct Color { // No Error
	var red: Double = 1.0
	var green: Double = 1.0
	var blue: Double
}

var b = Color(blue: Double)
var c = Color(red: Double, green: Double, blue: Double)
</code></pre>

<h2 id="구조체클래스의-생성자">구조체/클래스의 생성자</h2>
<h3 id="구조체-지정생성자">구조체 지정생성자</h3>
<ul>
  <li>코드의 중복 없이 다른 생성자를 호출하여 초기화 가능</li>
</ul>

<pre><code class="language-Swift">struct Color {
	let red, green, blue: Double

	init() {
		// 맨 아래의 init 호출
		self.init(red: 0.0, green: 0.0, blue: 0.0)
	}

	init(white: Double) {
		self.init(red: white, green: white, blue: white)
	}

	init(red: Double, green: Double, blue: Double) {
		self.red = red
		self.green = green
		self.blue = blue
	}
}
</code></pre>

<h3 id="클래스-지정편의-생성자">클래스 지정/편의 생성자</h3>
<ul>
  <li>
<strong>지정생성자 (Designated Initializer)</strong>
    <ul>
      <li>일반적인 생성자 (<code class="language-plaintext highlighter-rouge">init()</code>)</li>
    </ul>
  </li>
  <li>
<strong>편의생성자 (Convenience Initializer)</strong>
    <ul>
      <li>
<strong>다른 지정/편의생성자를 호출</strong>하는 생성자 (<code class="language-plaintext highlighter-rouge">convenience init()</code>)</li>
      <li>
<strong>클래스에만</strong> 있는 생성자 (상속과 관련됨)</li>
      <li>클래스는 <strong>상속</strong>을 지원하며 변수가 여러개인 경우가 많다.
        <ul>
          <li>여러 지정생성자의 사용은 개발자의 실수를 유발한다.</li>
          <li>
<strong>초기화 과정을 간편</strong>하게 하는 생성자</li>
          <li>상속 관계에서 개발자가 <strong>실수할 가능성을 배제</strong>하기 위한 생성자</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">class Color {
	let red, green, blue: Double

	convenience init() {
		self.init(red: 0.0, green: 0.0, blue: 0.0)
	}

	convenience init(white: Double) {
		self.init(red: white, green: white, blue: white)
	}

	init(red: Double, green: Double, blue: Double) {
		self.red = red
		self.green = green
		self.blue = blue
	}
}
</code></pre>

<h4 id="생성자-위임-규칙">생성자 위임 규칙</h4>
<ol>
  <li>
<strong>델리게이트 업 (Delegate Up)</strong>
    <ul>
      <li>서브 클래스의 지정생성자는 <strong>슈퍼 클래스의 지정생성자를 반드시 호출</strong>해야 한다.</li>
    </ul>
  </li>
  <li>
<strong>델리게이트 어크로스 (Delegate Across)</strong>
    <ul>
      <li>편의생성자는 동일한 클래스의 다른 <strong>편의생성자 또는 지정생성자를 호출</strong>해야하고, <strong>궁극적으로는 지정생성자를 호출</strong>해야 한다.</li>
    </ul>
  </li>
</ol>

<h4 id="상속-관계에서-생성자-호출과정의-메모리-구조">상속 관계에서 생성자 호출과정의 메모리 구조</h4>
<ol>
  <li>객체의 초기화 단계에서 <code class="language-plaintext highlighter-rouge">convenience init()</code> 편의생성자가 호출된다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">convenience init()</code> 편의생성자에서 동일한 클래스의 <code class="language-plaintext highlighter-rouge">init()</code> 지정생성자을 호출한다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">init()</code> 지정생성자가 슈퍼 클래스의 <code class="language-plaintext highlighter-rouge">super.init()</code> 지정생성자를 호출한다.</li>
  <li>생성자의 호출 과정에서 속성 값들은 힙 영역에 빈 공간을 찾아 저장된다.
    <ul>
      <li>해당 과정에 의해 구조체보다 클래스의 초기화에 비교적 오랜 시간이 걸린다.</li>
    </ul>
  </li>
</ol>

<h3 id="클래스-상속-예시">클래스 상속 예시</h3>

<pre><code class="language-Swift">class Aclass {
	var x: Int
	var y: Int

	init(x: Int, y: Int) {
		self.x = x
		self.y = y
	}

	convenience init() {
		self.init(x: 0, y: 0)
	}
}

class Bclass: Aclass {
	var z: Int

	// 상속 받을 때 있어야하는 지정생성자
	init(x: Int, y: Int, z: Int) {
		self.z = z // 새로운 저장 속성값 초기화
		// self.y = y // Error (생성자 호출 전)
		super.init(x: x, y: y) // 상위의 지정생성자 호출
	}

	convenience init(z: Int) {
		self.init(x: 0, y: 0, z: z)
	}

	convenience init() {
		self.init(z: 0)
	}

	func doSomething() {
		print("Do Something")
	}
}
</code></pre>

<h2 id="상속과-재정의-규칙">상속과 재정의 규칙</h2>
<h3 id="생성자">생성자</h3>
<ul>
  <li>생성자는 기본적으로 상속되지 않고 재정의하는 것이 원칙
    <ul>
      <li>
<strong>재정의</strong>: 동일한 이름의 생성자를 구현하는 것</li>
      <li>하위클래스에 최적화가 되어있지 않기 때문</li>
    </ul>
  </li>
  <li>상위의 지정생성자와 현재 단계의 저장 속성을 고려해서 구현</li>
</ul>

<h4 id="상위-생성자에-대한-고려">상위 생성자에 대한 고려</h4>
<ul>
  <li>상위에 어떤 생성자가 존재하는가?</li>
  <li>상위에 <strong>지정생성자</strong>가 있다면
    <ol>
      <li>하위 클래스에서 지정생성자로 구현 (재정의)</li>
      <li>하위 클래스에서 편의생성자로 구현 (재정의)</li>
      <li>구현하지 않아도 됨</li>
    </ol>
  </li>
  <li>상위에 <strong>편의생성자</strong>가 있다면
    <ol>
      <li>구현하지 않아도 됨 (호출 불가가 원칙)</li>
      <li>같은 이름의 생성자를 구현했다면 단순하게 새로 정의한 것</li>
    </ol>
  </li>
</ul>

<h4 id="현재-단계의-생성자-구현">현재 단계의 생성자 구현</h4>
<ul>
  <li>지정생성자 내에서
    <ol>
      <li>현재 단계의 모든 저장 속성을 초기화해야함</li>
      <li>슈퍼 클래스의 지정생성자를 호출해야함</li>
    </ol>
  </li>
  <li>편의생성자 내에서
    <ol>
      <li>현재 클래스의 지정생성자를 호출해야함 (편의생성자를 거치는 것은 상관X)</li>
    </ol>
  </li>
</ul>

<h4 id="생성자-상속의-예외사항">생성자 상속의 예외사항</h4>
<h5 id="지정생성자-자동상속">지정생성자 자동상속</h5>
<ul>
  <li>새 저장 속성이 아예 없거나, 기본값이 설정되어 있다면 지정생성자의 자동 상속
    <ul>
      <li>초기화  과정에서 실패 가능성이 없기 때문</li>
    </ul>
  </li>
</ul>

<h5 id="편의생성자-자동상속">편의생성자 자동상속</h5>
<ul>
  <li>지정생성자를 자동상속하는 경우
    <ul>
      <li>바로 위의 경우 (지정생성자를 자동상속하는 경우, 편의생성자까지 함께 자동상속)</li>
    </ul>
  </li>
  <li>상위 지정생성자를 모두 재정의하여 구현
    <ul>
      <li>초기화 과정에서 실패 가능성이 없기 때문</li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">class Food {
	var name: String

	init(name: String) { // 지정생성자
		self.name = name
	}

	convenience init() { // 편의생성자
		self.init(name: "[Unnamed]")
	}
}

let namedMeat = Food(name: "Bacon")
let mysteryMeat = Food()

class RecipeIngredient: Food {
	var quantity: Int

	init(name: String, quantity: Int) {
		self.quantity = quantity
		super.init(name: name)
	}

	// 상위 지정생성자를 편의생성자로 재정의
	override convenience init(name: String) {
		self.init(name: name, quantity: 1)
	}

	// convenience init() { } // 자동 상속

	// convenience init() -&gt; override convenience init(name: String) -&gt; init(name: String, quantity: Int)
}

class ShoppingListItem: RecipeIngredient {
	var purchased = false // 기본값

	var subtitle: String {
		var output = "\(quantity) x \(name)"
		output += purchased ? "✔" : "✖️"
		return output
	}

	// 지정생성자 모두 자동 상속
	// init(name: String, quantity: Int) { }

	// 편의생성자도 모두 자동 상속
	// convenience init(name: String) { }
	// convenience init() { }
}
</code></pre>

<h5 id="예시1">예시1</h5>

<pre><code class="language-Swift">class Aclass {
	var x = 0
}

class Bclass: Aclass {
	var y: Int

	// 지정생성자로 재정의
	override init()
		self.y = 0
		super.init() // super.init
	}

	// 서브클래스에서 편의생성자로 구현
	override convenience init() {
		self.init(y: 0) // self.init
	}

	// 재정의하지 않을 수 있음

	// 현재 단계의 생성자 구현
	init(y: Int) {
		self.y = y
		super.init()
	}
}

class Cclass: Bclass {
	var z: Int

	override init() {
		self.z = 0
		super.init()
	}

	override init(y: Int) {
		self.z = 0
		super.init(y: y)
	}

	init(z: Int) {
		self.z = z
		super.init()
	}
}
</code></pre>

<h5 id="예시2">예시2</h5>

<pre><code class="language-Swift">class Vehicle {
	var numberOfWheels = 0

	var subtitle: String {
		return "\(numberOfWheels) wheel(s)"
	}

	// init() { }
}

class Bicycle: Vehicle {
	override init() {
		super.init()
		numberOfWheels = 2
	}
}

class Hoverboard: Vehicle {
	var color: String

	override var subtitle: String {
		return "\(super.subtitle) in a beautiful \(color)"
	}

	// 저장속성이 있기 때문에 지정생성자 필수
	init(color: String) {
		self.color = color
		super.init()
	}
}
</code></pre>

<h2 id="필수생성자">필수생성자</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">required</code></li>
  <li>하위생성자는 반드시 필수생성자를 구현해야 한다.</li>
  <li>하위 클래스에서 필수생성자를 구현할 때는 <code class="language-plaintext highlighter-rouge">override</code> 키워드 대신 <code class="language-plaintext highlighter-rouge">required</code> 키워드로 대체</li>
  <li>필수생성자 자동 상속 조건
    <ul>
      <li>다른 지정생성자를 구현하지 않으면 자동 상속</li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">class Aclass {
	var x: Int

	required init(x: Int) {
		self.x = x
	}
}

class Bclass: Aclass {
	// 자동 상속
	// required init(x: Int) {
	// 	self.x = x
	// }
}

class Cclass: Aclass {
	// 생성자를 구현하려면
	init() {
		super.init(x: 8)
	}

	// 필수생성자를 구현해야한다.
	required init(x: Int) {
		super.init(x: x)
	}
}
</code></pre>

<h3 id="사용-예시">사용 예시</h3>
<ul>
  <li>필수생성자는 보통 애플이 만들어놓은 프레임워크를 개발자가 사용할 때 이용된다.</li>
</ul>

<h4 id="uiview">UIView</h4>

<pre><code class="language-Swift">class AView: UIView {
	required init?(coder: NSCoder) { // 구현을 안해도 자동 상속
		fatalError("init(coder:) has not been implemented")
	}
}

class BView: UIView {
	override init(frame: CGRect) {
		super.init(frame: frame)
	}

	required init?(coder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
}
</code></pre>

<h2 id="실패가능-생성자-failable">실패가능 생성자 (Failable)</h2>
<ul>
  <li>인스턴스 생성에 실패할 수도 있는 가능성을 가진 생성자
    <ul>
      <li>실패가 나서 앱이 먹통되는 것보단 예외처리를 하는 편이..</li>
    </ul>
  </li>
  <li>동일한 파라미터를 취급하는 생성자는 실패가능 생성자 단 하나여야 한다!</li>
  <li><code class="language-plaintext highlighter-rouge">init?()</code></li>
</ul>

<pre><code class="language-Swift">struct Animal {
	let species: String

	init?(species: String) { // == -&gt; Animal?
		if species.isEmpty { // 문자열이 비어있는 경우 == ""
			return nil
		}
		self.species = species
	}
}

let a = Animal(species: "Giraffe")
let b = Animal(species: "")
</code></pre>

<h3 id="열거형의-실패가능-생성자-활용">열거형의 실패가능 생성자 활용</h3>
<ul>
  <li>원시값을 통해서 구현하는 것과 유사</li>
</ul>

<pre><code class="language-Swift">enum TemperatureUnit {
	case kelvin
	case celsius
	case fahrenheit

	init?(symbol: Character) {
		switch symbol {
		case "K":
			self = TemperatureUnit.kelvin
		case "C":
			self = TemperatureUnit.celsius
		case "F":
			self = TemperatureUnit.fahrenheit
		default:
			return nil
		}
	}
}

let c: TemperatureUnit = TemperatureUnit.celsius
let f: TemperatureUnit? = TemperatureUnit(symbol: "F")
</code></pre>

<h3 id="초기화-실패의-전달-호출관계">초기화 실패의 전달 (호출관계)</h3>
<ul>
  <li>실패가능 생성자는 다른 실패가능 생성자를 호출할 수 없다.</li>
</ul>

<h4 id="동일단계-delegate-across">동일단계 (Delegate Across)</h4>
<ul>
  <li>실패가능 생성자는 실패불가능 생성자를 호출할 수 있다.</li>
  <li>반대로 실패불가능 생성자는 실패가능 생성자를 호출할 수 없다.</li>
  <li>
<strong>실패가능 생성자는</strong> <code class="language-plaintext highlighter-rouge">nil</code>을 포함하기 때문에 <strong>실패불가능 생성자보다 범위가 크기</strong> 때문!</li>
</ul>

<pre><code class="language-Swift">struct Item {
	var name = ""

	// 1. 실패가능 생성자가 실패불가능 생성자 호출
	init() {
	}

	init?(name: String) {
		self.init()
	}

	// 2. 실패불가능 생성자가 실패가능 생성자 호출 
	// Error: Non-failable initializer cannot delegate to failable initializer 'init(name:)' written with 'init?'
	init() {
		self.init(name: "하이")
	}

	init?(name: String) {
		self.name = name
	}
}
</code></pre>

<pre><code class="language-Swift">class Product {
	let name: String
	init?(name: String) {
		if name.isEmpty { return nil }
		self.name = name
	}
}

class CartItem: Product {
	let quantity: Int
	init?(name: String, quantity: Int) {
		if quantity &lt; 1 { return nil }
		self.quantity = quantity
		super.init(name: name)
	}
}

if let twoSocks = CartItem(name: "sock", quantity: 2) {
	print("아이템: \(twoSocks.name), 수량: \(twoSocks.quantity)")
}
if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
	print("아이템: \(zeroShirt.name), 수량: \(zeroShirt.quantity)")
} else {
	print("zero shirts를 초기화 불가 (개수가 없음)")
}
</code></pre>

<h4 id="상속관계-delegate-up">상속관계 (Delegate Up)</h4>
<ul>
  <li>실패불가능 생성자에서 상위 클래스의 실패가능 생성자를 호출할 수 없다.</li>
  <li>실패가능 생성자에서 상위 클래스의 실패불가능 생성자를 호출하는 것은 가능하다.</li>
</ul>

<h3 id="상속관계에서-재정의하기">상속관계에서 재정의하기</h3>
<ul>
  <li>상위에서 실패가능 생성자를 하위에서 실패불가능 생성자로 재정의하는 것은 가능하다.
    <ul>
      <li>강제 언래핑 또한 사용 가능하다.</li>
    </ul>
  </li>
  <li>상위에서 실패불가능 생성자를 하위에서 실패가능 생성자로 재정의하는 것은 불가능하다.</li>
  <li>마찬가지로 <strong>실패가능 생성자가 실패불가능 생성자보다 넓은 범위</strong>이기 때문!</li>
</ul>

<pre><code class="language-Swift">class Document {
	var name: String?

	init() { }

	init?(name: String) {
		if name.isEmpty { return nil }
		self.name = name
	}
}

class AutomaticallyNamedDocument: Document {
	override init() {
		super.init()
		self.name = "[Untitled]"
	}

	// 실패가능 -&gt; 실패불가능 재정의
	override init(name: String) {
		super.init() // init?(name:)이 아닌 init()을 호출
		if name.isEmpty {
			self.name = "[Untitled]"
		} else {
			self.name = name
		}
	}
}

class UntitledDocument: Document {
	override init() { // 구조적으로 실패 가능하지 않으므로!
		super.init(name: "[Untitled]")! // 강제 언래핑 (!)
	}
}
</code></pre>
</body></html>
