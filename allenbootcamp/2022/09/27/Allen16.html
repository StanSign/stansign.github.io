<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>

<h1 id="옵셔널-optional">옵셔널 (Optional)</h1>

<p>우선 옵셔널 타입의 필요성을 느껴보기 위해 다음과 같은 상황을 살펴봅시다.</p>

<pre><code class="language-Swift">var yourName: String
print(yourName)
</code></pre>

<p>위의 코드를 실행하면 <code class="language-plaintext highlighter-rouge">print(yourName)</code> 부분은 변수 <code class="language-plaintext highlighter-rouge">yourName</code>에 값을 저장하지 않았기 때문에 에러가 발생합니다.
옵셔널 타입은 이런 상황에 대응하기 위해 소개되었습니다.</p>

<h2 id="옵셔널-타입-optional-type">옵셔널 타입 (Optional Type)</h2>
<ul>
  <li>메모리에 공간을 할당하여 변수를 선언하였지만, 실제로 값은 부여하지 않았을 경우 발생하는 에러에 대응하기 위한 타입</li>
  <li>일반적으로 사용하는 타입 뒤에 <code class="language-plaintext highlighter-rouge">?</code>(물음표)를 붙이면 옵셔널 타입이 된다.
    <ul>
      <li>ex) <code class="language-plaintext highlighter-rouge">Int?</code>, <code class="language-plaintext highlighter-rouge">String?</code>
</li>
    </ul>
  </li>
</ul>

<h3 id="nil"><code class="language-plaintext highlighter-rouge">nil</code></h3>
<p>옵셔널을 이해하기 위해서는 <code class="language-plaintext highlighter-rouge">nil</code>에 대해서 먼저 알아야합니다.
<code class="language-plaintext highlighter-rouge">nil</code>은 값이 비어있음을 나타내는 키워드입니다. 다른 언어에서는 <code class="language-plaintext highlighter-rouge">null</code>로도 표현되곤 합니다.</p>

<h5 id="그런데-잠깐">그런데 잠깐!</h5>
<blockquote>
  <p>편의상으로는 <code class="language-plaintext highlighter-rouge">nil</code>과 <code class="language-plaintext highlighter-rouge">null</code>을 동일하다고 생각해도 되지만, 사실 둘은 다른 개념입니다. <code class="language-plaintext highlighter-rouge">null</code>은 메모리에 해당 값이 <strong>“없음”</strong> 을 표현하는 키워드이지만, <code class="language-plaintext highlighter-rouge">nil</code>은 아닙니다! Swift에서 <code class="language-plaintext highlighter-rouge">nil</code>은 비어있지 않고, 임시 열거형 타입의 값을 <strong>실제로 가집니다.</strong></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">nil</code> 값에 접근해야하는 위험이 있을 때, 직접적으로 메모리의 해당 공간에 접근하는 것이 아니라 <strong>임시적인 타입</strong>을 넣어두어 한 번 걸러주면 어떨까요?</p>

<p>따라서 옵셔널 타입은 엄연히 새로운 타입입니다.
<code class="language-plaintext highlighter-rouge">Int</code> 타입과 <code class="language-plaintext highlighter-rouge">Int?</code> 타입은 다른 타입인 것이죠.
옵셔널 타입은 원래의 타입 범위에 <code class="language-plaintext highlighter-rouge">nil</code> 값을 추가한 범위라고 정의할 수 있습니다.</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Int</code>
    <ul>
      <li>…, -4, -3, -2, -1, 0, 1, 2, 3, 4, …</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">Int?</code>
    <ul>
      <li>…, -4, -3, -2, -1, 0, 1, 2, 3, 4, … + <code class="language-plaintext highlighter-rouge">nil</code>
</li>
    </ul>
  </li>
</ul>

<h3 id="옵셔널-타입-선언의-기본-규칙">옵셔널 타입 선언의 기본 규칙</h3>
<ol>
  <li>
<code class="language-plaintext highlighter-rouge">nil</code>값을 대입할 수 있다.</li>
  <li>값을 넣어주지 않으면 자동으로 <code class="language-plaintext highlighter-rouge">nil</code>로 초기화된다.</li>
</ol>

<h3 id="정식-표기-문법">정식 표기 문법</h3>
<ul>
  <li>위에서 <code class="language-plaintext highlighter-rouge">Int?</code>와 같이 사용한다고 했지만, 이는 편의를 위한 간편 표기법이다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Optional&lt;Int&gt;</code>가 정식 문법</li>
</ul>

<h3 id="사용해보기">사용해보기</h3>

<pre><code class="language-Swift">var optionalNum: Int? = nil
optionalNum = 10

print(optionalNum) // Optional(10)
// Optional(10) != 10
</code></pre>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Non-Optional</code> 타입의 값을 <code class="language-plaintext highlighter-rouge">Optional</code> 타입의 변수에 대입할 수는 있다.</li>
  <li>대신 타입은 <code class="language-plaintext highlighter-rouge">Non-Optional</code>로 변환되어 들어간다.</li>
</ul>

<pre><code class="language-Swift">var a: Int? = 7
var c: Int = 5
a = c
print(a) // Optional(5)
</code></pre>

<ul>
  <li>옵셔널 타입의 연산은 어떨까요?</li>
</ul>

<pre><code class="language-Swift">var numA: Int? = 3
var numB: Int? = 4
numA + numB // Error: Binary operator '+' cannot be applied to two 'Int?' operands
</code></pre>

<ul>
  <li>불가능한 것을 알 수 있다.</li>
</ul>

<h3 id="옵셔널-타입에-대한-이해">옵셔널 타입에 대한 이해</h3>
<p>옵셔널 타입은 크게 보면 <code class="language-plaintext highlighter-rouge">enum</code> 형태의 타입입니다.
<code class="language-plaintext highlighter-rouge">Non-Optional</code> 타입과 <code class="language-plaintext highlighter-rouge">nil</code> 타입의 케이스로 나누어 처리하는 방식입니다.</p>

<h2 id="옵셔널-타입의-연산">옵셔널 타입의 연산</h2>

<p>위에서 우선 옵셔널 타입끼리의 연산은 불가능하다는 것을 확인하였습니다.
옵셔널 타입의 변수를 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">nil</code> 값을 제외한 값을 추출하는 과정이 필요합니다.</p>

<h3 id="옵셔널-값-추출-방법-4가지">옵셔널 값 추출 방법 4가지</h3>

<pre><code class="language-Swift">var num: Int?
var str: String? = "Hello!"
</code></pre>

<h4 id="강제-추출-forced-unwrapping">강제 추출 (Forced Unwrapping)</h4>
<ul>
  <li>값이 있다는 것이 확실할 때 사용
    <ul>
      <li>강제 추출 연산자 <code class="language-plaintext highlighter-rouge">!</code> 사용</li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">print(str!) // "Hello!"
print(num!) // Error
</code></pre>

<h4 id="if문을-사용하여-nil-값이-아니라는-것을-확인-후-강제-추출">
<code class="language-plaintext highlighter-rouge">if</code>문을 사용하여 <code class="language-plaintext highlighter-rouge">nil</code> 값이 아니라는 것을 확인 후, 강제 추출</h4>
<ul>
  <li>값이 있는지 확실하지 않다면, 확인한 후 강제 추출을 하면 된다.</li>
</ul>

<pre><code class="language-Swift">if str != nil {
	print(str!) // "Hello!"
}
</code></pre>

<h4 id="옵셔널-바인딩-if-let">옵셔널 바인딩 (<code class="language-plaintext highlighter-rouge">if let</code>)</h4>
<ul>
  <li>바인딩이 된다면, 특정 작업을 수행한다.</li>
  <li>조건을 만족하면, 메모리 영역에서 새로운 공간의 새로운 상수를 만들어 값을 추출해 복사하고 해당 상수를 사용한다.</li>
</ul>

<pre><code class="language-Swift">if let s = str { // s라는 상수에 값이 담긴다면,
	// 해당 스코프의 코드 실행
	print(s) // "Hello!"
}
</code></pre>

<ul>
  <li>실전에서 굉장히 많이 사용</li>
</ul>

<pre><code class="language-Swift">func doSomething(name: String?) {
	guard let n = name else { return }
	print(n)
}
</code></pre>

<h5 id="잠깐">잠깐!</h5>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">if let</code>은 알겠어요. 근데 <code class="language-plaintext highlighter-rouge">if var</code>는 안되나요?
    <blockquote>
      <p>아뇨 됩니다. 다만 보통의 경우 <code class="language-plaintext highlighter-rouge">Optional</code> 타입의 값을 추출한 뒤에 해당 값을 바로 사용하기 때문에 거의 사용되지 않는 방식입니다.</p>
    </blockquote>
  </li>
</ul>

<h4 id="닐-코얼레싱-nil-coalescing-연산자-사용">닐 코얼레싱 (Nil-Coalescing) 연산자 사용</h4>
<ul>
  <li>coalesce: 더 큰 덩어리로 합치다.</li>
  <li>옵셔널 타입에 대해 default 값을 제시할 수 있을 때 사용</li>
</ul>

<pre><code class="language-Swift">var serverName: String? = "Jake"
var userName = serverName ?? "Auth Fail"
</code></pre>

<pre><code class="language-Swift">var str: String?
print("안녕하세요" + (str ?? "Hi")) // "안녕하세요 Hi"
str = "Hello"
print("안녕하세요" + (str ?? "Hi")) // "안녕하세요 Hello"
</code></pre>

<h3 id="옵셔널-체이닝-optional-chaining">옵셔널 체이닝 (Optional Chaining)</h3>
<ul>
  <li>옵셔널 타입에 접근연산자를 사용할 때 사용하는 문법</li>
  <li>접근연산자를 사용할 때 <code class="language-plaintext highlighter-rouge">?</code>를 붙여서 앞의 타입이 <code class="language-plaintext highlighter-rouge">nil</code> 값을 가질 수 있음을 표기</li>
  <li>메모리 관점에서 힙 영역을 통해 .</li>
</ul>

<pre><code class="language-Swift">class Dog {
	var name: String?
	var weight: Int

	func sit() {
		print("앉았습니다.")
	}
}

var choco: Dog? = Dog()
choco?.name = "Choco"
print(choco?.name) // Optional("Choco")
choco?.sit() // "앉았습니다."
</code></pre>

<h4 id="옵셔널-체이닝의-특징">옵셔널 체이닝의 특징</h4>
<ul>
  <li>옵셔널 체이닝의 결과는 항상 옵셔널 타입이다.</li>
  <li>옵셔널 체이닝의 값 중에서 하나라도 <code class="language-plaintext highlighter-rouge">nil</code>을 <code class="language-plaintext highlighter-rouge">return</code>한다면, 이어지는 표현식들은 평가하지 않고 무조건 <code class="language-plaintext highlighter-rouge">nil</code>을 <code class="language-plaintext highlighter-rouge">return</code>한다.</li>
</ul>

<h2 id="iuo-implicitly-unwrapped-optionals-타입">IUO (Implicitly Unwrapped Optionals) 타입</h2>
<ul>
  <li>타입 선언시에 <code class="language-plaintext highlighter-rouge">!</code>가 붙어있는 타입
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">Optional</code>을 벗겨낼 준비가 되어있는 타입</li>
      <li>
<code class="language-plaintext highlighter-rouge">Non-Optional</code> 타입 변수에 담을 때, 자동으로 <code class="language-plaintext highlighter-rouge">Optional</code>을 벗겨내며 담김</li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">var number: Int! = 7
print(number) // Optional(7)
// 실제로 사용시에 벗겨지는 건 아니다...!
</code></pre>

<pre><code class="language-Swift">var number2: Int = number // 다른 변수에 담길 때 벗겨짐
print(number2) // 7

var number3 = number // 형식 추론을 사용할 때는 자동으로 벗겨지지 않음
print(number3) // Optional(7)

var number4 = number! // 강제로 벗기는 건 가능
print(number4) // 7
</code></pre>

<pre><code class="language-Swift">var name: String! = "Jake"
name.count // 값이 nil이 아닌 경우, 옵셔널 체이닝을 생략할 수 있지만, 값이 nil일 경우에는 Error가 발생한다.
</code></pre>

<h3 id="iuo-왜-알아야할까">IUO… 왜 알아야할까..?</h3>
<ul>
  <li>Storyboard에서 <code class="language-plaintext highlighter-rouge">IBOutlet</code>을 코드에 연결할 때, 다음과 같이 자동으로 선언된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">var label: UILabel!</code></li>
    </ul>
  </li>
  <li>
    <p>API에서 IUO 타입으로 <code class="language-plaintext highlighter-rouge">return</code>이 이루어질 때가 있다.</p>
  </li>
  <li>어렵게 생각하지 말자!
    <ul>
      <li>사용은 일반적인 옵셔널(<code class="language-plaintext highlighter-rouge">?</code>)과 동일하다!</li>
    </ul>
  </li>
</ul>

<h3 id="사용-예시">사용 예시</h3>

<pre><code class="language-Swift">class MyViewController: UIViewController {
	@IBOutlet weak var imageView: UIImageView!
	@IBOutlet weak var mainLabel: UILabel!

	override func viewDidLoad() {
		super.viewDidLoad()
	}

	imageView.image = UIImage(systemName: "pencil")
	mainLabel.font = UIFont.boldSystemFont(ofSize: 18.0)
}
</code></pre>

<p>위의 예시에서 연결된 <code class="language-plaintext highlighter-rouge">IBOutlet</code>들은 IUO 타입이기 때문에 <code class="language-plaintext highlighter-rouge">imageView.image</code>와 같이 사용할 때 옵셔널 체이닝이 필요 없었습니다.
만약 IUO 타입이 아니라면 코드는 다음과 같이 작성되어야 합니다.</p>
<pre><code class="language-Swift">imageView?.image = UIImage(systemName: "pencil")
</code></pre>
</body></html>
