<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>

<h1 id="구조체와-클래스의-속성">구조체와 클래스의 속성</h1>

<h2 id="저장-속성-stored-properties">저장 속성 (Stored Properties)</h2>

<h3 id="저장-속성-stored-properties-1">저장 속성 (Stored Properties)</h3>
<ul>
  <li>값이 저장되는 일반적인 속성(변수)</li>
  <li>특정한 메모리 공간을 가지고 그 안에 값을 저장할 수 있는 속성</li>
</ul>

<pre><code class="language-Swift">struct Bird {
	// 저장 속성
	var name: String
	var weight: Double

	func fly() {
		print("날아갑니다.")
	}
}
</code></pre>

<h4 id="주의점">주의점</h4>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">let</code>과 <code class="language-plaintext highlighter-rouge">var</code>로 선언 가능</li>
  <li>각 속성 자체가 <strong>고유의 메모리 공간</strong>을 가짐</li>
  <li>초기화 이전에 값을 가지고 있거나 생성자를 통해 <strong>값을 초기화</strong>해주어야 한다.</li>
</ul>

<h3 id="지연-저장-속성-lazy-stored-properties">지연 저장 속성 (Lazy Stored Properties)</h3>
<ul>
  <li>해당 속성의 초기화를 지연시킨다.
    <ul>
      <li>인스턴스가 초기화되는 시점에 해당 속성을 초기화하지 않고, 해당 속성에 접근할 때 개별적으로 초기화된다.</li>
    </ul>
  </li>
  <li>상수(<code class="language-plaintext highlighter-rouge">let</code>)으로의 선언이 불가능 (<code class="language-plaintext highlighter-rouge">lazy var</code>로만 가능)</li>
  <li>초기화 시점을 늦췄기 때문에 <code class="language-plaintext highlighter-rouge">init</code>에서 초기화하면 제 기능을 못한다.
    <ul>
      <li>접근될 때 초기화되더라도 그 시점에 초기값은 필요하기에 기본값이 설정되어야 한다.</li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">struct Bird {
	var name: String
	lazy var weight: Double = 0.2 // 지연 저장 속성

	init(name: String) {
		self.name = name
	}

	func fly() {
		print("날아갑니다.")
	}
}

var aBird = Bird(name: "새")
aBird.weight // 해당 시점에 weight 속성 초기화
</code></pre>

<h4 id="주의점-1">주의점</h4>
<ul>
  <li>기본값으로는 값을 넣거나 표현식을 넣을 수 있다.
    <ul>
      <li>함수 호출 코드, 계산 코드, 클로저 코드</li>
      <li>
<code class="language-plaintext highlighter-rouge">return</code> 타입만 일치한다면!</li>
    </ul>
  </li>
</ul>

<h4 id="지연-저장-속성을-사용하는-이유">지연 저장 속성을 사용하는 이유?</h4>
<ol>
  <li>메모리를 많이 사용할 때</li>
  <li>다른 속성을 이용해야 할 때
    <ul>
      <li>모든 속성들은 동시에 초기화된다.</li>
      <li>따라서 다른 속성에 의존하는 속성일 경우, 초기화가 제대로 되지 않을 가능성이 있다.</li>
    </ul>
  </li>
</ol>

<pre><code class="language-Swift">class AView {
	var a: Int

	lazy var view = UIImageView()

	lazy var b: Int = {
		return a * 10 // 속성 a가 필요
	}()

	init(num: Int) {
		self.a = num
	}
}
</code></pre>

<h2 id="계산-속성-computed-properties">계산 속성 (Computed Properties)</h2>
<ul>
  <li>속성의 형태를 가진 실질적 메서드
    <ul>
      <li>인스턴스에 메모리 공간이 할당되어 있지 않음 (메서드이기 때문)</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">get</code>, <code class="language-plaintext highlighter-rouge">set</code>
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">get</code>만 선언할 경우 읽기전용(read-only) 계산 속성</li>
      <li>
<code class="language-plaintext highlighter-rouge">set</code>은 선택적으로 구현
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">newValue</code> 사용 시 유용</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="예시1">예시1</h3>
<pre><code class="language-Swift">class Person {
	var birth: Int = 0

	var age: Int { // 계산 속성
		get { // get-block (getter)
			return 2021 - birth
		}
		// 1. set default
		set(age) { // set-block (setter)
			self.birth = 2021 - age
		}
		// 2. set using newValue
		set {
			self.birth = 2021 - newValue
		}
	}
}

var p1 = Person()
p1.birth = 2000
print(p1.age) // 21 (get)
p1.age = 20 // (set)
print(p1.birth) // 2001
</code></pre>

<h3 id="예시2">예시2</h3>
<ul>
  <li>계산 속성이 아닌 방식으로 구현</li>
</ul>

<pre><code class="language-Swift">class Person {
	var name: String = "사람"
	var height: Double = 160.0
	var weight: Double = 60.0

	func calculateBMI() -&gt; Double {
		let bmi = weight / (height * height) * 10000
		return bmi
	}
}

let p = Person()
p.height = 165
p.weight = 65

p.calculateBMI()
</code></pre>

<ul>
  <li>계산 속성으로 구현</li>
</ul>

<pre><code class="language-Swift">class Person {
	var name: String = "사람"
	var height: Double = 160.0
	var weight: Double = 60.0

	var bmi: Double {
		get {
			let result = weight / (height * height) * 10000
			return result
		}
		set { // 키는 변하지 않는다는 가정 하에
			weight = newValue * height * height / 10000
		}
	}
}

let p = Person()
p.height = 165
p.weight = 65
print(p.bmi) // 23.875...
</code></pre>

<h3 id="장점">장점</h3>
<ul>
  <li>관련이 있는 두 가지 메서드를 한 번에 구현</li>
  <li>외부에서 보기에 속성 이름으로 설정</li>
</ul>

<h3 id="주의점-2">주의점</h3>
<ul>
  <li>항상 변하는 값이므로 <code class="language-plaintext highlighter-rouge">var</code>로 선언</li>
  <li>자료형을 반드시 선언 (형식 추론 불가)</li>
  <li>
<code class="language-plaintext highlighter-rouge">get</code>은 필수, <code class="language-plaintext highlighter-rouge">set</code>은 선택</li>
</ul>

<h2 id="타입-속성-type-properties">타입 속성 (Type Properties)</h2>
<ul>
  <li>인스턴스에 속한 속성이 아닌 타입 자체에 속한 속성</li>
  <li>데이터 공간에 <strong>고정</strong>된 모든 인스턴스들이 <strong>공유</strong>하는 속성</li>
</ul>

<h3 id="저장-타입-속성">저장 타입 속성</h3>
<ul>
  <li>생성자(<code class="language-plaintext highlighter-rouge">init</code>)가 없다. 타입 자체에 속한 속성
    <ul>
      <li>기본값 필요</li>
    </ul>
  </li>
  <li>지연 속성의 성격을 갖는다.
    <ul>
      <li>참고: 여러 스레드에서 동시에 접근해도 한 번만 초기화 (Thread-Safe)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">static</code></li>
</ul>

<pre><code class="language-Swift">class Dog {
	static let species: String = "Dog" // 저장 타입 속성

	var name: String
	var weight: Double

	init(name: String, weight: Double) {
		self.name = name
		self.weight = weight
	}
}

// 타입 자체에 접근해야한다.
print(Dog.species) // "Dog"
</code></pre>

<pre><code class="language-Swift">class Circle {
	static let pi: Double = 3.14
	static var count: Int = 0

	var radius: Double

	var diameter: Double {
		get {
			return radius * 2
		}
		set {
			radius = newValue / 2
		}
	}

	init(radius: Double) {
		self.radius = radius
		Circle.count += 1
	}
}

var circle = Circle(radius: 2)
print(Circle.count) // 1
var circle2 = circle(radius: 3)
print(Circle.count) // 2

print(Circle.pi) // 3.14
</code></pre>

<h4 id="주의점-3">주의점</h4>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">let</code>과 <code class="language-plaintext highlighter-rouge">var</code> 둘 다 가능</li>
  <li>인스턴스에 속한 속성이 아니기 때문에 인스턴스를 통해서는 접근 불가</li>
</ul>

<h3 id="계산-타입-속성">계산 타입 속성</h3>

<pre><code class="language-Swift">class Circle {
	static let pi: Double = 3.14
	static var count: Int = 0

	static var multiPi: Double { // 계산 타입 속성
		return pi * 2 // Circle.pi
	}

	var radius: Double

	init(radius: Double) {
		self.radius = radius
	}
}

let b = Circle.multiPi
print(b) // 6.28
</code></pre>

<h3 id="어떤-경우에-타입-속성을-사용할까">어떤 경우에 타입 속성을 사용할까?</h3>
<ul>
  <li>모든 인스턴스가 동일하게 가져야 하는 속성</li>
  <li>모든 인스턴스가 공유해야하는 성격에 가까운 값</li>
  <li>상속에서 재정의
    <ul>
      <li>저장 타입 속성: 하위 클래스에서 재정의 불가능 (<code class="language-plaintext highlighter-rouge">class</code> 키워드 불가)</li>
      <li>계산 타입 속성: 상위 클래스에서 <code class="language-plaintext highlighter-rouge">class</code> 키워드를 붙인 경우 재정의 가능</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">class</code> 키워드
    <ul>
      <li>상속이 있는 경우, 계산 타입 속성에서는 <code class="language-plaintext highlighter-rouge">static</code> 대신  <code class="language-plaintext highlighter-rouge">class</code> 사용</li>
    </ul>
  </li>
</ul>

<h2 id="속성-감시자-property-observer">속성 감시자 (Property Observer)</h2>
<ul>
  <li>(저장) 속성 감시자</li>
  <li>메서드의 형태로서 저장 속성을 감시한다.</li>
  <li>저장 속성의 값이 바뀔 때 실행되는 메서드</li>
  <li>
<code class="language-plaintext highlighter-rouge">willSet</code>, <code class="language-plaintext highlighter-rouge">didSet</code>
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">willSet</code>: 바뀌기 전에 실행</li>
      <li>
<code class="language-plaintext highlighter-rouge">didSet</code>: 바뀐 후에 실행</li>
    </ul>
  </li>
</ul>

<pre><code class="language-Swift">class Profile {
	var name: String = "이름"

	var statusMessage: String = "기본 상태 메시지" {
		willSet(message) {
			print("메시지가 \(statusMessage)에서 \(message)로 변경될 예정입니다.")
			print("상태 메시지 업데이트 준비")
		}
		didSet(message) {
			print("메시지가 \(message)에서 \(statusMessage)로 이미 변경되었습니다.")
		}
	}
}

let p = Profile()

print(p.statusMessage) // "기본 상태 메시지"
p.statusMessage = "행복해"
// "메시지가 기본 상태 메시지에서 행복해로 변경될 예정입니다."
// "상태 메시지 업데이트 준비"
// willSet 구문 실행
</code></pre>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">oldValue</code>, <code class="language-plaintext highlighter-rouge">newValue</code>
</li>
</ul>

<pre><code class="language-Swift">class Profile {
	var name: String = "이름"

	var statusMessage = "기본 상태 메시지" {
		willSet {
			print("메시지가 \(statusMessage)에서 \(newValue)로 변경될 예정입니다.")
		}
		didSet {
			print("메시지가 \(oldValue)에서 \(statusMessage)로 변경되었습니다.")
		}
	}
}
</code></pre>

<h3 id="주의점-4">주의점</h3>
<ul>
  <li>저장 속성
    <ul>
      <li>
<strong>저장 속성</strong>에만 가능하다고 생각하는게 편하다!</li>
    </ul>
  </li>
  <li>계산 속성 (상속해서 재정의하는 경우에만 가능)
    <ul>
      <li>억지로 쓴다고 봐야…</li>
      <li>
<code class="language-plaintext highlighter-rouge">setter</code>에서 처리하는 것이 훠얼씬 편리하다.</li>
    </ul>
  </li>
  <li>실제로 수치적인 값이 변경되는 것이 아니라도, 값을 <code class="language-plaintext highlighter-rouge">set</code>하는 과정이 있다면 호출된다.</li>
</ul>
</body></html>
