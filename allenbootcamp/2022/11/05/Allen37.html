<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>

<h1 id="arc-automatic-reference-counting">ARC (Automatic Reference Counting)</h1>

<h2 id="스위프트의-메모리-관리-모델">스위프트의 메모리 관리 모델</h2>

<h3 id="값-형식과-참조-형식">값 형식과 참조 형식</h3>
<p>메모리 관리에 대해 공부하기 전에 메모리 관리가 어떤 때에 필요한 지 먼저 알아보겠습니다.</p>

<h4 id="값-형식">값 형식</h4>
<ul>
  <li>필요시에 메모리의 스택 영역에 값을 저장합니다.</li>
  <li>값이 들어있는 스택 영역의 스코프가 종료되면 메모리에서 자동으로 해제됩니다.</li>
  <li>Swift의 기본 타입(Int, String, …)들, 튜플, 구조체, 열거형, 컬렉션 등</li>
</ul>

<h4 id="참조-형식">참조 형식</h4>
<ul>
  <li>필요시에 메모리의 힙 영역에 값을 저장하고, 스택 영역에 주소를 저장합니다.</li>
  <li>
<strong>RC(Reference Counting)</strong> 을 통해 메모리를 관리합니다. ➡️ <strong>ARC</strong>
</li>
  <li>클래스, 클로저</li>
</ul>

<p>값 형식과 참조 형식의 차이점을 보면 알 수 있듯이, 참조 형식의 데이터들은 힙 영역에 저장되기 때문에 별도의 Reference Counting 모델이 필요합니다.</p>

<blockquote>
  <p>힙 영역 데이터에는 왜 별도의 관리 모델이 필요한건가요?</p>
</blockquote>

<h5 id="메모리의-구조">메모리의 구조</h5>
<p>힙 영역과 스택 영역의 차이점을 기억해내기 위해 메모리의 구조를 한 번 복습해볼까요?</p>
<ul>
  <li>
<strong>코드</strong>: 명령어 / 프로그램</li>
  <li>
<strong>데이터</strong>: 전역 변수 / 타입 변수
    <ul>
      <li>앱이 실행되는 공간 변하지 않는 공유하기 위한 데이터</li>
    </ul>
  </li>
  <li>
<strong>힙</strong>: 동적 할당
    <ul>
      <li>크기가 크고, 관리가 필요한 데이터</li>
    </ul>
  </li>
  <li>
<strong>스택</strong>: 함수 실행을 위한 임시 공간
    <ul>
      <li>크기가 작고 단기간 사용하기 위한 데이터</li>
    </ul>
  </li>
</ul>

<p><strong>스택 영역</strong>의 데이터들은 빠르게 사용되고 빠르게 해제되기 때문에 메모리 관리가 별도로 필요하지 않습니다. <strong>데이터 영역</strong>의 데이터들은 프로그램이 실행되는 동안 유지되는 불변의 데이터이기 때문에 마찬가지로 해제가 필요하지 않습니다.</p>

<p>하지만 힙 영역의 데이터들은 스택 영역에 비해 비교적 오랜 기간 머물면서, 동적 할당되기 때문에 빈 공간에 임의로 영역을 잡아 저장됩니다.</p>

<p>문제는 힙 영역의 데이터는 관리를 해주지 않으면 계속해서 메모리를 잡아먹으면서 상주한다는 점입니다. 이를 <strong>메모리 누수(Memory Leak)</strong> 라고 부릅니다.</p>

<p>이 문제를 해결하기 위해 Swift에서는 <strong>ARC</strong>라는 메모리 관리 모델이 적용되었습니다.</p>

<h3 id="java와-obj-c-swift의-메모리-관리-모델">Java와 Obj-C, Swift의 메모리 관리 모델</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>Java</strong></th>
      <th style="text-align: center"><strong>Obj-C</strong></th>
      <th style="text-align: center"><strong>Swift</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Garbage Collector)</td>
      <td style="text-align: center">MRC + ARC</td>
      <td style="text-align: center">ARC</td>
    </tr>
  </tbody>
</table>

<h4 id="java의-garbage-collector">Java의 Garbage Collector</h4>

<p>메모리 누수가 힙 영역의 메모리 할당 문제라면, 이 문제는 Swift 뿐만 아니라 다른 언어에서도 발생하는 문제일 것입니다.</p>

<p>객체기반 언어의 어머니라고 불리는 Java에서는 Garbage Collector라는 모델이 적용되었습니다.</p>

<p><strong>Garbage Collector</strong> 모델은 프로그램 실행중(런타임)에 힙 영역에 할당된 모든 데이터들을 스캔합니다. 그 후에 해제되어도 되겠다고 판단되는 데이터들을 알아서 메모리에서 해제해줍니다.</p>

<p>따라서 이 모델의 장점은 개발자가 따로 신경 써주지 않아도 알아서 메모리 누수 관리가 된다는 점입니다. 반대로 단점은 힙 영역을 모두 스캔하는 과정이 필요로 하기 때문에 비교적 느리다는 점이 있습니다.</p>

<h4 id="swift의-reference-counting">Swift의 Reference Counting</h4>

<p><strong>Reference Counting</strong> 모델은 할당된 데이터가 참조되고 있는 곳의 수를 세면서 참조 카운터가 0이 되는 순간 메모리에서 해제되는 모델입니다.</p>

<p>이 RC 모델은 카운팅을 개발자가 수동으로 해줘야하는 <strong>MRC(Manual RC)</strong> 모델과 컴파일러가 자동으로 수행해주는 <strong>ARC(Automatic RC)</strong> 모델로 나뉩니다.</p>

<p>Swift 이전에 쓰였던 Obj-C 언어에서는 MRC와 ARC 모델을 섞어서 사용하였지만, Swift 언어로 넘어온 후부터는 ARC 모델만을 사용하게 되었습니다.</p>

<h5 id="주의">주의</h5>
<p>ARC 모델은 Java의 Garbage Collector 모델과는 다르게 메모리 관리 자체를 자동으로 해주지는 않습니다.</p>

<p>ARC 모델의 Automatic은 <strong>Reference Counting을 자동으로 해준다</strong>는 점에 초점이 맞춰져 있습니다. 따라서 이 카운팅되는 법칙을 개발자가 잘 알지 못하고 사용한다면, 원하지 않을 때 카운터가 증가될수도, 감소될수도 있습니다.</p>

<h2 id="mrc-manual-reference-counting">MRC (Manual Reference Counting)</h2>

<p><img src="https://i.imgur.com/Kzh9oUV.png" alt=""></p>

<p>위 예시는 애플이 wwdc2016에서 발표한 내용입니다.</p>

<p>XCode는 실제로 개발자가 작성한 코드(왼쪽)에 ARC를 위한 코드들을 삽입(오른쪽)하여 컴파일합니다. <code class="language-plaintext highlighter-rouge">refCount</code>라는 카운터 변수를 클래스에 넣어주고, <code class="language-plaintext highlighter-rouge">retain</code>과 <code class="language-plaintext highlighter-rouge">release</code>를 통해 카운터를 증가시키거나 감소시킨다는 것을 볼 수 있습니다.</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">retain</code>: 메모리 할당 (RC + 1)</li>
  <li>
<code class="language-plaintext highlighter-rouge">release</code>: 메모리 해제 (RC - 1)</li>
</ul>

<p>MRC 모델을 사용할 때는 이와 같은 코드들을 개발자가 직접 넣어주어야 했습니다. ARC 모델을 사용하는 지금은 XCode가 컴파일할 때 자동으로 추가해줍니다!</p>

<pre><code class="language-Swift">class Dog {
	var name: String
	var weight: Double

	init(name: String, weight: Double) {
		self.name = name
		self.weight = weight
	}

	deinit {
		print("\(name) 메모리 해제")
	}
}

var choco: Dog? = Dog(name: "초코", weight: 15.0) // retain(choco) RC 1
var bori: Dog? = Dog(name: "보리", weight: 10.0) // retain(choco) RC 1

choco = nil // "초코 메모리 해제" RC 0
// release(choco)
bori = nil // "보리 메모리 해제" RC 0
// release(bori)
</code></pre>

<h2 id="강한-참조-사이클과-메모리-누수">강한 참조 사이클과 메모리 누수</h2>
<p>강한 참조 사이클은 객체가 <strong>서로를 참조</strong>하는 상황에서 일어납니다.</p>

<p>객체가 서로를 참조하게 되면 <strong>서로의 Reference Count를 1씩 증가</strong>시킵니다.</p>

<p>이런 상황이 발생하면 두 객체에 <code class="language-plaintext highlighter-rouge">nil</code>을 할당한다고 해도 서로의 RC를 계속해서 유지하고 있기 때문에 해제되지 못하고 상주하게 되는 문제가 발생합니다.</p>

<p>이를 <strong>메모리 누수(Memory Leak)</strong> 라고 부릅니다.</p>

<pre><code class="language-Swift">class Dog {
	var name: String
	var owner: Person?

	init(name: String) {
		self.name = name
	}

	deinit {
		print("\(name) 메모리 해제")
	}
}

class Person {
	var name: String
	var pet: Dog?

	init(name: String) {
		self.name = name
	}

	deinit {
		print("\(name) 메모리 해제")
	}
}

var bori: Dog? = Dog(name: "보리")
var gildong: Person? = Person(name: "홍길동")

bori?.owner = gildong
gildong?.pet = bori
// 강한 참조 사이클 발생

// bori?.owner = nil
// gildong?.pet = nil
// 강한 참조 사이클을 해소하려면 서로의 참조를 끊어주어야 한다.

bori = nil
gildong = nil
// nil로 해제해주었지만, 강한 참조 사이클로 인해 메모리에서 해제되지 못함
// deinit에 들어있는 print문이 실행되지 않음
</code></pre>

<h3 id="메모리-누수의-해결-방안">메모리 누수의 해결 방안</h3>
<ol>
  <li>RC를 고려하며 참조 해제 순서를 주의하며 코드 작성
    <ul>
      <li>신경쓸 것이 많고 실수할 가능성이 큼</li>
    </ul>
  </li>
  <li>약한 참조(Weak Reference) 사용</li>
  <li>비소유 참조(Unowned Reference) 사용</li>
</ol>

<p>위 세 가지 방법 중에서 첫 번째 방법은 너무나 번거롭고 실수가 일어나기 쉬운 방법입니다. 그다지 좋은 방법이 아니라는 뜻이죠.</p>

<p>그래서 그 대안으로 두 번째와 세 번째 방법이 있습니다.</p>

<p>이 두 방법은 <strong>서로의 RC를 증가시키지 않으면서 참조</strong>한다는 공통적인 특징이 있습니다.</p>

<h4 id="약한-참조-weak-reference">약한 참조 (Weak Reference)</h4>

<pre><code class="language-Swift">class Dog {
	var name: String
	weak var owner: Person?

	init(name: String) {
		self.name = name
	}

	deinit {
		print("\(name) 메모리 해제")
	}
}

class Person {
	var name: String
	weak var pet: Dog?

	init(name: String) {
		self.name = name
	}

	deinit {
		print("\(name) 메모리 해제")
	}
}

var bori: Dog? = Dog(name: "보리")
var gildong: Person? = Person(name: "홍길동")

bori?.owner = gildong
gildong?.pet = bori

bori = nil // 보리 메모리 해제
gildong = nil // 홍길동 메모리 해제
</code></pre>

<p>위의 예시와 같은 예시이지만 서로의 참조 부분 앞에 <code class="language-plaintext highlighter-rouge">weak</code> 키워드를 넣어주어서 약한 참조를 하도록 해주었습니다.</p>

<p>이 경우에는 서로의 RC를 증가시키지 않기 때문에, 각각을 <code class="language-plaintext highlighter-rouge">nil</code>로 만들어주면 RC가 0이 되어 메모리에서 해제됩니다.</p>

<p>한 가지 알아두어야 할 점이 있습니다. <strong>약한 참조</strong>의 경우에는 참조하고 있던 인스턴스가 사라지면, 해당 속성을  <strong><code class="language-plaintext highlighter-rouge">nil</code> 값으로 자동으로 초기화</strong>합니다.</p>

<pre><code class="language-Swift">gildong = nil
print(bori?.owner) // nil
</code></pre>

<p>위의 예시에서 <code class="language-plaintext highlighter-rouge">gildong</code>에 <code class="language-plaintext highlighter-rouge">nil</code> 값을 주면, 이 <code class="language-plaintext highlighter-rouge">gildong</code>을 참조하고 있던 <code class="language-plaintext highlighter-rouge">bori</code>의 <code class="language-plaintext highlighter-rouge">owner</code>이라는 속성도 자동으로 <code class="language-plaintext highlighter-rouge">nil</code> 값으로 초기화된다는 뜻입니다.</p>

<h4 id="비소유-참조-unowned-reference">비소유 참조 (Unowned Reference)</h4>
<p>비소유 참조도 약한 참조와 마찬가지로 참조 타입의 변수 선언 시에 앞에 <code class="language-plaintext highlighter-rouge">unowned</code>라는 키워드를 붙여서 선언할 수 있습니다.</p>

<p>약한 참조와의 차이점은 참조하고 있던 인스턴스가 사라져도 해당 속성을 <code class="language-plaintext highlighter-rouge">nil</code>로 초기화하지 않는다는 점입니다.</p>

<pre><code class="language-Swift">gildong = nil
print(bori?.owner) // ERROR: 실제로 메모리에 값이 없음 (nil X)
</code></pre>

<p>위 코드는 약한 참조때와는 다르게 에러가 발생하며 프로그램이 종료됩니다. 비소유 참조는 <code class="language-plaintext highlighter-rouge">nil</code>로 초기화하지 않기 때문에 실제로 해당 메모리에 아무런 값이 없기 때문입니다.</p>

<p>그래서 비소유 참조는 직접 <code class="language-plaintext highlighter-rouge">nil</code> 값을 초기화해주어야 합니다.</p>

<pre><code class="language-Swift">gildong = nil
bori?.owner = nil
print(bori?.owner) // nil
</code></pre>

<blockquote>
  <p>그러면 약한 참조와 비소유 참조는 각각 어떤 상황에 사용해야 적절할까요?</p>
</blockquote>

<p>두 참조 방식 모두 RC를 증가시키지 않는다는 공통점을 갖고 있습니다. 하지만 참조하던 값이 사라지면 <code class="language-plaintext highlighter-rouge">nil</code> 값으로 자동으로 초기화되는지 아닌지에 따라 역할이 구분됩니다.</p>

<p>소유자에 비해 짧은 생명주기를 가진 인스턴스를 참조할 때는 약한 참조(<code class="language-plaintext highlighter-rouge">weak</code>)를 사용하면 좋습니다. 반대로 소유자보다 인스턴스의 생명주기가 더 길거나 같은 경우에는 비소유 참조(<code class="language-plaintext highlighter-rouge">unowned</code>)를 사용하면 좋습니다.</p>

<p>한마디로 한 인스턴스가 참조하는 인스턴스보다 더 오래 메모리에 유지될 경우에는 <code class="language-plaintext highlighter-rouge">weak</code>을, 더 일찍 해제될 경우에는 <code class="language-plaintext highlighter-rouge">unowned</code>를 사용하면 좋습니다.</p>

<p><code class="language-plaintext highlighter-rouge">unowned</code>의 속도가 더 빠르다고 하지만 그 차이가 미미하고, <code class="language-plaintext highlighter-rouge">unowned</code>는 고려해야할 사항이 하나 더 생기는 것이기 때문에 실제 사용시에는 <code class="language-plaintext highlighter-rouge">weak</code>만 사용해도 무방하다고 합니다.</p>

<h2 id="클로저와-메모리-관리">클로저와 메모리 관리</h2>

<p><a href="https://stansign.github.io/allenbootcamp/2022/11/01/Allen35.html#h-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC"># 35)🧰 Swift - 클로저 (Closure)</a></p>

<p>여기부터의 내용은 클로저에 대한 이해가 필요합니다. 
이전 게시물을 확인해주세요!</p>

<h3 id="캡처리스트의-형태">캡처리스트의 형태</h3>
<ol>
  <li>파라미터가 없는 경우</li>
</ol>

<pre><code class="language-Swift">{ [캡처리스트] in
	print("프린트")
}
</code></pre>

<ol>
  <li>파라미터가 있는 경우</li>
</ol>

<pre><code class="language-Swift">{ [캡처리스트] (파라미터) -&gt; 리턴형 in
	 print("프린트")
}
</code></pre>

<pre><code class="language-Swift">func calculate() -&gt; ((Int) -&gt; Int) {
	var sum = 0

	func square(num: Int) -&gt; Int {
		sum += (num * num)
		return sum
	}

	return square
}

var squareFunc = calculateFunc()
squareFunc(10) // 100
squareFunc(20) // 500
squareFunc(30) // 1400
</code></pre>

<p>위 예시의 캡처 현상을 기억하시나요?</p>

<p><code class="language-plaintext highlighter-rouge">squareFunc</code>에 저장한 <code class="language-plaintext highlighter-rouge">square</code> 함수를 실행하기 위해 필요한 <code class="language-plaintext highlighter-rouge">sum</code>이라는 변수는 <code class="language-plaintext highlighter-rouge">calculateFunc</code> 함수의 실행이 종료되면서 메모리에서 해제됩니다.</p>

<p>이럴 때 발생하는 필연적인 에러를 방지하기 위해 <code class="language-plaintext highlighter-rouge">squareFunc</code>에 함수가 할당될 때 내부에 있지는 않지만 <strong>필요한 변수들의 값을 해당 시점에 캡처</strong>하여 <strong>함께 저장</strong>해두는 현상이였습니다.</p>

<p>이런 이유로 <strong>클로저가 외부 변수를 사용하는 경우</strong>에는 <strong>무조건! 캡처가 발생</strong>됩니다.</p>

<h3 id="클로저-실행-시-값-타입의-캡처">클로저 실행 시 값 타입의 캡처</h3>

<h4 id="캡처-리스트를-사용하지-않은-경우">캡처 리스트를 사용하지 않은 경우</h4>

<pre><code class="language-Swift">var num = 1
let valueCaptureClosure = {
	print("밸류 값 출력(캡처): \(num)")
}

num = 7
valueCaptureClosure() // 7

num = 1
valueCaptureClosure() // 1
</code></pre>

<p>이 예시의 <code class="language-plaintext highlighter-rouge">valueCaptureClosure</code>는 <strong>캡처 리스트를 사용하지 않은</strong> 예시입니다.</p>

<p>외부에 있는 <code class="language-plaintext highlighter-rouge">num</code> 변수를 사용하기 위해 변수를 캡처 해야하는데, <strong>캡처 리스트를 사용하지 않은 경우</strong>에는 힙 영역의 클로저는 <strong>변수의 주소를 캡처</strong>합니다.</p>

<p>그래서 <code class="language-plaintext highlighter-rouge">num</code> 변수의 값을 바꾼 후에 <code class="language-plaintext highlighter-rouge">valueCaptureClosure</code>를 실행시키면, 바뀐 변수의 값을 받아올 수 있는 것입니다.</p>

<h4 id="캡처-리스트를-사용한-경우">캡처 리스트를 사용한 경우</h4>

<pre><code class="language-Swift">var num = 1
let valueCaptureListClosure = { [num] in
	print("밸류 값 출력(캡처리스트): \(num)")
}

num = 7
valueCaptureListClosure() // 1
</code></pre>

<p>이번 예시의 <code class="language-plaintext highlighter-rouge">valueCaptureListClosure</code>는 <strong>캡처 리스트를 사용한</strong> 예시입니다.</p>

<p>마찬가지로 외부에 있는 <code class="language-plaintext highlighter-rouge">num</code> 변수를 캡처하는데, <strong>캡처 리스트를 사용</strong>했기 때문에 주소가 아니라 <strong>값 자체를 힙 영역에 함께 복사하여 캡처</strong>합니다.</p>

<p>따라서 <code class="language-plaintext highlighter-rouge">num</code> 변수의 값을 바꾸더라도 바뀐 값이 적용되지 않고 힙 영역에 저장된 값을 계속 사용하게 됩니다.</p>

<h3 id="클로저-실행-시-참조-타입의-캡처">클로저 실행 시 참조 타입의 캡처</h3>

<p>지금까지의 예시는 값 타입의 변수들을 캡처할 때 발생하는 일들이였습니다.</p>

<p>그렇다면 <code class="language-plaintext highlighter-rouge">class</code>나 <code class="language-plaintext highlighter-rouge">closure</code> 같은 참조 타입을 캡처할 때는 어떤 일이 발생할까요?</p>

<pre><code class="language-Swift">class SomeClass {
	var num = 0
}

var x = SomeClass()
var y = SomeClass()

print(x.num, y.num) // 0, 0

let refTypeCapture = { [x] in
	print("참조 출력 값(캡처리스트): ", x.num, y.num)
}

x.num = 1
y.num = 1

print(x.num, y.num) // 1, 1
refTypeCapture() // 1, 1
print(x.num, y.num) // 1, 1
</code></pre>

<p><code class="language-plaintext highlighter-rouge">refTypeCapture</code> 부분을 보면 <code class="language-plaintext highlighter-rouge">[x]</code>와 같이 <code class="language-plaintext highlighter-rouge">x</code> 클래스만 캡처리스트를 통해 받아온 것을 확인할 수 있습니다.</p>

<p>두 값을 바꾼 후에 출력을 했을 때 값 타입때와는 다르게 이번에는 두 값 모두 바뀐 상태로 출력되었습니다.</p>

<p>이런 일이 일어난 이유는 참조 타입임을 생각해보면 알 수 있습니다.</p>

<p>먼저 캡처 리스트를 통해 복사해서 사용한 <code class="language-plaintext highlighter-rouge">x</code> 클래스의 경우에는 값 타입때와 같은 이유로 <code class="language-plaintext highlighter-rouge">x</code> 인스턴스의 주소값을 그대로 복사하여 저장했기 때문에 바로 힙 영역의 인스턴스로 찾아가 값이 바뀌었습니다.</p>

<p>문제는 <code class="language-plaintext highlighter-rouge">y</code> 클래스인데, 클래스는 <strong>참조 타입</strong>이기 때문에 힙 영역의 클로저에서 <strong>스택 영역의 원본의 주소</strong>로 찾아가게 되면, 그곳에는 또 <strong>힙 영역에 할당되어 있는 원본 <code class="language-plaintext highlighter-rouge">y</code> 인스턴스의 주소</strong>가 담겨있습니다.</p>

<ul>
  <li>힙 영역의 클로저(<code class="language-plaintext highlighter-rouge">y</code> 변수의 주소) ➡️ 스택 영역의 변수 (<code class="language-plaintext highlighter-rouge">y</code>의 주소) ➡️ 힙 영역의 인스턴스</li>
</ul>

<p>이렇게 결국 원본의 주소에 찾아가게 되기 때문에 값의 변경이 적용될 수 있었던 것입니다.</p>

<h3 id="강한-참조-사이클-문제의-해결">강한 참조 사이클 문제의 해결</h3>

<p>자 그런데 참조하면 고려해야할 점이 하나 있습니다.
바로 메모리의 천적 <strong>강한 참조</strong>입니다.</p>

<pre><code class="language-Swift">var z = SomeClass()
let refTypeCapture = { [z] in
	print("참조 출력값(캡처리스트): ", z.num)
}
</code></pre>

<p>참조 타입을 캡처하면 주소를 갖게 되고 인스턴스의 RC를 하나 올리게 됩니다. 이 말은 곧 캡처된 인스턴스가 다시 클로저를 참조하게 되면 강한 참조가 발생한다는 의미가 될 것입니다.</p>

<p>그래서 캡처리스트에도 약한 참조(<code class="language-plaintext highlighter-rouge">weak</code>)와 비소유 참조(<code class="language-plaintext highlighter-rouge">unowned</code>)를 사용할 수 있습니다.</p>

<pre><code class="language-Swift">var z = SomeClass()
let refTypeCapture = { [weak z] in
	print("참조 출력값(캡처리스트):", z?.num)
}
</code></pre>

<p>약한 참조와 비소유 참조의 경우 , 할당이 해제되면 값이 사라질 수 있기 때문에 <code class="language-plaintext highlighter-rouge">Optional</code>로 결과가 나왔었죠. 여기서도 마찬가지인 점 유의합시다.</p>

<blockquote>
  <p>강한 참조..? 오히려 좋아</p>
</blockquote>

<p>그런데 강한 참조가 꼭 나쁜 것이냐 하면 그건 또 아닙니다. 강한 참조의 특징은 RC를 증가시킨다는 것이고, RC가 증가하면 메모리에서 해제가 되지 않겠죠.</p>

<p>정말 꼭 필요한 인스턴스라면 강한 참조를 사용해서 오히려 RC를 일부러 증가시켜 외부 요인들로 인해서 메모리 해제가 되지 않도록 방지하는 역할도 할 수 있습니다.</p>

<p>나쁜 기능을 쓰라고 만들어 뒀을리는 없으니 코딩을 할 때 생각하면서 작성해야겠습니다.</p>

<h4 id="캡처리스트-바인딩">캡처리스트 바인딩</h4>

<pre><code class="language-Swift">var s = SomeClass()
let captureBinding = { [weak z = s] in
	// ...
}
</code></pre>

<h2 id="일반적인-클로저의-사용">일반적인 클로저의 사용</h2>

<h3 id="객체-내에서의-사용">객체 내에서의 사용</h3>

<pre><code class="language-Swift">class Dog {
	var name = "초코"

	func doSomething() {
		// 비동기 동작 클로저
		DispatchQueue.global().async {
			print("나의 이름은 \(self.name)입니다.")
		}
	}
}

var choco = Dog()
choco.doSomething()
</code></pre>

<p>실제로 앱을 만들 때는 객체 안에서 클로저를 사용하는 경우가 거의 대부분입니다. <code class="language-plaintext highlighter-rouge">UIView</code>, <code class="language-plaintext highlighter-rouge">UIViewController</code> 등의 컴포넌트들도 전부 객체이기 때문이죠.</p>

<p>그런데 클로저 안에서 객체의 속성이나 메서드에 접근하기 위해서는 반드시 <code class="language-plaintext highlighter-rouge">self</code> 키워드를 붙여줘야 합니다.</p>

<p>클로저의 scope 안에 있는 속성/메서드인지 외부인 객체에 있는 속성/메서드인지 알 수가 없겠죠.</p>

<p>이 <code class="language-plaintext highlighter-rouge">self</code>를 붙여주는 방법이 두가지 있습니다.</p>

<p>첫 번째 방법은 위 예시처럼 <code class="language-plaintext highlighter-rouge">self.name</code>과 같은 형태로 속성이나 메서드앞에 붙여주는 방법입니다.</p>

<p>두 번째 방법은 캡처 리스트에서 사용해주는 방법입니다.</p>

<pre><code class="language-Swift">func doSomething() {
	DispatchQueue.global().async { [self] in
		print("나의 이름은 \(name)입니다.")
	}
}
</code></pre>

<p>이 두 번째 방법은 약한 참조와 함께 사용하는 형태로 굉장히 많이 쓰이고 있습니다.</p>

<pre><code class="language-Swift">func doSomething() {
	DispatchQueue.global().async { [weak self] in
		print("나의 이름은 \(self?.name)입니다.")
	}
}

func doSomething() {
	DispatchQueue.global().async { [weak self] in
		guard let weakSelf = self else { return }
		print("나의 이름은 \(weakSelf.name)입니다.")
	}
}
</code></pre>

<h3 id="메모리-누수의-사례">메모리 누수의 사례</h3>

<p>아무래도 개념만 보면 어떤 때에 강한 참조 순환이 생기는건지 가늠이 안되죠.</p>

<pre><code class="language-Swift">class Dog {
	var name = "초코"
	var run: (() -&gt; Void)?

	func walk() {
		print("\(self.name)가 걷는다.")
	}

	func saveClosure() {
		run = {
			print("\(self.name)가 뛴다.")
		}
	}

	deinit {
		print("\(self.name) 메모리 해제")
	}
}

func doSomething() {
	let choco: Dog? = Dog()
	choco?.saveClosure() // 강한 참조 사이클
}

doSomething()
// doSomething()이 종료되어도 choco가 참조하는 run 클로저와 run 클로저가 self.name으로 참조하는 choco 사이에서 강한 참조 순환 발생
</code></pre>

<h4 id="view-controller에서의-예시">View Controller에서의 예시</h4>

<pre><code class="language-Swift">class ViewController: UIViewController {
	var name: String = "뷰 컨트롤러"

	func doSomething() {
		DispatchQueue.global().async {
			sleep(3)
			print("글로벌 큐에서 출력: \(self.name)")
		}
	}

	deinit {
		print("\(name) 메모리 해제")
	}
}

func localScopeFunction() {
	let vc = ViewController()
	vc.doSomething()
}

localScopeFunction()
</code></pre>

<blockquote>
  <p>(3초후)
글로벌 큐에서 출력: 뷰 컨트롤러
뷰 컨트롤러 메모리 해제</p>
</blockquote>

<pre><code class="language-Swift">class ViewController: UIViewController {
	var name: String = "뷰 컨트롤러"

	func doSomething() {
		DispatchQueue.global().async { [weak self] in
			sleep(3)
			print("글로벌 큐에서 출력: \(self.name)")
		}
	}

	deinit {
		print("\(name) 메모리 해제")
	}
}

func localScopeFunction() {
	let vc = ViewController()
	vc.doSomething()
}

localScopeFunction()
</code></pre>

<blockquote>
  <p>(3초후)
뷰 컨트롤러 메모리 해제
글로벌 큐에서 출력: nil</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">sleep(3)</code>이 실행되기 전에 약한 참조(<code class="language-plaintext highlighter-rouge">weak</code>)를 받은 <code class="language-plaintext highlighter-rouge">vc</code> 인스턴스가 메모리에서 해제되어 <code class="language-plaintext highlighter-rouge">nil</code>값이 출력된다.</p>
</body></html>
