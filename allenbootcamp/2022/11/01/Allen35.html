<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><a href="https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>

<h1 id="클로저-closure">클로저 (Closure)</h1>

<h2 id="클로저의-개념-및-1급-객체-취급">클로저의 개념 및 1급 객체 취급</h2>

<h5 id="클로저를-보기-전에">클로저를 보기 전에</h5>
<p>기존의 함수의 타입 표기와 사용법은 다음과 같습니다.</p>
<ol>
  <li>
<code class="language-plaintext highlighter-rouge">() -&gt; ()</code>, <code class="language-plaintext highlighter-rouge">() -&gt; Void</code>
</li>
  <li><code class="language-plaintext highlighter-rouge">(String) -&gt; String</code></li>
  <li>
<code class="language-plaintext highlighter-rouge">(Int, Int) -&gt; ()</code>, <code class="language-plaintext highlighter-rouge">(Int, Int) -&gt; Void</code>
</li>
</ol>

<h3 id="클로저">클로저</h3>
<ul>
  <li>이름이 없는 (익명의) 함수</li>
  <li>클로저와 함수는 기능은 완전히 동일하지만, 형태가 다르다.</li>
</ul>

<h3 id="함수와-클로저">함수와 클로저</h3>
<ul>
  <li>함수: 이름이 있는 코드의 묶음
    <ul>
      <li>다른 코드가 함수 이름으로 호출하기 위해</li>
    </ul>
  </li>
  <li>클로저: 이름이 없는 코드의 묶음
    <ul>
      <li>굳이 이름이 없어도 호출할 수 있는 형태로 사용 가능</li>
    </ul>
  </li>
</ul>

<h3 id="함수와-클로저의-형태">함수와 클로저의 형태</h3>
<ul>
  <li>함수</li>
</ul>

<pre><code class="language-Swift">func aFunction(str: String) -&gt; String {
	return "Hello, \(str)"
}
</code></pre>

<ul>
  <li>클로저</li>
</ul>

<pre><code class="language-Swift">let _ = { (str: String) -&gt; String in
	return "Hello, \(str)"
}
</code></pre>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">{}</code>(중괄호)를 함수라고 인식하면 좋다…!</p>
</blockquote>

<pre><code class="language-Swift">let aClosureType = { print("안녕!") } // () -&gt; ()
aClosureType() // 호출( 안녕! )
</code></pre>

<h3 id="일급객체">일급객체</h3>
<p>Swift는 <strong>함수</strong>를 <strong>일급객체</strong>로서 취급합니다. 따라서 함수는 <strong>타입</strong>으로서 취급됩니다. 함수를 타입으로서 취급하여 얻을 수 있는 이점들을 다음과 같습니다.</p>
<ol>
  <li>함수를 <strong>변수</strong>에 할당할 수 있다.</li>
  <li>함수를 호출할 때, 함수를 <strong>파라미터로 전달</strong>할 수 있다.</li>
  <li>함수에서 함수를 <strong>반환</strong>할 수 있다.</li>
</ol>

<h2 id="클로저는-왜-필요할까">클로저는 왜 필요할까?</h2>

<h3 id="콜백함수-callback-function">콜백함수 (Callback Function)</h3>
<ul>
  <li>
<strong>콜백함수</strong>: 함수를 실행할 때 파라미터로 전달하는 함수</li>
</ul>

<ol>
  <li>클로저를 파라미터로 받는 함수 정의</li>
</ol>

<pre><code class="language-Swift">func closureParamFunction(closure: () -&gt; Void) {
	print("안녕하세요!")
	closure()
}
</code></pre>

<ol>
  <li>함수를 실행할 때 파라미터를 클로저 형태로 전달</li>
</ol>

<pre><code class="language-Swift">closureParamFunction(closure: {
	print("안녕히계세요!")
})
// 안녕하세요!
// 안녕히계세요!
</code></pre>

<blockquote>
  <p>함수 실행할 때 클로저를 정의하면서 실행하는게 왜 좋은거에요?</p>
</blockquote>

<p>콜백함수인데 따로 다른 곳에서는 쓰이지 않는 함수가 있다면 그 함수는 굳이 이름이 필요가 없겠죠.. 클로저는 그럴 때 유용합니다.</p>

<h3 id="파라미터를-처리한-결과를-함수에-바로-넣고-싶을-때-사후처리">파라미터를 처리한 결과를 함수에 바로 넣고 싶을 때 (사후처리)</h3>

<ol>
  <li>클로저를 파라미터로 받는 함수 정의</li>
</ol>

<pre><code class="language-Swift">func closureCaseFunction(a: Int, b: Int, closure: (Int) -&gt; Void) {
	let c = a + b
	closure(c)
}
</code></pre>

<ol>
  <li>함수를 실행할 때 클로저 형태로 전달</li>
</ol>

<pre><code class="language-Swift">closureCaseFunction(a: 5, b: 2, closure: { (number) in 
	print("클로저의 결과: \(number)")
})
// 클로저의 결과: 7
</code></pre>

<blockquote>
  <p>이게 왜 좋은건지 도저히 느낌이 안와요!</p>
</blockquote>

<p>예시는 단순 출력문만 있기 때문에 느낌이 안올 수 있어요. 하지만 후처리로 개발자가 원하는대로 클로저를 줄 수 있다는 것은 개발 과정에서의 엄청난 자율성과 활용성을 제공해줍니다.</p>

<p>실제로 Swift 언어를 사용하는 개발자들은 이러한 형태의 코드를 굉장히 많이 사용하고 있어요. 오픈소스 라이브러리를 살펴보면, 이러한 클로저의 사후처리 개념을 알지 못하면 기능을 전혀 이해를 할 수 없을 정도에요!</p>

<p>보통 애플이나 오픈소스 라이브러리 작성자들이 번거롭고 어려운 내용의 코드들을 작성해두고, 해당 코드의 결과를 다른 개발자들이 쉽게 이용할 수 있도록 클로저를 파라미터로 받는 형태로 함수를 제공합니다.</p>

<h2 id="클로저의-간소화-문법">클로저의 간소화 문법</h2>
<p>클로저는 실사용시의 가독성과 편의성을 위해 매우 다양한 축약 형태를 제공합니다. 크게 네 가지 형태로 나눌 수 있고, 다음과 같습니다.</p>
<ol>
  <li>문맥 상 파라미터와 리턴 밸류 타입 추론 (Type Inference)</li>
  <li>싱글 익스프레션일 경우 (한 줄), 리턴 생략 (Implicit Return)</li>
  <li>아규먼트 이름을 축약 (Shorthand Arguments)</li>
  <li>트레일링(후행) 클로저 (Trailing Closure)</li>
</ol>

<p>하나씩 한 번 살펴보겠습니다.</p>

<h3 id="트레일링-trailing-클로저">트레일링 (Trailing) 클로저</h3>

<ol>
  <li>원문</li>
</ol>

<pre><code class="language-Swift">closureParamFunction(closure: {
	print("안녕히계세요.")
})
</code></pre>

<ol>
  <li>소괄호 앞으로 이동</li>
</ol>

<pre><code class="language-Swift">closureParamFunction(closure: ) {
	print("안녕히계세요.")
}
</code></pre>

<ol>
  <li>인자(Argument) 레이블 생략</li>
</ol>

<pre><code class="language-Swift">closureParamFunction() {
	print("안녕히계세요.")
}
</code></pre>

<ol>
  <li>마지막 인자로 클로저가 전달되는 경우 소괄호 생략 가능</li>
</ol>

<pre><code class="language-Swift">closureParamFunction {
	print("안녕히계세요.")
}
</code></pre>

<h4 id="현실적인-사용-예시">현실적인 사용 예시</h4>

<pre><code class="language-Swift">func closureCaseFunction(a: Int, b: Int, closure: (Int) -&gt; Void) {
	let c = a + b
	closure(c)
}

closureCaseFunction(a: 3, b: 4) { res in // 함수 인자 앞까지 소괄호 이동
	print("Update Complete: \(res) obtained.")
}
</code></pre>

<h4 id="멀티플-트레일링-클로저">멀티플 트레일링 클로저</h4>
<p>Swift 5.3에서 추가된 클로저 편의성 추가 기능입니다.</p>

<p>원래는 마지막 클로저만 트레일링 클로저를 적용할 수 있었습니다. 하지만 5.3 버전부터는 여러 개의 클로저에 모두 적용할 수 있게 되었습니다.</p>

<pre><code class="language-Swift">func multipleClosure(first: () -&gt; (), _ second: () -&gt; (), third: () -&gt; ()) {
	first()
	second()
	third()
}

// 5.3 이전
multipleClosure(first: {
	print("1")
}, _: {
	print("2")
}) {
	print("3")
}

// 5.3 이후
multipleClosure {
	print("1")
} _: {
	print("2")
} third: {
	print("3")
}
</code></pre>

<h3 id="파라미터-및-생략-등의-간소화">파라미터 및 생략 등의 간소화</h3>

<pre><code class="language-Swift">func performClosure(param: (String) -&gt; (Int) {
	param("Swift")
}

performClosure(param: { (str: String) -&gt; Int in 
	return str.count
})
</code></pre>

<ol>
  <li>타입 추론</li>
</ol>

<pre><code class="language-Swift">performClosure(param: { str in
	return str.count
})
</code></pre>

<ol>
  <li>한 줄일 경우 <code class="language-plaintext highlighter-rouge">return</code> 생략 가능</li>
</ol>

<pre><code class="language-Swift">performClosure(param: { str in
	str.count
})
</code></pre>

<ol>
  <li>인자(argument) 이름을 축약</li>
</ol>

<pre><code class="language-Swift">performClosure(param: {
	$0.count
})
</code></pre>

<blockquote>
  <p>엥.. $가 뭐에요…</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">$0</code>은 순서 상 첫 번째 파라미터입니다. 마찬가지로  <code class="language-plaintext highlighter-rouge">$1</code>, <code class="language-plaintext highlighter-rouge">$2</code>, <code class="language-plaintext highlighter-rouge">$3</code> 은 각각 두 번째, 세 번째, 네 번째 파라미터입니다.</p>

<ol>
  <li>트레일링 클로저</li>
</ol>

<pre><code class="language-Swift">performClosure {
	$0.count
}

performClosure { $0.count }
</code></pre>

<h2 id="실제-사용-예시">실제 사용 예시</h2>
<p>단순해지고 편해지는건 알겠는데, 실제로 써먹을 때의 모습을 봐야 이해가 딱 될 것 같아요.</p>

<h3 id="urlsession">URLSession</h3>

<pre><code class="language-Swift">URLSession(configuration: .default).dataTask(with: URL(string: "https://address")!) { data, response, error in
	switch response {
	case .success:
		return data
	case .failure:
		print(error)
	}
}
</code></pre>

<p>물론 위처럼 간단하게는 못 써요..! 중요한 건 클로저니까 형태 정도만 보면 됩니다.</p>

<h3 id="timer">Timer</h3>

<pre><code class="language-Swift">Timer.scheduledTimer(withTimeInterval: 0.5, repeats: false) { _ in
	print("0.5초 뒤에 출력")
}
</code></pre>

<h3 id="dismiss">dismiss</h3>

<pre><code class="language-Swift">vc.dismiss(animated: true) {
	print("화면 종료")
}
</code></pre>

<h2 id="클로저의-메모리">클로저의 메모리</h2>

<h3 id="클로저는-참조타입">클로저는 참조타입!</h3>
<p>클로저는 클래스와 마찬가지로 참조 타입입니다.</p>

<p>시작은 다른 모든 함수들과 동일하게 스택 영역에서 실행됩니다.</p>

<p>클로저가 일반적인 함수와 다른 점은 함수를 호출할 때 일어납니다.</p>

<p>일반적인 함수는 호출되면 코드 영역의 코드 블럭 시작점을 찾아가 한 줄씩 코드를 실행합니다.</p>

<p>하지만 클로저는 참조 타입이기 때문에 <strong>힙 영역</strong>에 있는 클로저 주소에 찾아간 후에, 힙 영역에 저장된 코드 블럭 주소를 받아 코드 영역의 코드를 실행합니다.</p>

<p>그렇다면 클로저는 왜 참조 타입으로 저장될까요?</p>

<h3 id="클로저의-캡처-현상">클로저의 캡처 현상</h3>

<pre><code class="language-Swift">var stored = 0
let closure = { (number: Int) -&gt; Int in
	stored += number
	return stored
}

closure(3) // 3
closure(4) // 7
closure(5) // 12
stored = 0
closure(5) // 5
</code></pre>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">stored</code>이라는 변수는 클로저 내부에 정의된 변수가 아니라 외부에 있는 변수입니다. 따라서 클로저는 <strong>변수에 할당되거나 호출되는 순간</strong>, 자신이 참조하는 외부의 변수를 <strong>캡처</strong>합니다.</p>

<blockquote>
  <p>클로저 내부에서 사용할 외부의 값을 필요할 경우 <strong>힙 영역</strong>에 <strong>저장</strong>해둔다는 의미입니다. 이 때 저장되는 값은 값 자체보다는 스택 영역에 저장된 변수의 주소가 참조 타입으로 저장됩니다.</p>
</blockquote>

<p>자 그러면 동일한 기능을 가지는 함수를 각각 일반적인 함수와 클로저를 사용하여 어떻게 과정과 결과가 달라지는지 확인해보겠습니다.</p>

<h4 id="일반적인-함수-nested-function">일반적인 함수 (Nested Function)</h4>

<pre><code class="language-Swift">func calculate(number: Int) -&gt; Int {
	var sum = 0

	func square(num: Int) -&gt; Int {
		sum += (num * num)
		return sum
	}

	let result = square(num: number)

	return result
}

calculate(number: 10) // 100
calculate(number: 20) // 400
calculate(number: 30) // 900
</code></pre>

<p>위 예시의 경우에는 일반적인 함수를 사용하는 방법입니다.</p>

<p>이 경우에는, 모든 연산은 오직 <strong>스택 영역</strong>에서만 이루어집니다. Nested Function이라 할지라도 새로운 스택을 쌓아가며, 스택 안에서만 모든 연산들이 이루어지죠.</p>

<h4 id="변수를-캡처하는-함수">변수를 캡처하는 함수</h4>

<pre><code class="language-Swift">func calculateFunc() -&gt; ((Int) -&gt; Int) {
	var sum = 0

	func square(num: Int) -&gt; Int {
		sum += (num * num)
		return sum
	}

	return square
}

var squareFunc = calculateFunc() // square((Int) -&gt; Int)
squareFunc(10) // 100
squareFunc(20) // 500
squareFunc(30) // 1400
var dodoFunc = squareFunc
dodoFunc(20) // 1800
</code></pre>

<p>위 예시의 경우에는 캡처 현상이 발생하는 함수입니다.</p>

<p><code class="language-plaintext highlighter-rouge">squareFunc</code> 변수에는 <code class="language-plaintext highlighter-rouge">calculateFunc</code> 함수 내부에 있는 <code class="language-plaintext highlighter-rouge">square</code> 함수가 담겼습니다. 어떤 함수의 내부에 있는 함수가 리턴되는 경우, 클로저와 동일하게 <strong>힙 영역에 내부 함수를 저장</strong>하고 그 주소를 리턴하게 됩니다.</p>

<p>따라서 <code class="language-plaintext highlighter-rouge">squareFunc</code> 변수에는 내부 함수 <code class="language-plaintext highlighter-rouge">square</code>가 <strong>힙 영역</strong>에 저장된 주소가 저장되게 됩니다.</p>

<p>그런데 내부 함수 <code class="language-plaintext highlighter-rouge">square</code>는 외부의 변수 <code class="language-plaintext highlighter-rouge">sum</code>을 사용하고 있습니다. 문제는 여기서 발생합니다.</p>

<p><code class="language-plaintext highlighter-rouge">calculateFunc</code> 함수의 실행이 끝나면 해당 함수는 스택 영역에서 해제됩니다. 그런데 그 내부에 있는 <code class="language-plaintext highlighter-rouge">square</code> 함수는 새로운 변수 <code class="language-plaintext highlighter-rouge">squareFunc</code>에 저장되어 보존되었고, <code class="language-plaintext highlighter-rouge">calculateFunc</code> 함수에 저장되었던 <code class="language-plaintext highlighter-rouge">sum</code>이라는 변수를 필요로 합니다.</p>

<p>스택 영역에서 해제되버리면 <code class="language-plaintext highlighter-rouge">sum</code> 변수또한 해제되어 버리기 때문에, <code class="language-plaintext highlighter-rouge">squareFunc</code> 변수에 저장된 함수를 실행하면 무조건 에러가 나게 되었습니다. 이런 현상을 방지하기 위해 <strong>캡처 현상</strong>이 발생합니다.</p>

<p>내부의 <code class="language-plaintext highlighter-rouge">square</code> 함수는 외부에 있지만 필요한 <code class="language-plaintext highlighter-rouge">sum</code>이라는 변수를 <strong>본인의 저장 공간(힙 영역)에 함께 저장</strong>합니다.</p>

<p>이런 <strong>캡처 현상</strong> 때문에 일반적인 함수를 사용할 때처럼 매번 변수를 초기화하지 못하고 저장된 변수를 계속해서 사용하기 때문에 이전에 넣어주었던 값이 계속해서 보존되게 되는 것입니다.</p>

<blockquote>
  <p>캡처 현상은 이렇게 힙 영역에 함수를 저장하는 현상이 발생하는 <strong>(1) 함수를 변수에 할당</strong>하거나 <strong>(2) 클로저</strong>를 사용하는 경우 발생합니다.</p>
</blockquote>

<h2 id="escaping--autoclosure-클로저">@escaping / @autoclosure 클로저</h2>

<h3 id="escaping-클로저">@escaping 클로저</h3>
<p>원칙적으로 지금까지 배운 클로저들은 함수의 실행이 종료되면 파라미터로 쓰였던 클로저까지 함께 메모리에서 해제됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">@escaping</code> 클로저는 클로저를 제거하지 않고 함수에서 탈출시킵니다. 다른 말로, 함수가 종료되어도 클로저가 해제되지 않습니다.</p>

<p>이런 기능이 필요한 경우는 크게 두 가지입니다.</p>

<ol>
  <li>내부에서 사용한 클로저를 외부 변수에 저장</li>
  <li>GCD (비동기 코드의 사용)</li>
</ol>

<pre><code class="language-Swift">var aSavedFunction: () -&gt; () = { print("출력") }

func performEscaping2(closure: @escaping () -&gt; ()) {
	aSavedFunction = closure // 클로저를 외부 aSavedFunction에 할당
}

performEscaping2(closure: { print("다르게 출력") })
aSavedFunction() // 다르게 출력
</code></pre>

<pre><code class="language-Swift">func performEscaping1(closure: @escaping (String) -&gt; ()) {
	var name = "홍길동"

	DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
		closure(name)
	}
}

performEscaping1 { name in
	print("이름 출력하기: \(name)")
}
</code></pre>

<blockquote>
  <p>정리</p>
</blockquote>

<ul>
  <li>함수 주소가 힙 영역에 저장되는 경우 ( = 함수가 비교적 긴 시간 저장되어야 하는 경우)
    <ol>
      <li>함수를 변수에 담는 경우</li>
      <li>중첩함수(Nested Function)에서 내부 함수를 반환하고, 그것을 외부 변수에 담는 경우</li>
      <li>비동기적인 클로저의 실행의 경우</li>
    </ol>
  </li>
</ul>

<h3 id="autoclosure">@autoclosure</h3>
<p><code class="language-plaintext highlighter-rouge">@autoclosure</code>는 자동으로 클로저 처리를 해주는 키워드입니다. 번거로움을 조금이라도 줄이기 위해 자동으로 중괄호를 씌워줍니다.</p>

<p><code class="language-plaintext highlighter-rouge">@autoclosure</code>는 파라미터가 없는 경우에만 사용할 수 있습니다.</p>

<p>하지만 사실 잘 사용되지 않는 문법입니다. 코드가 명확하지 않게 작성되기 때문에 애플에서도 추천하지 않고 있습니다.</p>

<pre><code class="language-Swift">func someFunction(closure: @autoclosure () -&gt; Bool) {
	if closure() {
		print("참입니다.")
	} else {
		print("거짓입니다.")
	}
}

var num = 1
someFunction(closure: true)
// someFunction(closure: { true })
</code></pre>

<h2 id="클로저-사용-예시-코드로-ui-작성">클로저 사용 예시 (코드로 UI 작성)</h2>

<ul>
  <li>설정까지 완료된 UI 컴포넌트의 반환</li>
</ul>

<pre><code class="language-Swift">let emailTextField: UITextField = {
	let tf = UITextField()
	tf.placeholder = "Email"
	tf.backgroundColor = .systemRed
	tf.borderStyle = .roundedRect
	tf.font = UIFont.systemFont(ofSize: 14)
	tf.addTarget(self, action: ..., for: ...)
	return tf
}() // 해당 클로저를 바로 실행하여 반환값을 할당
</code></pre>

</body></html>
