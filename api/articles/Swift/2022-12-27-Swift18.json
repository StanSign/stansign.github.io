{"title":"18)🍎 Swift - 다운샘플링","uid":"dd29b53b3fa8ec1be54827ce6b92cee8","slug":"Swift/2022-12-27-Swift18","date":"2022-12-26T15:00:00.000Z","updated":"2023-03-31T10:46:00.205Z","comments":true,"path":"api/articles/Swift/2022-12-27-Swift18.json","keywords":null,"cover":[],"content":"<h1 id=\"다운샘플링으로-메모리-효율적인-이미지-처리하기\"><a href=\"#다운샘플링으로-메모리-효율적인-이미지-처리하기\" class=\"headerlink\" title=\"다운샘플링으로 메모리 효율적인 이미지 처리하기\"></a>다운샘플링으로 메모리 효율적인 이미지 처리하기</h1><p>이전 게시물에서 알아보았던 <code>PHPicker</code>를 사용해서 이미지를 처리하던 중 아래와 같은 에러를 마주쳤습니다.</p>\n<p><img src=\"https://i.imgur.com/PIZF0mw.png\"></p>\n<p>Swift가 허용한 4,194,304 바이트보다 큰 데이터를 UserDefaults에 저장할 수 없다는 에러입니다.</p>\n<p>UserDefaults는 작은 데이터들을 저장할 목적으로 만들어진 것이기 때문에 위와 같은 에러는 자연스러운 현상인 듯 합니다.</p>\n<p>지금 저장하려는 이미지는 원본 이미지 그 자체였으니 당연히 용량이 컸을 것이고, 이미지의 용량을 줄이려면 보통 이미지 크기를 줄이겠다는 생각부터 하겠죠?</p>\n<p><strong>이미지 크기의 축소</strong>는 가장 직관적으로 이미지 용량을 줄이고 메모리 가용률도 높이는 좋은 방법 중 하나입니다.</p>\n<p>그래서 저도 이미지를 줄일 수 있는 방법부터 찾아보게 되었죠.</p>\n<h2 id=\"이미지-리사이즈시의-CPU와-메모리-동작\"><a href=\"#이미지-리사이즈시의-CPU와-메모리-동작\" class=\"headerlink\" title=\"이미지 리사이즈시의 CPU와 메모리 동작\"></a>이미지 리사이즈시의 CPU와 메모리 동작</h2><p>하지만 공부를 한 지 얼마 지나지 않아 단순히 이미지를 줄이는 방법은 좋은 방법이 아니고, 오히려 앱이 기기에 과부하를 더 줄 수 있다는 사실을 깨달았습니다.</p>\n<p>그 까닭은 2018년에 진행된 WWDC2018에서 찾아볼 수 있었습니다.</p>\n<p><a href=\"https://developer.apple.com/wwdc18/219\">Image and Graphics Best Practices - WWDC18 - Videos - Apple Developer</a></p>\n<p>이미 이미지 처리 게시물들에서 많이 다루고 있고 iOS의 화면 표현 방법을 학습해볼 수 있는 세션입니다.</p>\n<p>아래는 <code>UIGraphicsImageRenderer</code>를 사용하여 <code>PHPicker</code>를 통해 받은 이미지 여러개의 크기를 줄이는 코드입니다.</p>\n<p><img src=\"https://i.imgur.com/qZZB9BM.png\"></p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var images: [UIImage] &#x3D; []\n\nvar result in results &#123;\n\tresult.itemProvider.loadObject(ofClass: UIImage.self) &#123; object, error in\n\t\tguard let image &#x3D; object as? UIImage else &#123; return &#125;\n\t\tguard let resizedImage: UIImage &#x3D; UIGraphicsImageRenderer(size: CGSize(width: 2_000, height: 2_000)).image &#123; context in\n\t\t\timage.draw(in: CGRect(origin: CGPoint.zero, size: newSize))\n\t\t&#125; else &#123; return &#125;\n\t\timages.append(resizedImage)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>단순히 보기에는 아무런 문제가 없어보이죠.</p>\n<p>문제는 두 번에 걸쳐서 발생합니다.</p>\n<h3 id=\"1-원본을-로드한다\"><a href=\"#1-원본을-로드한다\" class=\"headerlink\" title=\"1. 원본을 로드한다.\"></a>1. 원본을 로드한다.</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">guard let image &#x3D; object as? UIImage else &#123; return &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>첫 번째 문제입니다.</p>\n<p>이미지 사이즈를 줄이는 목적이 무엇이였나요?</p>\n<p>메모리에 부하를 덜 주기 위해서였죠.</p>\n<p>위 방법은 성공적으로 수행만 된다면 그 이후에는 메모리 사용률을 낮춰줄겁니다.</p>\n<p>그런데 이미지 크기를 줄이기 위해서 우선 원본 이미지를 한 번 로드해주어야 합니다.</p>\n<p>그 한 번 로드하는 과정에서 백그라운드 작업들을 종료시키거나 심하면 앱 자체를 종료시키는 현상이 발생할 수 있습니다.</p>\n<p>실제로 위 코드만 봐도 <code>PHPicker</code>는 선택한 데이터를 <code>UIImage</code> 타입으로서 제공하지 않습니다.</p>\n<p>굳이 크기가 큰 그 데이터를 아무런 처리 없이 <code>UIImage</code>로 바로 변환하여 사용하고 있었던 것이죠!</p>\n<h3 id=\"2-작은-이미지를-직접-그린다\"><a href=\"#2-작은-이미지를-직접-그린다\" class=\"headerlink\" title=\"2. 작은 이미지를 직접 그린다.\"></a>2. 작은 이미지를 <strong>직접 그린다</strong>.</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">image.draw(in: CGRect(origin: .zero, size: newSize))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>두 번째 문제입니다.</p>\n<p>위 방법은 이미지를 불러와 그 이미지의 작은 버전을 <code>draw</code> 메서드를 사용하여 직접 그려줘야 하는 방법입니다.</p>\n<p>그래픽 작업을 하는 것이기 때문에 CPU와 메모리 두 하드웨어 모두에게 작업을 부여하는 것이고, 이 또한 메모리 부하를 줄이는 것과는 거리가 먼 것을 알 수 있습니다.</p>\n<h2 id=\"다운-샘플링\"><a href=\"#다운-샘플링\" class=\"headerlink\" title=\"다운 샘플링\"></a>다운 샘플링</h2><p>그러면 단순히 이미지를 리사이징 하는 방법 외에 어떤 방법이 있을까요?</p>\n<p><img src=\"https://i.imgur.com/QEsP6KF.png\"></p>\n<p>바로 데이터를 <code>UIImage</code>로 바로 변환하여 사용하는 것이 아니라 <code>CGImage</code> 타입의 데이터를 사용하여 디코딩할 파일(data buffer) 자체의 사이즈를 줄이는 다운샘플링 방법이 있습니다.</p>\n<p>다만 이 방법은 <code>Core Graphics</code>이라는 한 층 더 low-level한 내용을 사용하기 때문에 코드가 좀 더 길고 복잡합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func downsample(at url: URL, to pointSize: CGSize, scale: CGFloat) -&gt; Data? &#123;\n\n\tlet sourceOptions &#x3D; [kCGImageSourceShouldCache: false] as CFDictionary\n\n\tguard let source &#x3D; CGImageSourceCreateWithURL(url as CFURL, sourceOptions) else &#123; return nil &#125;\n\n\tlet maxDimensionInPixels &#x3D; max(pointSize.width, pointSize.height) * scale\n\n\tlet downsampleOptions &#x3D; [\n\t\tkCGImageSourceCreateThumbnailFromImageAlways: true,\n\t\tkCGImageSourceCreateThumbnailWithTransform: true,\n\t\tkCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels\n\t] as CFDictionary\n\n\tguard let cgImage &#x3D; CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOptions) else &#123; return nil &#125;\n\n\tlet data &#x3D; NSMutableData()\n\n\tguard let imageDestination &#x3D; CGImageDestinationCreateWithData(data, UTType.jpeg.identifier as CFString, 1, nil) else &#123; return nil &#125;\n\n\tlet isPNG: Bool &#x3D; &#123;\n\t\tguard let utType &#x3D; cgImage.utType else &#123; return false &#125;\n\t\treturn (utType as String) &#x3D;&#x3D; UTType.png.identifier\n\t&#125;()\n\n\tlet destinationProperties &#x3D; [\n\t\tkCGImageDestinationLossyCompressionQuality: isPNG ? 1.0 : 0.75\n\t] as CFDictionary\n\n\tCGImageDestinationAddImage(imageDestination, cgImage, destinationProperties)\n\tCGImageDestinationFinalize(imageDestination)\n\n\treturn data as Data\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>어질어질하쥬..? 😵</p></blockquote>\n<p>복잡해 보이지만 두 파트로 나눌 수 있습니다. 한 번 살펴봅시다.</p>\n<h3 id=\"1-CGImage-생성\"><a href=\"#1-CGImage-생성\" class=\"headerlink\" title=\"1. CGImage 생성\"></a>1. <strong>CGImage</strong> 생성</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let sourceOptions &#x3D; [kCGImageSourceShouldCache: false] as CFDictionary\nguard let source &#x3D; CGImageSourceCreateWithURL(url as CFURL, sourceOptions) else &#123; return nil &#125;\n\nlet maxDimensionInPixels &#x3D; max(pointSize.width, pointSize.height) * scale\nlet downsampleOptions &#x3D; [\n\tkCGImageSourceCreateThumbnailFromImageAlways: true,  \n\tkCGImageSourceShouldCacheImmediately: true,\n\tkCGImageSourceCreateThumbnailWithTransform: true,\n\tkCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels\n] as CFDictionary\n\nguard let cgImage &#x3D; CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOptions) else &#123; return nil &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>downsampling의 핵심이 되는 부분입니다.</p>\n<p>사실상 필수적인 로직들은 이 안에 다 있습니다.</p>\n<p>Option flag를 정의해주고 해당 옵션을 통해 <code>CGImage</code>를 생성해주는 방식입니다.</p>\n<ul>\n<li><code>kCGImageSourceShouldCache: false</code><ul>\n<li>이미지 소스에  대한 참조값만을 생성하고 <code>CGImageSource</code>가 생성되는 즉시 디코딩을 진행하지 않습니다.</li>\n</ul>\n</li>\n<li><code>kCGImageSourceShouldCacheImmediately: true</code><ul>\n<li>앞선 옵션과는 반대로 다운샘플링 로직이 시작됨과 동시에 디코딩 작업을 수행합니다.</li>\n</ul>\n</li>\n<li><code>kCGImageSourceCreateThumbnailWithTransform: true</code><ul>\n<li>다운샘플링된 이미지를 원본 이미지와 같은 형태를 갖도록 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-PNG-퀄리티-보존\"><a href=\"#2-PNG-퀄리티-보존\" class=\"headerlink\" title=\"2. PNG 퀄리티 보존\"></a>2. PNG 퀄리티 보존</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let data &#x3D; NSMutableData()\n\nguard let imageDestination &#x3D; CGImageDestinationCreateWithData(data, UTType.jpeg.identifier as CFString, 1, nil) else &#123; return nil &#125;\n\nlet isPNG: Bool &#x3D; &#123;\n\tguard let utType &#x3D; cgImage.utType else &#123; return false &#125;\n\treturn (utType as String) &#x3D;&#x3D; UTType.png.identifier\n&#125;()\n\nlet destinationProperties &#x3D; [\n\tkCGImageDestinationLossyCompressionQuality: isPNG ? 1.0 : 0.75\n] as CFDictionary\n\nCGImageDestinationAddImage(imageDestination, cgImage, destinationProperties)\nCGImageDestinationFinalize(imageDestination)\n\nreturn data as Data<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>이 부분은 사실 선택적으로 구현하면 되는 부분입니다.</p>\n<p><code>PNG</code> 확장자는 보통 스크린샷과 같이 이미지의 품질이 중요한 이미지들에 사용됩니다.</p>\n<p>이러한 이미지의 품질이 손상된다면 이미지에 포함된 텍스트 등의 시인성, 가독성이 중요한 요소들에 영향이 갈 수 있습니다.</p>\n<p><code>PNG</code> 확장자라면 1.0의 손상 없는 압축을, 그 외의 확장자라면 0.75의 압축률로 데이터를 디코딩하였습니다.</p>\n<h4 id=\"PHPicker와의-사용\"><a href=\"#PHPicker와의-사용\" class=\"headerlink\" title=\"PHPicker와의 사용\"></a><code>PHPicker</code>와의 사용</h4><p>이전 <code>PHPicker</code>를 사용할 때는 아래와 같은 코드를 사용하였습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">itemProvider.loadObject(ofClass: UIImage.self) &#123; image, error in\n\t&#x2F;&#x2F; do something\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>이번 게시물에서 사용한 방법은 <code>URL</code> 타입으로 이미지를 받기 때문에 아래와 같이 사용해야 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">itemProvider.loadFileRepresentation(forTypeIdentifier: UTType.image.identifier) &#123; url, error in\n\t&#x2F;&#x2F; do something\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","text":"다운샘플링으로 메모리 효율적인 이미지 처리하기이전 게시물에서 알아보았던 PHPicker를 사용해서 이미지를 처리하던 중 아래와 같은 에러를 마주쳤습니다. Swift가 허용한 4,194,304 바이트보다 큰 데이터를 UserDefaults에 저장할 수 ...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EB%8B%A4%EC%9A%B4%EC%83%98%ED%94%8C%EB%A7%81%EC%9C%BC%EB%A1%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0\"><span class=\"toc-text\">다운샘플링으로 메모리 효율적인 이미지 처리하기</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A6%88%EC%8B%9C%EC%9D%98-CPU%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8F%99%EC%9E%91\"><span class=\"toc-text\">이미지 리사이즈시의 CPU와 메모리 동작</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%EC%9B%90%EB%B3%B8%EC%9D%84-%EB%A1%9C%EB%93%9C%ED%95%9C%EB%8B%A4\"><span class=\"toc-text\">1. 원본을 로드한다.</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%EC%9E%91%EC%9D%80-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A5%BC-%EC%A7%81%EC%A0%91-%EA%B7%B8%EB%A6%B0%EB%8B%A4\"><span class=\"toc-text\">2. 작은 이미지를 직접 그린다.</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%8B%A4%EC%9A%B4-%EC%83%98%ED%94%8C%EB%A7%81\"><span class=\"toc-text\">다운 샘플링</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-CGImage-%EC%83%9D%EC%84%B1\"><span class=\"toc-text\">1. CGImage 생성</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-PNG-%ED%80%84%EB%A6%AC%ED%8B%B0-%EB%B3%B4%EC%A1%B4\"><span class=\"toc-text\">2. PNG 퀄리티 보존</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#PHPicker%EC%99%80%EC%9D%98-%EC%82%AC%EC%9A%A9\"><span class=\"toc-text\">PHPicker와의 사용</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"19)🍎 Swift - RxFlow.01","uid":"908b0e0d798be07b2105b3cfcc4b1431","slug":"Swift/2023-01-27-Swift19","date":"2023-01-26T15:00:00.000Z","updated":"2023-03-31T10:45:56.443Z","comments":true,"path":"api/articles/Swift/2023-01-27-Swift19.json","keywords":null,"cover":[],"text":"RxFlowFavor 프로젝트는 ReactorKit을 사용하여 MVVM-C패턴에 RxSwift를 적극적으로 활용하고 있습니다. 하지만 저희 프로젝트에서 Reactive하지 못한 부분이 하나 있었습니다. 바로 Coordinator 부분인데요.. 하위 C...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Favor","slug":"Favor","count":6,"path":"api/tags/Favor.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"17)🍎 Swift - Property Wrapper","uid":"d307c77550c3e506aba3109e585568f0","slug":"Swift/2022-12-26-Swift17","date":"2022-12-25T15:00:00.000Z","updated":"2023-03-31T10:43:12.067Z","comments":true,"path":"api/articles/Swift/2022-12-26-Swift17.json","keywords":null,"cover":null,"text":"Property Wrapper오늘은 UserDefaults를 어떻게 하면 조금이라도 더 편하게 사용할 수 있을까 고민하다가 아주 좋은 친구를 발견했습니다. 바로 Property Wrapper라는 친구인데요. 이 친구는 SwiftUI와 Combine의 ...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}