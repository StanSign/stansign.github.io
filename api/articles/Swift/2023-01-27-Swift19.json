{"title":"19)🍎 Swift - RxFlow.01","uid":"908b0e0d798be07b2105b3cfcc4b1431","slug":"Swift/2023-01-27-Swift19","date":"2023-01-26T15:00:00.000Z","updated":"2023-03-31T10:45:56.443Z","comments":true,"path":"api/articles/Swift/2023-01-27-Swift19.json","keywords":null,"cover":[],"content":"<h1 id=\"RxFlow\"><a href=\"#RxFlow\" class=\"headerlink\" title=\"RxFlow\"></a>RxFlow</h1><p>Favor 프로젝트는 ReactorKit을 사용하여 MVVM-C패턴에 RxSwift를 적극적으로 활용하고 있습니다.</p>\n<p>하지만 저희 프로젝트에서 Reactive하지 못한 부분이 하나 있었습니다.</p>\n<p>바로 Coordinator 부분인데요..</p>\n<p>하위 Coordinator를 종료하기 위해서는 상위 Coordinator에 접근해야만 하는 현상을 발견헀습니다.</p>\n<p>바로 아래 코드처럼요..</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">self.coordinator.parentCoordinator?.finish(childCoordinator: self.coordinator)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>한눈에 봐도 굉장히 깔끔해보이지 않습니다. 😵</p>\n<p><code>현재 코디네이터 ➡️ 상위 코디네이터</code>에 접근을 한 뒤 다시 <code>현재 코디네이터를 종료하는 메서드를 실행</code>하는 것은 굉장히 좋지 않은 접근이라고 생각했습니다.</p>\n<p>때문에 두 가지 방법을 고안해보았는데요.</p>\n<ul>\n<li><code>delegate</code> 패턴을 사용하여 하위 코디네이터에서 직접적으로 상위 코디네이터에 접근하는 것을 방지</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">extension AppCoordinator: CoordinatorFinishDelegate &#123;\n  func coordinatorDidFinish(childCoordinator: some Coordinator) &#123;\n    self.finish(childCoordinator: childCoordinator)\n    \n    self.navigationController.viewControllers.removeAll()\n    \n    switch childCoordinator.self &#123;\n    case is AuthCoordinator:\n      self.showTabBarFlow()\n    case is TabBarCoordinator:\n      self.showAuthFlow()\n    default:\n      break\n    &#125;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><code>override</code>를 활용하여 추가 로직 구현 방식으로 접근</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">override func finish(childCoordinator: some Coordinator) &#123;\n  super.finish(childCoordinator: childCoordinator)\n  \n  self.navigationController.viewControllers.removeAll()\n  \n  switch childCoordinator.self &#123;\n  case is AuthCoordinator:\n    self.showTabBarFlow()\n  case is TabBarCoordinator:\n    self.showAuthFlow()\n  default:\n    break\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>사실 완벽하게 동일한 로직이지만 접근 방법의 차이를 갖고 있고, 어떤 방식이 더 나을까를 고민하던 중에</p>\n<p><code>delegate</code> 패턴을 사용하는 방식이 “위임”한다는 로직 측면에서는 직관적이지만 코드 가시성 측면에서는 복잡하다는 의견으로 귀결되었습니다.</p>\n<p><code>delegate</code> 패턴을 어떻게 하면 더 쉽게 사용할 수 있을까를 고민하던 중에 <code>rx</code>를 활용하면 되지 않을까라는 생각에 라이브러리를 찾아보게 되었고, <code>RxFlow</code>를 발견하게 되었습니다!</p>\n<h2 id=\"❓-RxFlow란\"><a href=\"#❓-RxFlow란\" class=\"headerlink\" title=\"❓ RxFlow란\"></a>❓ RxFlow란</h2><p>공식 GitHub 설명은 <code>RxFlow</code>를 다음과 같이 설명하고 있습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>RxFlow는 <code>Reactive Flow</code>를 활용하여 Coordinator 패턴을 구현한 iOS 앱을 위한 navigation 라이브러리이다.</p></blockquote>\n<p>요약하면 “코디네이터 패턴에 <code>rx</code>를 접목시켰다.” 정도겠네요.</p>\n<p><code>RxFlow</code>는 Coordinator 패턴을 Reactive화 시킨 것이기 때문에 Coordinator 패턴의 장단점을 먼저 설명하고 있습니다.</p>\n<h3 id=\"😊-장점\"><a href=\"#😊-장점\" class=\"headerlink\" title=\"😊 장점\"></a>😊 장점</h3><ul>\n<li><code>UIViewController</code>에서 네비게이션 코드를 분리한다.</li>\n<li><code>UIViewController</code>를 다른 화면 전환 상황에서도 재사용할 수 있다.</li>\n<li>의존성 주입을 쉽게 이룰 수 있다.</li>\n</ul>\n<h3 id=\"😭-단점\"><a href=\"#😭-단점\" class=\"headerlink\" title=\"😭 단점\"></a>😭 단점</h3><ul>\n<li>코디네이터 패턴의 기본적인 로직들은 앱을 bootstrap할 때마다 작성해주어야 한다.</li>\n<li>코디네이터 패턴 스택의 교류 과정에서 boilerplate 코드가 많이 발생할 수 있다.</li>\n</ul>\n<p>그렇다면 <code>RxFlow</code>는 어떤 발전을 이루었다고 주장하고 있을까요?</p>\n<ul>\n<li><code>Flows</code>를 활용하여 네비게이션을 좀 더 명확하게 발전시켰다.</li>\n<li><code>FlowCoordinator</code>를 기본적으로 제공하여 <code>Flows</code> 사이의 네비게이션을 제어할 수 있다.</li>\n<li>네비게이션 액션들이 Reactive하게 이루어진다.</li>\n</ul>\n<p>그리고 아래는 <code>RxFlow</code>를 이해하기 위해 알아두어야 할 6가지 용어들입니다.</p>\n<ul>\n<li><p><code>Flow</code>: 각각의 <code>Flow</code>는 앱의 <strong>네비게이션 공간</strong>들을 정의합니다. 이 공간은 네비게이션 <strong>액션들이 선언되는 곳</strong>입니다.</p>\n</li>\n<li><p><code>Step</code>: <code>Step</code>은 네비게이션까지 이어질 수 있는 <strong>state를 표현하기 위한 방법</strong>입니다. <strong><code>Flow</code>와 <code>Step</code>을 조합</strong>하면 <strong>가능한 모든 네비게이션 액션을 설명</strong>할 수 있습니다. <code>Step</code>은 (<code>id</code>나 <code>URL</code> 같은) 내부적인 값들을 지니고 있을 수도 있어 이 값들을 <code>Flow</code>에 선언되어 있는 화면들에 전달할 수도 있습니다.</p>\n</li>\n<li><p><code>Stepper</code>: <strong><code>Flow</code> 안에서 <code>Step</code>을 발생</strong>시킬 수 있다면, 그 어떤 것도 <code>Stepper</code>라고 불릴 수 있습니다.</p>\n</li>\n<li><p><code>Presentable</code>: <strong>Present 될 수 있는 어떤 것</strong>을 추상적으로 표현한 개념입니다. (기본적으로 <code>UIViewController</code>와 <code>Flow</code>가 <code>Presentable</code>한 객체입니다.)</p>\n</li>\n<li><p><code>FlowContributor</code>: 어떤 것들이 <code>Flow</code> 안에서 새로운 <code>Step</code>을 만들어낼 수 있을지를 <code>FlowCoordinator</code>에게 알려주는 간단한 데이터 구조입니다.</p>\n</li>\n<li><p><code>FlowCoordinator</code>: 개발자가 적절한 <code>Flow</code>와 <code>Step</code>을 조합하여 가능한 네비게이션을 정의하면, <code>FlowCoordinator</code>는 앱의 모든 네비게이션을 제어하기 위해 이 조합들을 섞습니다. <code>FlowCoordinator</code>는 <code>RxFlow</code>에 의해 제공되어 개발자가 직접 구현하지 않아도 됩니다.</p>\n</li>\n</ul>\n<h2 id=\"사용-예시\"><a href=\"#사용-예시\" class=\"headerlink\" title=\"사용 예시\"></a>사용 예시</h2><img src=\"https://raw.githubusercontent.com/RxSwiftCommunity/RxFlow/develop/Resources/RxFlow.gif\">\n\n<p>공식 문서는 위와 같은 영화 정보앱을 예시로 들어 설명하고 있습니다.</p>\n<p>하나씩 살펴볼게요..! 😉</p>\n<h3 id=\"Step-정의\"><a href=\"#Step-정의\" class=\"headerlink\" title=\"Step 정의\"></a>Step 정의</h3><p>우선 <code>Step</code>을 정의해주어야 합니다.</p>\n<p>한 가지 주의할 점은 <code>Step</code>은 앱의 상태를 나타내는 요소이기 때문에 어디로 navigation이 이루어질 지와 같은 <strong>특정적인 요소들은 <code>Step</code>이 아니라 <code>Flow</code>에서</strong> 정해줘야 한다고 합니다.</p>\n<p>예를 들어 <code>showMovieDetail(withID: Int)</code>는 영화를 선택했을 때 영화의 세부 정보를 보여주는 매우 특정된 케이스이기 때문에 바람직하지 않습니다.</p>\n<p>대신 <code>movieIsPicked(withID: Int)</code>와 같이 조금 더 <strong>독립적인 케이스</strong>를 추가해줘야 합니다. 이런 식으로 정의해주면 영화가 선택됐을 때 영화의 세부 정보 화면을 불러오는 것 말고도 다른 조건에서 다른 액션을 추가해줄 수 있습니다.</p>\n<p>아래와 같이 <code>enum</code> 타입으로 정의하는 것을 추천하고 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">enum DemoStep: Step &#123;\n\t&#x2F;&#x2F; Login\n\tcase loginIsRequired\n\tcase userIsLoggedIn\n\n\t&#x2F;&#x2F; Onboarding\n\tcase onboardingIsRequired\n\tcase onboardingIsComplete\n\n\t&#x2F;&#x2F; Home\n\tcase dashboardIsRequired\n\n\t&#x2F;&#x2F; Movies\n\tcase moviesAreRequired\n\tcase movieIsPicked(withID: Int)\n\tcase castIsPicked(withID: Int)\n\n\t&#x2F;&#x2F; Settings\n\tcase settingsAreRequired\n\tcase settingsAreComplete\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Flow-정의\"><a href=\"#Flow-정의\" class=\"headerlink\" title=\"Flow 정의\"></a>Flow 정의</h3><p><code>Flow</code> 정의는 두 가지를 필수적으로 해줘야합니다.</p>\n<ul>\n<li>네비게이션의 근간이 되는 root <code>Presentable</code>을 선언해줍니다.</li>\n<li><code>navigate(to:)</code> 메서드를 구현함으로서 <code>Step</code>을 네비게이션 액션으로 변환해주는 기능을 구현합니다.</li>\n</ul>\n<p><code>navigate(to:)</code> 메서드는 <code>FlowContributos</code>를 리턴합니다.</p>\n<p><code>.one(flowContributor: .contribute(withNextPresentable: viewController, withNextStepper: viewController.viewModel))</code><br>의 형태로 리턴을 하면 되는데요.. 각 파라미터는 다음과 같습니다.</p>\n<ul>\n<li><code>viewController</code>: 모두가 아는바와 같이 <code>Presentable</code>이고, LifeCycle에 따라 연결된 <code>Stepper</code>(<code>ViewModel</code>)가 <code>Step</code>을 emit하는 것에 영향을 줍니다.<ul>\n<li>예를 들어 <code>Presentable</code>이 hidden(present되지 않은 상황)일 경우, <code>Stepper</code>가 <code>Step</code>을 emit한다고 해도 해당 emit은 효력이 없습니다.</li>\n</ul>\n</li>\n<li><code>viewModel</code>: <code>Stepper</code>로서 연결된 <code>Presentable</code>의 LifeCycle에 영향을 받으며, <code>Step</code>을 emit함으로서 <code>Flow</code>안에서 네비게이션에 기여합니다.</li>\n</ul>\n<p>부가적으로 <code>Flow</code>는 View Controller를 instantiate 해줄 때 이루어지는 의존성 주입에 이용될 수도 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class WatchedFlow: Flow &#123;\n\tvar root: Presentable &#123;\n\t\treturn self.rootViewController\n\t&#125;\n\n\tprivate let rootViewController &#x3D; UINavigationController()\n\tprivate let services: AppServices\n\n\tinit(withServices services: AppServices) &#123;\n\t\tself.services &#x3D; services\n\t&#125;\n\n\tfunc navigate(to step: Step) -&gt; FlowContributors &#123;\n\t\tguard let step &#x3D; step as? DemoStep else &#123; return .none &#125;\n\n\t\tswitch step &#123;\n\t\tcase .moviesAreRequired:\n\t\t\treturn self.navigateToMovieListScreen()\n\t\tcase .movieIsPicked(let movieID):\n\t\t\treturn self.navigateToMovieDetailScreen(with: movieID)\n\t\tcase .castIsPicked(let castID):\n\t\t\treturn self.navigateToCastDetailScreen(with: castID)\n\t\tdefault:\n\t\t\treturn .none\n\t\t&#125;\n\t&#125;\n&#125;\n\nprivate extension WatchedFlow &#123;\n\n\tfunc navigateToMovieListScreen() -&gt; FlowContributors &#123;\n\t\tlet viewController &#x3D; WatchedViewController.instantiate(withViewModel: WatchedViewModel(), andServices: self.services)\n\t\tviewController.title &#x3D; &quot;Watched&quot;\n\n\t\tself.rootViewController.pushViewController(viewController, animated: true)\n\t\treturn .one(flowContributor: .contribute(withNextPresentable: viewController, withNextStepper: viewController.viewModel))\n\t&#125;\n\n\tfunc navigateToMovieDetailScreen(with movieID: Int) -&gt; FlowContributors &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n\n\tfunc navigateToCastDetailScreen(with castID: Int) -&gt; FlowContributors &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Stepper-정의\"><a href=\"#Stepper-정의\" class=\"headerlink\" title=\"Stepper 정의\"></a>Stepper 정의</h3><p><code>Stepper</code>는 <code>protocol</code>이기 때문에 어떤 것이든 될 수 있다고 합니다. ViewController가 될 수도 있고, ViewModel이 될 수도 있죠.</p>\n<p>하지만 ViewModel 같이 로직을 분리할 수 있는 곳에 사용하는 것이 적절합니다.</p>\n<p>RxFlow는 <code>OneStepper</code>라는 <code>Stepper</code> 클래스를 기본으로 구현하여 제공하고 있습니다. 아래와 같이 생겼는데요..</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">public class OneStepper: Stepper &#123;\n\tpublic let steps &#x3D; PublishRelay&lt;Step&gt;()\n\tprivate let singleStep: Step\n\n\tpublic init(withSingleStep singleStep: Step) &#123;\n\t\tself.singleStep &#x3D; singleStep\n\t&#125;\n\n\tpublic var initialStep: Step &#123;\n\t\treturn self.singleStep\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>이 <code>OneStepper</code>는 초기화와 동시에 오직 하나의 <code>Step</code>을 emit하는 것을 유일한 로직으로 갖는 <code>Stepper</code>입니다.</p>\n<p>새로운 <code>Flow</code>를 생성하고 첫 <code>Step</code>을 실행할 때 유용하다고 합니다.</p>\n<p>아래 <code>Stepper</code>는 <code>pick(movieID:)</code> 메서드가 실행될 때마다 <code>DemoStep.movieIsPicked(withID)</code>를 emit합니다.</p>\n<p>해당 <code>Step</code>이 emit되면, 위의 <code>WatchedFlow</code>에서 <code>navigate(to step:)</code> 메서드가 실행되고, 결과적으로 <code>navigateToMovieDetailScreen(withmovieID: Int)</code> 메서드가 실행되게 됩니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class WatchedViewModel: Stepper &#123;\n\tlet movies: [MovieViewModel]\n\tlet steps &#x3D; PublishRelay&lt;Step&gt;()\n\n\tinit(with service: MovieService) &#123;\n\t\tself.movies &#x3D; service.watchedMovies().map(&#123; movie -&gt; MovieViewModel in\n\t\t\treturn MovieViewModel(id: movie.id, title: movie.title, image: movie.image)\n\t\t&#125;)\n\t&#125;\n\n\t&#x2F;&#x2F; 영화가 pick 됐을 때 새로운 Step을 emit합니다.\n\t&#x2F;&#x2F; 이 emit은 WatchedFlow에서 네비게이션 액션을 촉발합니다.\n\tpublic func pick(movieID: Int) &#123;\n\t\tself.steps.accept(DemoStep.movieIsPicked(withID: movieID))\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","text":"RxFlowFavor 프로젝트는 ReactorKit을 사용하여 MVVM-C패턴에 RxSwift를 적극적으로 활용하고 있습니다. 하지만 저희 프로젝트에서 Reactive하지 못한 부분이 하나 있었습니다. 바로 Coordinator 부분인데요.. 하위 C...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Swift","slug":"Swift","count":31,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":82,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":82,"path":"api/tags/iOS.json"},{"name":"Favor","slug":"Favor","count":6,"path":"api/tags/Favor.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RxFlow\"><span class=\"toc-text\">RxFlow</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%9D%93-RxFlow%EB%9E%80\"><span class=\"toc-text\">❓ RxFlow란</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%98%8A-%EC%9E%A5%EC%A0%90\"><span class=\"toc-text\">😊 장점</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%98%AD-%EB%8B%A8%EC%A0%90\"><span class=\"toc-text\">😭 단점</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\"><span class=\"toc-text\">사용 예시</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-%EC%A0%95%EC%9D%98\"><span class=\"toc-text\">Step 정의</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Flow-%EC%A0%95%EC%9D%98\"><span class=\"toc-text\">Flow 정의</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Stepper-%EC%A0%95%EC%9D%98\"><span class=\"toc-text\">Stepper 정의</span></a></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"20)🍎 Swift - RxFlow.02","uid":"a4bb605dd85632e4da94987ee3e7cc44","slug":"Swift/2023-01-28-Swift20","date":"2023-01-27T15:00:00.000Z","updated":"2023-03-31T10:45:54.536Z","comments":true,"path":"api/articles/Swift/2023-01-28-Swift20.json","keywords":null,"cover":null,"text":"RxFlow험난한 길이 예상되지만 가봅시다.. 깃허브와 같은 순서대로 해봅시다. Step 정의import RxFlow enum FavorStep: Step &#123; case signInIsRequired &#125; 우선 로그인 Step만 만들어주...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"Swift","slug":"Swift","count":31,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":82,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":82,"path":"api/tags/iOS.json"},{"name":"Favor","slug":"Favor","count":6,"path":"api/tags/Favor.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"18)🍎 Swift - 다운샘플링","uid":"dd29b53b3fa8ec1be54827ce6b92cee8","slug":"Swift/2022-12-27-Swift18","date":"2022-12-26T15:00:00.000Z","updated":"2023-03-31T10:46:00.205Z","comments":true,"path":"api/articles/Swift/2022-12-27-Swift18.json","keywords":null,"cover":[],"text":"다운샘플링으로 메모리 효율적인 이미지 처리하기이전 게시물에서 알아보았던 PHPicker를 사용해서 이미지를 처리하던 중 아래와 같은 에러를 마주쳤습니다. Swift가 허용한 4,194,304 바이트보다 큰 데이터를 UserDefaults에 저장할 수 ...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"Swift","slug":"Swift","count":31,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":82,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":82,"path":"api/tags/iOS.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}