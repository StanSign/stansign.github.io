{"title":"9)🍎Swift - ARC(strong, weak, unowned)","uid":"feb104f2e415f3c30b5b2264f2206c66","slug":"Swift/2022-09-09-Swift09","date":"2022-09-08T15:00:00.000Z","updated":"2023-03-31T10:42:00.054Z","comments":true,"path":"api/articles/Swift/2022-09-09-Swift09.json","keywords":null,"cover":[],"content":"<p>Swift 문서에는 오랜만이네요. 최근 파이썬만 다루다보니 Swift 쪽 밀린 공부가 산더미에요.</p>\n<p>오늘은 ARC에 대해 알아볼겁니다. 이야기는 계속 들어왔고 참고하는 코드들에서도 매우 자주 보였는데 이번에 제대로 알아보고 가봐야겠습니다.</p>\n<h2 id=\"ARC-Automatic-Reference-Counting\"><a href=\"#ARC-Automatic-Reference-Counting\" class=\"headerlink\" title=\"ARC (Automatic Reference Counting)\"></a>ARC (Automatic Reference Counting)</h2><p>이름에서 알 수 있듯이 ARC는 참조와 관련된 기능입니다. 그리고 보기만해도 기분이 좋아지는 Automatic한 기능입니다. </p>\n<p>한 마디로 쉽게 넘기면 ARC는</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>자동으로 메모리를 관리해주는 아주 간편한 기능입니다. </p></blockquote>\n<p>여기서 조금 더 들어가면 ARC는,</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>컴파일 타임에 자동으로 <code>retain</code>, <code>release</code> 코드를 생성해주는 기능입니다. retain한 횟수를 추적하며 더 이상 참조되지 않는 인스턴스를 release해주는 것 이라고 설명할 수 있습니다.</p></blockquote>\n<p>모든 기기의 메모리(Heap) 영역은 유한된 자원입니다. 따라서 언제나 최적화가 필요하고, 가볍게 유지할 필요가 있죠!</p>\n<p>Swift가 공개되기 이전 Obj-C 언어로 iOS 앱을 개발했던 시절에는 이 메모리 관리를 개발자가 직접 수동으로 해주어야 했다고 합니다. 이때의 메모리 관리 방식을 MRC(Manual Reference Counting)이라고 부릅니다.</p>\n<ul>\n<li><code>retain</code>: <strong>reference count</strong>를 증가시켜 객체가 유지되도록 보장</li>\n<li><code>release</code>: <strong>reference count</strong>를 감소시켜 더 이상 사용되지 않는 객체가 메모리에 유지되는 것을 방지</li>\n</ul>\n<p>이 두 기능을 계속해서 반복해서 사용하며 메모리를 관리해주어야 했던 것이죠. 정말이지 너무 번거롭지 않나요..? 그래서 애플은 개발자들의 편의성을 위해 ARC를 등장시키게 된 것 입니다.</p>\n<p>ARC는 컴파일 타임에 수행됩니다. 그런데 수행되는 방식이 각각의 코드 중간중간에 자동으로 <code>retain</code> 코드와 <code>release</code> 코드를 삽입시키는 방식입니다.</p>\n<p><img src=\"https://i.imgur.com/0ddfizI.png\"><br>컴파일 타임에는 단순히 코드를 삽입만 해주고, 런타임동안 코드가 실행되며 <strong>reference count</strong>를 증감시킵니다. 그러다가 count 값이 0이 되면 <code>deinit</code>을 통해 메모리에서 해제시키는 것이죠!</p>\n<p>자 그런데, 자동으로 관리를 해주는 것이 아무리 편하더라도 개발자가 어느정도 메모리에 관여를 하고 싶을 때가 있겠죠? 그런 경우를 위해서 <code>strong</code>, <code>weak</code>, <code>unowned</code>가 존재하는 것 입니다.</p>\n<h3 id=\"strong-강한-참조\"><a href=\"#strong-강한-참조\" class=\"headerlink\" title=\"strong (강한 참조)\"></a><code>strong</code> (강한 참조)</h3><ul>\n<li>선언할 때 아무 키워드도 적어주지 않으면 기본값(default)으로 설정</li>\n<li>해당 인스턴스의 소유권을 가짐</li>\n<li>참조하는 인스턴스의 <strong>reference count</strong> 증가</li>\n<li><strong>strong reference count</strong>가 0이 되면 객체는 <code>deinit</code></li>\n<li>값 지정 시점에 <code>retain</code>, 참조 종료 시점에 <code>release</code></li>\n</ul>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token keyword\">var</span> david<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Person</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">:</span> <span class=\"token string-literal\"><span class=\"token string\">\"David\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// reference count ++</span>\n\ndavid <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span> <span class=\"token comment\">// reference count --</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>강한 참조를 사용할 때는 주의할 점이 하나 있습니다. 바로 **강한 참조 순환(Strong Reference Cycle)**입니다. </p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Strong</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">var</span> strong<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Strong</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">var</span> strong1<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Strong</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Strong</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> strong2<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Strong</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Strong</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nstrong1<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>strong <span class=\"token operator\">=</span> strong2\nstrong2<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>strong <span class=\"token operator\">=</span> strong1\n\nstrong1 <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span>\nstrong2 <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>위 예시를 보면 <code>strong1</code>과 <code>strong2</code>는 서로의 strong을 참조하고 있습니다. 이 때, strong은 강한 참조 객체라서 <code>nil</code>을 주기 전까진 해제되지 못합니다.<br>그런데 마지막 <code>strong1</code>과 <code>strong2</code>에 <code>nil</code> 값을 주려 할 때, 서로가 서로를 강하게 참조하고 있어 각각의 객체 변수는 메모리 해제가 되었지만, 객체 자체는 여전히 서로를 참조하며 메모리 해제가 되지 못합니다.<br>이렇게 되면 객체 변수는 이미 해제가 되어 객체에 접근할 방법도 없고, 객체를 메모리에서 해제할 방법도 없어지게 됩니다.<br>영원히 메모리에 머물러 메모리 누수가 발생하게 되는 것이죠.</p>\n<p>이런 현상을 해결하기 위해 weak (약한 참조)가 필요합니다.</p>\n<h3 id=\"weak-약한-참조\"><a href=\"#weak-약한-참조\" class=\"headerlink\" title=\"weak (약한 참조)\"></a><code>weak</code> (약한 참조)</h3><ul>\n<li>해당 인스턴스의 소유권을 가지지 않음</li>\n<li>주소값만 가짐으로서 포인터처럼 사용</li>\n<li><strong>reference count</strong>를 증가시키지 않음</li>\n<li><strong>weak reference count</strong>가 0이 되면 <code>dead</code></li>\n<li>메모리 해제될 때 자동으로 <code>nil</code>로 초기화</li>\n<li>해당 인스턴스가 <code>nil</code> 일 수 있기 때문에 항상 <code>optional</code>이어야 함<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token keyword\">weak</span> <span class=\"token keyword\">var</span> david<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Person</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span>named<span class=\"token punctuation\">:</span> <span class=\"token string-literal\"><span class=\"token string\">\"David\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 바로 객체 해제, nil</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<p>그렇다면 <code>weak</code>는 어떻게 참조 순환을 해결할까요?</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Strong</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">weak</span> <span class=\"token keyword\">var</span> strong<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Strong</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">var</span> strong1<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Strong</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Strong</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> strong2<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Strong</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Strong</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nstrong1<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>strong <span class=\"token operator\">=</span> strong2\nstrong2<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>strong <span class=\"token operator\">=</span> strong1\n\nstrong1 <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span>\nstrong2 <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>위와 같은 예시이지만 각각의 객체 변수가 <code>weak</code>(약한 참조)이기 때문에 ARC가  메모리에서 해제될 때 자동으로 객체까지 메모리에서 해제시켜 줍니다. </p>\n<p>참조 순환 문제가 해결되었네요!</p>\n<h3 id=\"unowned-미소유-참조\"><a href=\"#unowned-미소유-참조\" class=\"headerlink\" title=\"unowned (미소유 참조)\"></a><code>unowned</code> (미소유 참조)</h3><ul>\n<li>해당 인스턴스의 소유권을 가지지 않음</li>\n<li><strong>unowned reference count</strong>가 0이 되면 <code>free</code></li>\n<li>해당 인스턴스를 <code>nil</code>로 초기화하지 않음</li>\n</ul>\n<h3 id=\"그래서-셋의-차이는\"><a href=\"#그래서-셋의-차이는\" class=\"headerlink\" title=\"그래서 셋의 차이는?\"></a>그래서 셋의 차이는?</h3><ul>\n<li><code>strong</code><ul>\n<li>메모리에서 해제되는 것을 막기 위해 사용</li>\n<li>Reference Count 1 증가</li>\n</ul>\n</li>\n<li><code>weak</code><ul>\n<li>순환 참조의 가능성이 있을 경우 사용</li>\n<li>항상 <code>var</code> </li>\n<li>Reference Count 변동 X</li>\n</ul>\n</li>\n<li><h2 id=\"unowned\"><a href=\"#unowned\" class=\"headerlink\" title=\"unowned\"></a><code>unowned</code></h2></li>\n</ul>\n<h2 id=\"사이드-테이블-Side-Table-Entry\"><a href=\"#사이드-테이블-Side-Table-Entry\" class=\"headerlink\" title=\"사이드 테이블 (Side Table Entry)\"></a>사이드 테이블 (Side Table Entry)</h2><p>설명의 순서는 강한 참조 순환 때문에 <code>strong</code> ➡️ <code>weak</code> ➡️ <code>unowned</code>의 순서로 했지만 개념을 자세히 살펴보면 <code>strong</code> ➡️ <code>unowned</code> ➡️ <code>weak</code>의 순서로 보는 것이 맞습니다.</p>\n<p>강한 참조 변수와 미소유 참조 변수는 객체를 직접 참조하지만, 약한 참조 변수는 객체의 사이드 테이블을 참조하기 때문입니다.</p>\n<p>내부적으로 객체가 생성되면 <code>weak</code>, <code>unowned</code>, <code>strong</code>의 종류에 따라 따로 <strong>reference count</strong>를 세는 것이 아니라 모든 종류의 <strong>reference count</strong>를 전부 셉니다.</p>\n<p>순차적으로 살펴보면,<br><code>strong reference count</code>가 0이 되면 객체는 <code>deinit</code> 되지만 메모리에는 남아 있습니다.</p>\n<p>이후 <code>unowned reference count</code>를 체크하여 0이 아니라면 <code>DEINITED</code> 상태로 메모리에 쭈욱 남아있고, 0이라면 <code>free</code> 됩니다.</p>\n<p>그 이후에는 <code>weak reference count</code>를 체크하여 0이 아니라면 <code>FREED</code> 상태가 되어 사이드 테이블이 메모리에 남아있고, 0이 되었을때야 모든 <strong>reference count</strong>가 0이 되어 사이드 테이블이 메모리에서 해제되며 객체가 <code>DEAD</code> 상태가 됩니다.</p>\n<p><img src=\"https://i.imgur.com/0LZ1C7k.png\"></p>\n<p>위 State Machine 그래프로 한눈에 알아보기 쉽게 정리해볼 수 있습니다.</p>\n<h5 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h5><p><img src=\"https://velog.io/@wook4506/iOS-Swift-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B0%B8%EC%A1%B0-%EB%B0%A9%EB%B2%95-strong-weak-unowned\" alt=\"[iOS / Swift] 메모리 참조 방법\"><br><img src=\"https://jeonyeohun.tistory.com/373\" alt=\"[Swift] strong weak unowned의 비밀\"><br><img src=\"https://shubhamchawla00.medium.com/memory-management-on-ios-ad2244b49b20\" alt=\"Memory management on iOS\"></p>\n","text":"Swift 문서에는 오랜만이네요. 최근 파이썬만 다루다보니 Swift 쪽 밀린 공부가 산더미에요. 오늘은 ARC에 대해 알아볼겁니다. 이야기는 계속 들어왔고 참고하는 코드들에서도 매우 자주 보였는데 이번에 제대로 알아보고 가봐야겠습니다. ARC (Au...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Swift","slug":"Swift","count":28,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":76,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":76,"path":"api/tags/iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ARC-Automatic-Reference-Counting\"><span class=\"toc-text\">ARC (Automatic Reference Counting)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#strong-%EA%B0%95%ED%95%9C-%EC%B0%B8%EC%A1%B0\"><span class=\"toc-text\">strong (강한 참조)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#weak-%EC%95%BD%ED%95%9C-%EC%B0%B8%EC%A1%B0\"><span class=\"toc-text\">weak (약한 참조)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#unowned-%EB%AF%B8%EC%86%8C%EC%9C%A0-%EC%B0%B8%EC%A1%B0\"><span class=\"toc-text\">unowned (미소유 참조)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94\"><span class=\"toc-text\">그래서 셋의 차이는?</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#unowned\"><span class=\"toc-text\">unowned</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%82%AC%EC%9D%B4%EB%93%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-Side-Table-Entry\"><span class=\"toc-text\">사이드 테이블 (Side Table Entry)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%B0%B8%EA%B3%A0\"><span class=\"toc-text\">참고</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"1)🧰 Swift - 컴퓨터의 동작 원리","uid":"b08c3ce9980327554bb7435efb5f3b94","slug":"Allen/2022-09-19-Allen01","date":"2022-09-18T15:00:00.000Z","updated":"2023-03-31T10:30:35.048Z","comments":true,"path":"api/articles/Allen/2022-09-19-Allen01.json","keywords":null,"cover":null,"text":"이번에 Swift 언어와 iOS의 기본에 대해 부족하다는 생각이 들어서 앨런님의 온라인 부트캠프를 수강하게 되었습니다. 매주 내용들을 정리해보며 공부해볼 생각입니다!앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) CS 101컴...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":76,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":76,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"4)📘 Python - Context Manager","uid":"880e35cd89b3cfce92587e2ccc115063","slug":"Python/2022-07-16-Python04","date":"2022-07-15T15:00:00.000Z","updated":"2023-03-31T10:40:14.501Z","comments":true,"path":"api/articles/Python/2022-07-16-Python04.json","keywords":null,"cover":null,"text":"contextManagerContext Manager는 많은 코드 시간과 리소스 중에 정확히 원하는 시간과 리소스를 사용할 수 있도록 도와주는 기능입니다. 우리가 무심결에도 사용하던 with문 또한 Context Manager 중의 하나입니다. 이 w...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"python","slug":"python","count":4,"path":"api/categories/python.json"}],"tags":[{"name":"Python","slug":"Python","count":6,"path":"api/tags/Python.json"},{"name":"Context Manager","slug":"Context-Manager","count":1,"path":"api/tags/Context-Manager.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}