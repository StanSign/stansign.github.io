{"title":"15)🍎 Swift - ReactorKit","uid":"1cd419cd63835d685fc8cde482245df5","slug":"Swift/2022-12-04-Swift15","date":"2022-12-03T15:00:00.000Z","updated":"2023-03-31T10:42:54.374Z","comments":true,"path":"api/articles/Swift/2022-12-04-Swift15.json","keywords":null,"cover":[],"content":"<h1 id=\"ReactorKit\"><a href=\"#ReactorKit\" class=\"headerlink\" title=\"ReactorKit\"></a>ReactorKit</h1><p>앱스토어에 등록된 앱들의 오픈소스를 훔쳐보면 꽤나 자주 보였던 ReactorKit입니다.</p>\n<p>사실 막연하게 React Native랑 관련된건가보다~ 하고 지나치곤 했었는데.. 전혀 아니였죠? 😜</p>\n<p>겨울 프로젝트 동안 사용해야 할 것 같아서 공부해보게 되었습니다!</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://github.com/ReactorKit/ReactorKit\">ReactorKit</a></p></blockquote>\n<p><strong>ReactorKit</strong>은 <strong>RxSwift</strong>를 제대로, 또 편하게 사용하기 위해 나온 프레임워크입니다.</p>\n<p>공식 github에 설명된 글을 읽어보면, ReactorKit은 <strong>리액티브</strong>하고 <strong>일방성</strong>을 갖는 Swift 어플리케이션을 지원하기 위해 만들어졌다고 합니다.</p>\n<p>리액티브한거야 RxSwift 기반이니 그렇다고 치고, <strong>일방성</strong>에 주목하고 공부를 해보면 되겠네요!</p>\n<h2 id=\"기본-컨셉\"><a href=\"#기본-컨셉\" class=\"headerlink\" title=\"기본 컨셉\"></a>기본 컨셉</h2><img src=\"https://i.imgur.com/utDbuI4.png\" width=\"500\">\n\n<p>ReactorKit은 <code>View</code>와 <code>Reactor</code>라는 것 사이를 유저의 <code>Action</code>과 뷰의 <code>State</code>를 <code>Observable stream</code>을 만들어 전달한다고 합니다.</p>\n<p>당최 무슨 말인지 알 수가 없네요 🤯</p>\n<p>하나씩 차근차근 봅시다.</p>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3><p><code>View</code>는 우리가 생각하는 그 <code>View</code> 자체입니다.</p>\n<p>화면을 표시하는 모든 요소들을 <code>View</code>라고 하고 이 <code>View</code>들은 유저의 입력을 action stream으로 bind하거나 각각의 UI Component들에게 view states를 <code>bind</code>한다고 합니다.</p>\n<p>그러니까 <strong>1. 유저의 인터랙션을 받거나</strong> <strong>2. 하위 UI Component들에게 <code>Reactor</code>의 상태를 알려준다</strong>는 뜻인 것 같네요.</p>\n<p>이 <code>View</code>에는 비즈니스 로직이 없다고 합니다. 단지 전달자의 역할만 한다고 보면 될 것 같아요!</p>\n<p><code>View Controller</code>가 <code>View</code>라는 것을 명시하기 위해서 <code>View</code> 프로토콜을 채택하라고 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class ProfileViewController: UIViewController, View &#123;\n\tvar disposeBag &#x3D; DisposeBag()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><code>View</code> 프로토콜을 채택하는 것 만으로 이 뷰컨은 <code>reactor</code> 프로퍼티를 갖게 됩니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">profileViewController.reactor &#x3D; UserViewReactor()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>위와 같은 작업이 자동으로 이루어진다는 의미입니다.</p>\n<p>이렇게 주어진 <code>reactor</code>라는 프로퍼티가 변경되게 되면, <code>bind(reactor:)</code> 메서드가 자동으로 호출됩니다. action stream과 state stream을 정의하기 위해 뷰컨 안에 이 함수를 만들어줍시다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func bind(reactor: ProfileViewReactor) &#123;\n\t&#x2F;&#x2F; action (View -&gt; Reactor)\n\trefreshButton.rx.tap.map &#123; Reactor.Action.refresh &#125;\n\t\t.bind(to: reactor.action)\n\t\t.disposed(by: self.disposeBag)\n\n\t&#x2F;&#x2F; state (Reactor -&gt; View)\n\treactor.state.map &#123; $0.isFollowing &#125;\n\t\t.bind(to: followButton.rx.isSelected)\n\t\t.disposed(by: self.disposeBag)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>스토리보드도 지원한다고 합니다!</p>\n<p>스토리보드를 사용하는 뷰컨은 <code>View</code>가 아니라 <code>StoryboardView</code>를 채택해야 합니다!</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class MyViewController: UIViewController, StoryboardView &#123;\n\tfunc bind(reactor: MyReactor) &#123;\n\t\t...\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h3><p><code>Reactor</code>는 UI와는 전혀 관련없는 독립된 레이어 계층입니다.</p>\n<p>하지만 <code>View</code>의 상태를 결정해주는 아주 중대한 역할을 합니다.</p>\n<p>모든 <code>View</code>는 각자의 <code>Reactor</code>를 가져야하고, 모든 로직을 그 <code>Reactor</code>에 위임(delegate)합니다.</p>\n<p>그러면서도 <code>Reactor</code>는 <code>View</code>에 대한 의존성이 1도 없기 때문에 Unit Test하기에도 수월하다고 하네요!</p>\n<p><code>Reactor</code>를 사용하기 위해서는 <code>View</code>와 마찬가지로 <code>Reactor</code> 프로토콜을 채택해야 합니다.</p>\n<p>이 프로토콜을 채택한 객체는 <code>Action</code>, <code>Mutation</code>, <code>State</code> 세가지 타입을 가져야합니다.</p>\n<p>또한 <code>initialState</code>라는 프로퍼티도 가져야 한다고 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class ProfileViewReactor: Reactor &#123;\n\t&#x2F;&#x2F; represent user actions\n\tenum Action &#123;\n\t\tcase refreshFollowingStatus(Int)\n\t\tcase follow(Int)\n\t&#125;\n\n\t&#x2F;&#x2F; represent state changes\n\tenum Mutation &#123; \n\t\tcase setFollowing(Bool)\n\t&#125;\n\n\t&#x2F;&#x2F; represents the current view state\n\tstruct State &#123;\n\t\tvar isFollowing: Bool &#x3D; false\n\t&#125;\n\n\tlet initialState: State &#x3D; State()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p><code>Action</code><br>유저 인터랙션을 의미합니다.</p>\n</li>\n<li><p><code>State</code><br><code>View</code>의 상태를 의미합니다.</p>\n</li>\n<li><p>Mutation<br><code>Action</code>과 <code>State</code>를 이어주는 역할을 합니다.</p>\n</li>\n</ul>\n<p><code>Reactor</code>는 두 단계를 거쳐 action stream을 state stream으로 변환합니다.</p>\n<img src=\"https://i.imgur.com/yJ9zsoJ.png\" width=\"500\">\n\n<p>바로 <code>mutate()</code>와 <code>reduce()</code>를 통해서죠.</p>\n<p><code>mutate()</code>는 <code>Action</code>을 받아 <code>Observable&lt;Mutation&gt;</code>을 생성합니다.</p>\n<p>모든 비동기 작업들이나 API 호출 등이 여기에 들어가는 작업이라고 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func mutate(action: Action) -&gt; Observable&lt;Mutation&gt; &#123;\n\tswitch action &#123;\n\tcase let .refreshFollowingStatus(userID): &#x2F;&#x2F; receive action\n\t\treturn UserAPI.isFollowing(userID) &#x2F;&#x2F; create API stream\n\t\t\t.map &#123; (isFollowing: Bool) -&gt; Mutation in\n\t\t\t\treturn Mutation.setFollowing(isFollowing) &#x2F;&#x2F; convert to Mutation stream\n\t\t\t&#125;\n\tcase let .follow(userID):\n\t\treturn UserAPI.follow()\n\t\t\t.map &#123; _ -&gt; Mutation in\n\t\t\t\treturn Mutation.setFollowing(true)\n\t\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>reduce()</code>는 이전의 <code>State</code>와 <code>Mutation</code>으로부터 새로운 <code>State</code>를 만드는 메서드입니다.</p>\n<p>새로운 <code>State</code>를 동기적으로 반환하는 기능 외의 기능은 넣지 말라고 하네요.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func reduce(state: State, mutation: Mutation) -&gt; State &#123;\n\tvar state &#x3D; state &#x2F;&#x2F; create a copy of old state\n\tswitch mutation &#123;\n\tcase let .setFollowing(isFollowing):\n\t\tstate.isFollowing &#x3D; isFollowing &#x2F;&#x2F; manipulate the state, creating a new state\n\t\treturn state &#x2F;&#x2F; return new state\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>transform()</code>은 각 stream을 다른 stream으로 변환하는 기능을 하는 메서드입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func transform(action: Observable&lt;Action&gt;) -&gt; Observable&lt;Action&gt;\nfunc transform(mutation: Observable&lt;Mutation&gt;) -&gt; Observable&lt;Mutation&gt;\nfunc transform(state: Observable&lt;State&gt;) -&gt; Observable&lt;State&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"심화\"><a href=\"#심화\" class=\"headerlink\" title=\"심화\"></a>심화</h2><h3 id=\"Global-States\"><a href=\"#Global-States\" class=\"headerlink\" title=\"Global States\"></a>Global States</h3><p>Redux와 다르게 <strong>ReactorKit</strong>은 global app state를 정의하지 않는다고 합니다.</p>\n<p>저는 Redux가 뭔지 모르니 일단 넘어가볼게요..</p>\n<p>그렇기 때문에 global state를 아무걸로나 관리할 수 있다고 합니다. <code>BehaviorSubject</code>나 <code>PublishSubject</code>, 혹은 <code>reactor</code>를 사용해서 관리할 수 있다고 하네요.</p>\n<p>동시에 global state를 사용하도록 강제하지도 않는다고 합니다.</p>\n<p>ReactorKit에는 <strong>Action ➡️ Mutation ➡️ State</strong> Flow가 존재하지 않습니다.</p>\n<p>그래서 global state를 <code>Mutation</code>으로 변환하려면 <code>transform(mutation:</code>을 사용해야 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var currentUser: BehaviorSubject&lt;User&gt; &#x2F;&#x2F; global state\n\nfunc transform(mutation: Observable&lt;Mutation&gt;) -&gt; Observable&lt;Mutation&gt; &#123;\n\treturn Observable.merge(mutation, currentUser.map(Mutation.setUser))\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>위 예시는 <code>currentUser</code>가 바뀔 때  <code>Mutation.setUser</code>를 실행해달라는 코드입니다.</p>\n<p>*음.. 🤔 * </p>\n<p>*이 부분은 ReactorKit을 사용해가면서 차차 이해해봐야겠습니다… 😂  *</p>\n<h3 id=\"View-Communication\"><a href=\"#View-Communication\" class=\"headerlink\" title=\"View Communication\"></a>View Communication</h3><p>View간의 데이터 전달이 이루어질 때 보통 <code>delegate</code> 패턴이나 <code>closure</code>를 사용하죠?</p>\n<p>ReactorKit은 데이터 전달에 위 두 가지 방법을 사용하지 말고 <a href=\"https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Reactive.swift\">reactive extension</a>을 사용하는 것을 추천한다고 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#x2F;&#x2F; Read as &quot;Reactive Extension where Base is a SomeType&quot;\nextension Reactive where Base: SomeType &#123;\n\t&#x2F;&#x2F; Any specific reactive extension for SomeType\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<img src=\"https://i.imgur.com/0zL1XoU.png\" width=\"500\">\n\n<p>View A를 <code>ChatViewController</code>, View B를 <code>MessageInputView</code>라고 합시다.</p>\n<p>View B는 View A의 <code>subview</code>입니다.</p>\n<p>View B가 View A에 <code>ControlEvent</code>를 보내면 View A에서 본인의 reactor인 Reactor A에 <code>Action</code>을 전달하는 시나리오입니다.</p>\n<p>원래의 방식대로 View B에서 View A로 이벤트나 데이터를 전달하려면 <code>delegate</code>나 <code>closure</code>를 사용했었죠.</p>\n<p>대신 ReactorKit이 추천하는 방식대로 <code>Reactive extension</code>을 사용해서 구현을 해보면 아래와 같습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#x2F;&#x2F; MessageInputView.swift\nextension Reactive where Base: MessageInputView &#123;\n\tvar sendButtonTap: ControlEvent&lt;String&gt; &#123;\n\t\tlet source &#x3D; base.sendButton.rx.tap.withLatestFrom(...)\n\t\treturn ControlEvent(events: source)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#x2F;&#x2F; ChatViewController.swift\nmessageInputView.rx.sendButtonTap\n\t.map(Reactor.Action.send)\n\t.bind(to: reactor.action)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"ReactorKit앱스토어에 등록된 앱들의 오픈소스를 훔쳐보면 꽤나 자주 보였던 ReactorKit입니다. 사실 막연하게 React Native랑 관련된건가보다~ 하고 지나치곤 했었는데.. 전혀 아니였죠? 😜 겨울 프로젝트 동안 사용해야 할 것 같아서...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":81,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":81,"path":"api/tags/iOS.json"},{"name":"ReactorKit","slug":"ReactorKit","count":1,"path":"api/tags/ReactorKit.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ReactorKit\"><span class=\"toc-text\">ReactorKit</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EA%B8%B0%EB%B3%B8-%EC%BB%A8%EC%85%89\"><span class=\"toc-text\">기본 컨셉</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#View\"><span class=\"toc-text\">View</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reactor\"><span class=\"toc-text\">Reactor</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%8B%AC%ED%99%94\"><span class=\"toc-text\">심화</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Global-States\"><span class=\"toc-text\">Global States</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#View-Communication\"><span class=\"toc-text\">View Communication</span></a></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"42)🧰 Swift - 동시성 프로그래밍","uid":"8fd8cb15083779ba6732fe56b2a7d55a","slug":"Allen/2022-12-04-Allen42","date":"2022-12-03T15:00:00.000Z","updated":"2023-03-31T10:35:30.349Z","comments":true,"path":"api/articles/Allen/2022-12-04-Allen42.json","keywords":null,"cover":[],"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 비동기 프로그래밍비동기 처리가 필요한 이유네트워크 통신과 비동기 처리대부분의 앱에서는 서버와의 통신이 필요합니다. 당근 마켓의 화면입니다. UIKit의 요소만 보자면 단순하게 테...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":81,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":81,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"40)🧰 Swift - 네트워크 통신.01","uid":"1ca7fb6a95b8a418f4c9c554aca0e0f9","slug":"Allen/2022-12-03-Allen40","date":"2022-12-02T15:00:00.000Z","updated":"2023-03-31T10:35:22.054Z","comments":true,"path":"api/articles/Allen/2022-12-03-Allen40.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 네트워크 통신네트워킹TCP&#x2F;IP 인터넷에 관련된 다양한 프로토콜 집합의 총칭 프로토콜: 통신을 하기 위해 마련해둔 약속 HTTP, IP, FTP, UDP, TCP, IE...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":81,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":81,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}