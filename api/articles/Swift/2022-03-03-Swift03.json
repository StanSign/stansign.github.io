{"title":"3)🍎Swift - 클로저(Closure).03","uid":"e8e4dffd0540e6da0503ffe01c05cfbd","slug":"Swift/2022-03-03-Swift03","date":"2022-03-02T15:00:00.000Z","updated":"2023-03-31T10:40:56.160Z","comments":true,"path":"api/articles/Swift/2022-03-03-Swift03.json","keywords":null,"cover":null,"content":"<p>이번에는 @autoclosure와 @escaping에 대해 알아보겠습니다.</p>\n<hr>\n<h3 id=\"autoclosure\"><a href=\"#autoclosure\" class=\"headerlink\" title=\"@autoclosure\"></a>@autoclosure</h3><p>autoclosure도 우선 용어 자체를 살펴보겠습니다.</p>\n<p>자동-클로저?</p>\n<p>이게 대체 뭘까요?</p>\n<p>이번에는 정의를 살펴봅시다.</p>\n<p><strong>인자로서 전달된 일반구문&#x2F;함수를 클로저로서 감싸는 것</strong></p>\n<p>아무래도 일반구문&#x2F;함수를 자동으로 클로저로서 취급한다.. 라는 의미인 것 같네요.</p>\n<p>아직도 이해가 잘 가지 않으니 예제를 살펴보겠습니다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func foo(closure: @autoclosure () -&gt; ()) &#123;\n    &#x2F;&#x2F; Tasks\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>@autoclosure가 사용되는 위치도 잘 기억해주세요. 인자명 뒤 타입 정의 바로 앞에 위치해있습니다!</p>\n<p>자 그래서 대체 이게 무슨말이냐..</p>\n<p><strong>@autoclosure</strong>를 사용하면 클로저 타입의 인자 <strong>closure</strong>는 클로저가 아닌 일밤구문&#x2F;함수를 받아도 <strong>클로저로서 처리</strong>해줍니다.</p>\n<p>우선 @autoclosure를 사용하지 않았을 때를 봅시다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func foo(_ closure: () -&gt; Void) &#123;\n    closure()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>위 함수를 호출할 때 어떻게 호출할까요? 아래와 같이 호출합니다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">foo(&#123; \n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>이번엔 같은 함수에 @autoclosure를 사용해봅시다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func foo(_ closure: @autoclosure () -&gt; Void) &#123;\n    closure()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>위 함수는 아래처럼 호출됩니다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">foo(print(&quot;Hi! I&#39;m Closure&quot;))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>{ … }</strong> 이 중괄호가 없어진 것을 볼 수 있죠.</p>\n<p>클로저는 본인이 클로저임을 알리기 위해 중괄호가 무조건 필요합니다. @autoclosure는 클로저가 아닌 일반구문&#x2F;함수를 중괄호로 감싼 역할을 해주는 것이죠.</p>\n<p>단 유의할 점은 @autoclosure를 사용하기 위해서는 클로저의 인자가 없어야 합니다!</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func foo(closure: @autoclosure (Int) -&gt; Void) &#123;\n    closure()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>위와 경우 <strong>(Int) -&gt; Void</strong> 인자로 Int 타입이 들어가있죠?</p>\n<p>따라서 오류가 납니다. 꼭 주의해주세요!</p>\n<p>그렇다면 일반구문에 비해서 @autoclosure을 사용했을 때의 차이점은 무엇일까요?</p>\n<p>일반구문은 원래 실행 순서가 되면 <strong>즉시 실행</strong>됩니다. </p>\n<p>지연을 준다고 하더라도 지연을 주는 함수가 즉시 실행되었기 때문에 뒤에 따라오는 다른 함수들이 지연되는 것이죠.</p>\n<p>그런데 클로저는 즉시 실행되지 않습니다. 함수 안에서 <strong>해당 인자가 사용될 때 실행</strong>되죠.</p>\n<p>결론적으로 @escaping은 일반구문을 클로저처럼 사용하고 싶을 때 유용한 기능입니다.</p>\n<h3 id=\"escaping\"><a href=\"#escaping\" class=\"headerlink\" title=\"@escaping\"></a>@escaping</h3><p>@escaping 클로저란 용어의 이름에서 유추할 수 있듯이, 함수에서 벗어나서도 실행될 수 있는 클로저입니다.</p>\n<p>@escaping 클로저를 사용하면 다음과 같은 기능을 사용할 수 있습니다.</p>\n<ol>\n<li>함수가 끝난 뒤에도 실행될 수 있다.</li>\n<li>중첩함수에서 중첩함수를 return 할 수 있다.</li>\n<li>변수&#x2F;상수에 클로저를 대입할 수 있다.</li>\n</ol>\n<p>이 말은 지금까지 다뤘던 클로저들은 위의 경우들이 전부 불가능하다는 소리겠죠?</p>\n<p>지금까지 다뤄온 클로저들 같이 @escaping 구문을 사용하지 않은 클로저들을 non-escaping closure라고 부릅니다.</p>\n<p>API 라이브러리인 Alamofire의 예시를 보겠습니다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func dataGET(from url: URL, completion: @escaping (AnyObject) -&gt; ()) &#123;\n    DispatchQueue.global(qos: .background).async &#123;\n        Alamofire.request(url, method: .get).responseObject &#123; (response: DataResponse&lt;FilmResponse&gt;) in \n        switch response.result &#123;\n        case .success(_):\n            let res &#x3D; response.result.value\n            let resURL &#x3D; res.results.imageID\n            print(resURL ?? &quot;No URL Found&quot;)\n        case .failure(let error):\n            print(error)\n        &#125;&#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>굉장히 복잡해보이죠? 사실 다른건 다 필요없습니다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func dateGET(from url: URL, completion: @escaping (AnyObject) -&gt; ()) &#123;\n    DispatchQueue.global(qos: .background).async &#123;\n        &#x2F;&#x2F; Blah Blah\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>이렇게만 보면 됩니다.</p>\n<p>이제 우리는 저 함수를 분석할 수 있습니다! </p>\n<p>마지막 인자로 closure를 사용하여 <strong>Trailing Closure</strong> 방식이 채택되었네요. 또, <strong>@escaping</strong> 클로저가 사용된 것도 볼 수 있습니다. 왜 사용했을까요?</p>\n<p>API 호출은 상대적으로 많은 시간이 소요됩니다. 그래서 보통 비동기성으로 실행하죠. 유저가 로딩이 다 될 때까지 먹통이 된 앱을 가만히 보고 있진 않을테니까요. </p>\n<p>따라서 위 함수가 완료되기 전에 DispatchQueue로 실행한 구문들은 완료되었을 가능성이 거의 전무합니다. 여기서 @escaping 클로저가 아니라 non-escaping 클로저를 사용했다면..? <strong>함수가 종료됨과 동시에 함수 안에서 실행된 클로저까지 전부 종료되어 버립니다.</strong> 저희가 원하는 결과는 절대 아니죠.</p>\n<p>그리고 애초에 XCode에서 이를 허용하지 않습니다. **”Escaping closure captures non-escaping parameter”**라는 에러 메시지를 출력하며 빌드 에러가 나죠.</p>\n<hr>\n<p>이렇게 @autoclosure와 @escaping 클로저까지 알아봤습니다. @escaping 클로저는 온라인으로 통신하는 앱에서는 거의 필수적으로 사용법을 알아둬야 하니 꼼꼼하게 기억해둘 필요가 있습니다. 저처럼 헤매지 않으려면 말이죠 ㅜㅜ</p>\n","text":"이번에는 @autoclosure와 @escaping에 대해 알아보겠습니다. @autoclosureautoclosure도 우선 용어 자체를 살펴보겠습니다. 자동-클로저? 이게 대체 뭘까요? 이번에는 정의를 살펴봅시다. 인자로서 전달된 일반구문&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"Swift","slug":"Swift","count":29,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":77,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":77,"path":"api/tags/iOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#autoclosure\"><span class=\"toc-text\">@autoclosure</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#escaping\"><span class=\"toc-text\">@escaping</span></a></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"4)🍎Swift - RxSwift","uid":"ba350faaa7dac5578f5aca8757053cb0","slug":"Swift/2022-03-18-Swift04","date":"2022-03-17T15:00:00.000Z","updated":"2023-03-31T10:41:05.448Z","comments":true,"path":"api/articles/Swift/2022-03-18-Swift04.json","keywords":null,"cover":[],"text":"오늘은 모두가 쓰지만 저만 안쓰고 있던 RxSwift가 무엇이고, 어떻게 쓰는건지 알아보겠습니다. 우선 RxSwift는 Swift만 갖고 있는 라이브러리는 아닙니다. 원래의 프로젝트 명은 ReactiveX이고 이 이름으로는 어디선가 들어봤던 것 같기도...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"Swift","slug":"Swift","count":29,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":77,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":77,"path":"api/tags/iOS.json"},{"name":"RxSwift","slug":"RxSwift","count":2,"path":"api/tags/RxSwift.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"2)🍎Swift - 클로저(Closure).02","uid":"4bec864af0b8c90bc4e0e9a7d2f81123","slug":"Swift/2022-03-02-Swift02","date":"2022-03-01T15:00:00.000Z","updated":"2023-03-31T10:40:50.818Z","comments":true,"path":"api/articles/Swift/2022-03-02-Swift02.json","keywords":null,"cover":null,"text":"이번에는 덩치가 큰 클로저라는 친구를 다이어트 시키는 방법과 저를 곤란하게 만든 @escaping 클로저에 대해 알아보겠습니다 우리 클로저라는 친구는 덩치가 너무 큽니다.. 이전 게시물의 예시를 다시 가져와볼까요? foo(closure: &#123; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"Swift","slug":"Swift","count":29,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":77,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":77,"path":"api/tags/iOS.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}