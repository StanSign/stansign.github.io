{"title":"28)🍎 Swift - RxDataSources와 reloadData","uid":"865af57bf1f8e18b3c920c89fcdfd418","slug":"Swift/2023-05-07-Swift28","date":"2023-05-06T15:00:00.000Z","updated":"2023-05-08T15:56:49.644Z","comments":true,"path":"api/articles/Swift/2023-05-07-Swift28.json","keywords":null,"cover":"https://i.imgur.com/asYxn3y.png","content":"<h1 id=\"😵-DataSource를-reload-하는-과정에서-문제-발생\"><a href=\"#😵-DataSource를-reload-하는-과정에서-문제-발생\" class=\"headerlink\" title=\"😵 DataSource를  reload 하는 과정에서 문제 발생\"></a>😵 DataSource를  reload 하는 과정에서 문제 발생</h1><img src=\"https://i.imgur.com/qXjX4Zk.gif\" width=\"300\">\n\n<p>MyPage를 편집하는 View를 구현하던 중 하나의 Section 값이 업데이트 되면 다른 Section의 값이 초기값으로 돌아가는 현상을 마주했습니다.</p>\n<p>해당 View는 하나의 <code>UICollectionView</code>로 구성되었으며 최상단의 프로필&#x2F;배경 이미지 변경 부분은 Header, 이름&#x2F;ID&#x2F;취향 부분은 Section으로 구성되어 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">  private lazy var dataSource: EditMyPageDataSource &#x3D; EditMyPageDataSource(\n    configureCell: &#123; [weak self] _, collectionView, indexPath, item in\n      switch item &#123;\n      case let .name(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        return cell\n      case let .id(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        return cell\n      case let .favor(isSelected, favor):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as EditMyPagePreferenceCell\n        cell.isButtonSelected &#x3D; isSelected\n        cell.favor &#x3D; favor\n        return cell\n      &#125;\n    &#125;, configureSupplementaryView: &#123; dataSource, collectionView, kind, indexPath in\n      switch kind &#123;\n      case EditMyPageCollectionHeaderView.reuseIdentifier:\n        let header &#x3D; collectionView.dequeueReusableSupplementaryView(\n          ofKind: kind,\n          for: indexPath\n        ) as EditMyPageCollectionHeaderView\n        return header\n      case UICollectionView.elementKindSectionHeader:\n        let header &#x3D; collectionView.dequeueReusableSupplementaryView(\n          ofKind: kind,\n          for: indexPath\n        ) as FavorSectionHeaderView\n        let headerTitle &#x3D; dataSource[indexPath.section].header\n        header.updateTitle(headerTitle)\n        return header\n      case UICollectionView.elementKindSectionFooter:\n        let footer &#x3D; collectionView.dequeueReusableSupplementaryView(\n          ofKind: kind,\n          for: indexPath\n        ) as FavorSectionFooterView\n        footer.footerDescription &#x3D; dataSource[indexPath.section].footer\n        return footer\n      default:\n        return UICollectionReusableView()\n      &#125;\n    &#125;\n  )<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>DataSource를 바인딩하는 과정은 Rx와의 호환성을 고려하여 <code>RxDataSources</code> 라이브러리를 사용하고 있습니다.<br>추가적으로 cell을 dequeue하고 identifier를 정의하는 과정을 편리하게 구현하기 위해 <code>Reusable</code> 라이브러리를 사용하고 있습니다.</p>\n<h2 id=\"❓-원인-파악\"><a href=\"#❓-원인-파악\" class=\"headerlink\" title=\"❓ 원인 파악\"></a>❓ 원인 파악</h2><p>각 Cell에 rx를 사용하여 데이터를 바인딩하는 과정에서의 문제, Reactor의 <code>transform</code>에서 <code>newState</code>가 새롭게 생성되는 문제 등을 고려했지만 결국에는 모두 아니였습니다.</p>\n<p>원인은 <code>dataSource</code>에 <code>print</code>문을 넣은 후에 발견할 수 있었습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">  private lazy var dataSource: EditMyPageDataSource &#x3D; EditMyPageDataSource(\n    configureCell: &#123; [weak self] _, collectionView, indexPath, item in\n      switch item &#123;\n      case let .name(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        print(cell) &#x2F;&#x2F; 🖐️ 여기\n        return cell\n      case let .id(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        print(cell) &#x2F;&#x2F; 🖐️ 여기\n        return cell\n      case let .favor(isSelected, favor):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as EditMyPagePreferenceCell\n        cell.isButtonSelected &#x3D; isSelected\n        cell.favor &#x3D; favor\n        return cell\n      &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>문제가 발생하는 Section의 cell에 <code>print</code>문을 걸어보았습니다.</p>\n<img src=\"https://i.imgur.com/G41uFul.png\" width=\"500\">\n\n<p>각 Section에 하나의 Item만 포함되어 있으므로 취향 Section이 변경될때마다 모든 Section의 <code>dataSource</code>가 다시 정의되고 있었던 것입니다.</p>\n<p>모든 Section의 데이터가 reload되고 있다는 의심을 품고 RxDataSources 내부 코드를 파악해보기로 했습니다.</p>\n<h2 id=\"❗-원인-발견\"><a href=\"#❗-원인-발견\" class=\"headerlink\" title=\"❗ 원인 발견\"></a>❗ 원인 발견</h2><p>문제는 RxDataSources가 맞았습니다.</p>\n<p>일단 저희가 사용하고 있던 <code>RxCollectionViewSectionedReloadDataSource</code>의 경우는 다음과 같이 구성되어 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">open class RxCollectionViewSectionedReloadDataSource&lt;Section: SectionModelType&gt;\n    : CollectionViewSectionedDataSource&lt;Section&gt;\n    , RxCollectionViewDataSourceType &#123;\n    public typealias Element &#x3D; [Section]\n\n    open func collectionView(_ collectionView: UICollectionView, observedEvent: Event&lt;Element&gt;) &#123;\n        Binder(self) &#123; dataSource, element in\n            #if DEBUG\n                dataSource._dataSourceBound &#x3D; true\n            #endif\n            dataSource.setSections(element)\n            collectionView.reloadData() &#x2F;&#x2F; 👈 여기!\n                    collectionView.collectionViewLayout.invalidateLayout()\n        &#125;.on(observedEvent)\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>UIKit은 <code>UICollectionView</code>의 값을 reload하는 방법으로 크게</p>\n<ol>\n<li>모든 값을 reload하는 <code>reloadData()</code></li>\n<li>특정 Section만을 reload하는 <code>reloadSections()</code></li>\n<li>마지막으로 특정 Item만을 reload하는 <code>reloadItem(at:)</code><br>의 세가지 종류 API를 제공하고 있습니다.</li>\n</ol>\n<p>하지만 RxDataSources의 경우, 무조건 <code>reloadData()</code>를 호출하여 모든 값을 reload하고 있는 점을 볼 수 있습니다.</p>\n<p>ChatGPT에게 물어보니 RxDataSources는 규모가 작은 데이터를 다룰 때 사용되는 것을 고려하여 설계되었고, 모든 값을 reload하는 것이 다른 trade-off와 비교했을 때 효율적으로 판단했다고 합니다.</p>\n<p><img src=\"https://i.imgur.com/eIPDjzg.png\"></p>\n<p>정확한 정보인지 개인적으로 출처를 찾아보려 했지만 찾아볼 수는 없었습니다..<br>제보 받습니다.. 😅</p>\n<p><code>.name</code>과 <code>.id</code> 섹션의 경우에는 View가 로드됐을 때 단 한 번만 데이터가 로드되기 때문에 모든 Section이 reload되는 경우 초기값으로 돌아가는 것입니다.</p>\n<p>혹시나 <code>RxCollectionViewSectionedAnimatedDataSource</code>는 변경되는 Section을 골라내서 부분적으로 reload가 되나 싶었지만..<br>마찬가지로 애니메이션 처리만 부분적으로 처리되고 reload는 전체적으로 되고 있었습니다..</p>\n<h2 id=\"‼️-해결\"><a href=\"#‼️-해결\" class=\"headerlink\" title=\"‼️ 해결\"></a>‼️ 해결</h2><p>이를 해결하기 위해서는 두 가지 해결법이 있습니다.</p>\n<ol>\n<li>Custom DataSource 타입을 만들어 사용한다.</li>\n<li>RxDataSources를 사용하지 않는다.</li>\n</ol>\n<h3 id=\"Custom-DataSource-사용\"><a href=\"#Custom-DataSource-사용\" class=\"headerlink\" title=\"Custom DataSource 사용\"></a>Custom DataSource 사용</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class FavorDataSource&lt;Section: SectionModelType&gt;: RxCollectionViewSectionedReloadDataSource&lt;Section&gt; &#123;\n  override func collectionView(_ collectionView: UICollectionView, observedEvent: Event&lt;[Section]&gt;) &#123;\n    Binder(self) &#123; dataSource, element in\n      dataSource.setSections(element)\n      collectionView.reloadSections([2], animationStyle: .none) &#x2F;&#x2F; 👈 테스트를 위해 고정적으로 2번째 섹션만 reload되도록\n      collectionView.collectionViewLayout.invalidateLayout()\n    &#125;.on(observedEvent)\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>첫 번째 방법입니다.</p>\n<p>위와 같이 Custom DataSource를 만들어 사용하는 방법입니다.</p>\n<p><code>reloadData()</code> 대신 <code>reloadSections</code>나 <code>reloadItem(at:)</code>을 사용하는 Data Source를 따로 만들어 사용하는 방법입니다.</p>\n<p>테스트를 위해 우선 2번째 Section의 값들만 reload 되도록 구현해보았습니다.</p>\n<img src=\"https://i.imgur.com/q4pR5DY.gif\" width=\"300\">\n\n<p>Section이 깜빡이긴 하지만 일단 원하는대로 동작은 하는군요..</p>\n<p>단점은 Section의 형태에 따라 DataSource를 View에 맞게 각각 만들어서 사용해야 할 가능성이 있다는 점이였습니다.</p>\n<p>“언제 어떤 Section을 reload해야하는가?”를 Generic하게 계산해주어야 한다는 점은 일반적인 경우에서도 꽤나 복잡한 로직을 필요로 하고, 추후 과정에서 스파게티 코드가 될 것이라는 생각이 들어 부적절하다고 판단하였습니다.</p>\n<h3 id=\"RxDataSources-대신-DiffableDataSources-사용\"><a href=\"#RxDataSources-대신-DiffableDataSources-사용\" class=\"headerlink\" title=\"RxDataSources 대신 DiffableDataSources 사용\"></a>RxDataSources 대신 DiffableDataSources 사용</h3><p>사실 가장 좋은 방법은 Native 기능을 사용하는 것이겠죠?</p>\n<p>저는 DiffableDataSources에 대한 충분한 공부를 한 뒤 저희 프로젝트의 RxData Source를 DiffableDataSources로 대체해도 문제가 없겠다는 판단을 하고 RxDataSources를 걷어내기로 결정하였습니다.</p>\n<p>Rx를 사용하면서도 DiffableDataSources를 사용하는 데에는 아무 문제가 없을 것 같더라고요..</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>bind(to:)</code>를 사용하여 간편하게 데이터를 바인딩할 수 있다라는 장점만 포기한다면 RxDataSources를 걷어내는 데에는 아무 문제가 없었습니다.</p></blockquote>\n<p>심지어 API를 사용하는 형태도 상당히 유사해서 러닝 허들도 낮은 편에 속했습니다.</p>\n<p>하지만 제 상황에서의 DiffableDataSources를 사용하는 가장 큰 이점은 <strong>제가 원하는 시점에 제가 원하는 Section이나 Item만을 업데이트</strong> 해줄 수 있다는 점이였습니다.</p>\n<p>자 이제 리팩토링을 해봅시다..! 🔥</p>\n<h4 id=\"1-Section-정의\"><a href=\"#1-Section-정의\" class=\"headerlink\" title=\"1. Section 정의\"></a>1. Section 정의</h4><p>우선 두 가지 프로토콜을 정의해주었습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">public protocol SectionModelType: Hashable &#123; &#125;\npublic protocol SectionModelItem: Hashable &#123; &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>SectionIdentifier로 사용될 <code>SectionModelType</code>과 ItemIdentifier로 사용될 <code>SectionModelItem</code> 프로토콜입니다.</p>\n<p>이 두가지 프로토콜은 아무 기능도 하지 않고 오직 <code>Hashable</code>을 채택해주기만 했습니다. (DiffableDataSources에서 사용되려면 Hashable해야합니다!)</p>\n<p>추후에 필요하다면 기능을 추가해주겠지만 아직은 Generic에서의 타입 제한 용도로만 사용하고 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">enum ProfileSectionItem: SectionModelItem &#123;\n  case profileSetupHelper(ProfileSetupHelperCellReactor)\n  case preferences(ProfilePreferenceCellReactor)\n  case anniversaries(ProfileAnniversaryCellReactor)\n  case memo\n  case friends(ProfileFriendCellReactor)\n&#125;\n\nenum ProfileSection: SectionModelType &#123;\n  case profileSetupHelper\n  case preferences\n  case anniversaries\n  case memo\n  case friends\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>그리고 그 두가지 프로토콜을 채택한 예시입니다.</p>\n<p><code>SectionModelType</code>을 채택한 Section들과 <code>SectionModelItem</code>을 채택한 Item을 정의해줍니다.</p>\n<h4 id=\"2-Reactor-State-변경\"><a href=\"#2-Reactor-State-변경\" class=\"headerlink\" title=\"2. Reactor State 변경\"></a>2. Reactor State 변경</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var sections: [ProfileSection] &#x3D; []\nvar items: [[ProfileSectionItem]] &#x3D; []\n\nvar profileSetupHelperItems: [ProfileSectionItem] &#x3D; []\nvar preferencesItems: [ProfileSectionItem] &#x3D; []\nvar anniversaryItems: [ProfileSectionItem] &#x3D; []\nvar friendItems: [ProfileSectionItem] &#x3D; []<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>저는 각 Section에 대응되는 Item들을 따로 관리해주고 있습니다.</p>\n<p>이렇게 하는 편이 데이터들을 수정해주는 로직을 짤 떄 편하더라구요..</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func transform(state: Observable&lt;State&gt;) -&gt; Observable&lt;State&gt; &#123;\n  return state.map &#123; state in\n    var newState &#x3D; state\n    var newSections: [ProfileSection] &#x3D; []\n    var newItems: [[ProfileSectionItem]] &#x3D; []\n    var profileSetupHelperItems: [ProfileSectionItem] &#x3D; []\n\n    &#x2F;&#x2F; 취향\n    if !state.preferencesItems.isEmpty &#123;\n\t  newSections.append(.preferences)\n\t  newItems.append(state.preferencesItems)\n    &#125; else &#123;\n    profileSetupHelperItems.append(.profileSetupHelper(ProfileSetupHelperCellReactor(.preference)))\n    &#125;\n    &#x2F;&#x2F; 기념일\n    if !state.anniversaryItems.isEmpty &#123;\n\t  newSections.append(.anniversaries)\n\t  newItems.append(state.anniversaryItems)\n    &#125; else &#123;\n    profileSetupHelperItems.append(.profileSetupHelper(ProfileSetupHelperCellReactor(.anniversary)))\n    &#125;\n    &#x2F;&#x2F; 친구\n    newSections.append(.friends)\n    newItems.append(state.friendItems)\n    &#x2F;&#x2F; 새 프로필\n    if !profileSetupHelperItems.isEmpty &#123;\n\t  newSections.insert(.profileSetupHelper, at: .zero)\n\t  newItems.insert(profileSetupHelperItems, at: .zero)\n    &#125;\n  \n    newState.sections &#x3D; newSections\n    newState.items &#x3D; newItems\n    return newState\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>각 Item들에 대한 데이터들은 <code>transform(state:)</code>에서 통합해주는 방식으로 처리해주고 있습니다.</p>\n<h4 id=\"3-DataSource에-바인딩\"><a href=\"#3-DataSource에-바인딩\" class=\"headerlink\" title=\"3. DataSource에 바인딩\"></a>3. DataSource에 바인딩</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">reactor.state.map &#123; (sections: $0.sections, items: $0.items) &#125;\n  .asDriver(onErrorRecover: &#123; _ in return .empty()&#125;)\n  .drive(with: self, onNext: &#123; owner, sectionData in\n\tvar snapshot: NSDiffableDataSourceSnapshot&lt;ProfileSection, ProfileSectionItem&gt; &#x3D; .init()\n\tsnapshot.appendSections(sectionData.sections)\n\tsectionData.items.enumerated().forEach &#123; idx, items in\n\t  snapshot.appendItems(items, toSection: sectionData.sections[idx])\n\t&#125;\n\towner.dataSource.apply(snapshot, animatingDifferences: false)\n  &#125;)\n  .disposed(by: self.disposeBag)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>sections와 items 모두 Hashable하기 때문에 위와 같이 <code>appendSections</code>, <code>appendItems</code> 등의 DiffableDataSources의 API를 사용하여 <code>dataSource</code>에 바인딩해주면 끝입니다!</p>\n","feature":true,"text":"😵 DataSource를 reload 하는 과정에서 문제 발생 MyPage를 편집하는 View를 구현하던 중 하나의 Section 값이 업데이트 되면 다른 Section의 값이 초기값으로 돌아가는 현상을 마주했습니다. 해당 View는 하나의 UICol...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Swift","slug":"Swift","count":29,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Favor","slug":"Favor","count":6,"path":"api/tags/Favor.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%F0%9F%98%B5-DataSource%EB%A5%BC-reload-%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D\"><span class=\"toc-text\">😵 DataSource를  reload 하는 과정에서 문제 발생</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%9D%93-%EC%9B%90%EC%9D%B8-%ED%8C%8C%EC%95%85\"><span class=\"toc-text\">❓ 원인 파악</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%9D%97-%EC%9B%90%EC%9D%B8-%EB%B0%9C%EA%B2%AC\"><span class=\"toc-text\">❗ 원인 발견</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%BC%EF%B8%8F-%ED%95%B4%EA%B2%B0\"><span class=\"toc-text\">‼️ 해결</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Custom-DataSource-%EC%82%AC%EC%9A%A9\"><span class=\"toc-text\">Custom DataSource 사용</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RxDataSources-%EB%8C%80%EC%8B%A0-DiffableDataSources-%EC%82%AC%EC%9A%A9\"><span class=\"toc-text\">RxDataSources 대신 DiffableDataSources 사용</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Section-%EC%A0%95%EC%9D%98\"><span class=\"toc-text\">1. Section 정의</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Reactor-State-%EB%B3%80%EA%B2%BD\"><span class=\"toc-text\">2. Reactor State 변경</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-DataSource%EC%97%90-%EB%B0%94%EC%9D%B8%EB%94%A9\"><span class=\"toc-text\">3. DataSource에 바인딩</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"01)🎊 WWDC23 - What's new in UIKit","uid":"4932fe99e31aa6c7113fa36649ad4bc9","slug":"WWDC23/2023-06-07-WWDC23-01","date":"2023-06-06T15:00:00.000Z","updated":"2023-06-08T08:18:57.712Z","comments":true,"path":"api/articles/WWDC23/2023-06-07-WWDC23-01.json","keywords":null,"cover":"https://i.imgur.com/7ZMZmZ5.jpg","text":"WWDC23 - What’s new in UIKit드디어 WWDC23의 막이 열렸습니다! 다들 VisionOS 와 Vision Pro 보셨나요?? 너무너무 놀라워서 당장이라도 공부하고 싶은 마음이 컸지만.. 스유와 ARKit을 모른다면 쉽게 접근할 수...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"WWDC23","slug":"WWDC23","count":1,"path":"api/categories/WWDC23.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"WWDC23","slug":"WWDC23","count":1,"path":"api/tags/WWDC23.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"feature":true},"next_post":{"title":"27)🍎 Swift - CollectionView의 Cell/View에서의 subscribe 문제","uid":"c1d9a7680cb448c25291810a696ba7e7","slug":"Swift/2023-04-12-Swift27","date":"2023-04-11T15:00:00.000Z","updated":"2023-04-12T11:34:37.195Z","comments":true,"path":"api/articles/Swift/2023-04-12-Swift27.json","keywords":null,"cover":"https://i.imgur.com/asYxn3y.png","text":"❓ CollectionView의 HeaderView를 구독하는 과정에서 문제 발생 HeaderView의 버튼을 tap하면 바인딩된 Action이 여러번 발생하는 문제 발생 configureSupplementaryView: &#123; dataSourc...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Swift","slug":"Swift","count":29,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Favor","slug":"Favor","count":6,"path":"api/tags/Favor.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"feature":true}}