{"title":"6)📱iOS앱개발 - DB 재설계","uid":"291cbcf6b4765cf7164ff2800622aa73","slug":"Assemble/220124_06/2022-01-24-assemble06","date":"2022-01-23T15:00:00.000Z","updated":"2023-03-31T10:38:18.055Z","comments":true,"path":"api/articles/Assemble/220124_06/2022-01-24-assemble06.json","keywords":null,"cover":[],"content":"<h3 id=\"DB-재설계\"><a href=\"#DB-재설계\" class=\"headerlink\" title=\"DB 재설계\"></a>DB 재설계</h3><p>이전의 DB는 관계형DB로서의 기능을 하지 못하였습니다. 각 인스턴스 사이의 관계를 설명할 수 없었고, 자연스럽게 외래키도 잘못 연결되어 있었습니다. 그래서 다음과 같이 처음부터 다시 뜯어고쳤습니다. </p>\n<img src=\"https://github.com/StanSign/StanSign.github.io/blob/main/_posts/Assemble/220124_06/cap01.png?raw=true\" alt=\"table\" width=\"550\">\n\n<p>film과 filmInfo 테이블이 분리되어 있는 것이 비효율적이라 생각하여 통합하였고, 추가적인 정보를 더 제공하기 위해 새로운 테이블도 추가하였습니다. 관계를 설명하는 테이블에도 id를 부여하여 추후에 수정할 때 편하게 설계하였습니다. </p>\n<h3 id=\"1-CURRENT-TIMESTAMP\"><a href=\"#1-CURRENT-TIMESTAMP\" class=\"headerlink\" title=\"1. CURRENT_TIMESTAMP\"></a>1. CURRENT_TIMESTAMP</h3><p>films 테이블에 정보가 언제 마지막으로 수정되었는지 확인할 수 있도록 fLastUpdate 행을 새로 만들어 주었습니다. 이 부분은 AWS의 Lambda에서 직접 수정해주지 않아도 DB에서 자체적으로 update 시켜주길 원해서 방법을 찾아보았습니다. </p>\n<p>아래와 같이 원하는 행에 DEFAULT와 ON UPDATE를 이용해줍니다.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#39;fLastUpdate&#39; TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>DEFAULT CURRENT_TIMESTAMP</strong>: INSERT 시에 자동으로 현재 timestamp가 입력된다.<br><strong>ON UPDATE CURRENT_TIMESTAMP</strong>: UPDATE 시에 자동으로 현재 timestamp가 입력된다.</p>\n<h3 id=\"2-CHAR-VARCHAR-TEXT\"><a href=\"#2-CHAR-VARCHAR-TEXT\" class=\"headerlink\" title=\"2. CHAR, VARCHAR, TEXT\"></a>2. CHAR, VARCHAR, TEXT</h3><p>films 테이블의 fPlot 행은 영화의 대략적인 줄거리를 설명하는 글이 저장되는 공간입니다. 이 공간은 다른 행에 비해서 많은 양의 데이터가 들어갈 것이기 때문에 저장공간의 낭비없이 공간을 할당해줄 수 있을까 싶어 SQL이 지원하는 데이터 타입을 둘러보게 되었습니다. </p>\n<p>문자열을 저장하는 데이터타입 중 많이 사용되는 <strong>VARCHAR, CHAR, TEXT</strong> 타입이 있습니다. 이 셋에는 차이점이 존재하는데 정리해보면 아래와 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th>데이터 타입</th>\n<th align=\"center\">사이즈 (byte)</th>\n<th align=\"center\">가변형</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CHAR</strong></td>\n<td align=\"center\">&lt;&#x3D; 255</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><strong>VARCHAR</strong></td>\n<td align=\"center\">&lt;&#x3D; 65535</td>\n<td align=\"center\">O</td>\n</tr>\n<tr>\n<td><strong>TEXT</strong></td>\n<td align=\"center\">&lt;&#x3D; 65535</td>\n<td align=\"center\">O</td>\n</tr>\n</tbody></table>\n<p><strong>1. CHAR</strong><br>고정된 크기를 갖는 데이터 타입입니다. 예를 들면, CHAR(4)로 선언된 행은 고정적으로 4-byte의 크기를 할당받습니다.<br><strong>2. VARCHAR, TEXT</strong><br>가변형 크기를 갖는 데이터 타입입니다. 예를 들면, VARCHAR(45)로 45-byte 크기의 행을 설정해줘도, 실제로 갖는 내용이 4-byte라면 4-byte를 할당받습니다. 45-byte는 들어가는 값의 최대 크기가 됩니다.</p>\n<p>그렇다면 이 둘의 차이는 또 무엇일까요?<br><strong>TEXT</strong> 타입은 최대 크기를 지정해주지 못합니다. 고정적으로 <strong>65535</strong> 사이즈의 최대 크기를 갖게되는 것이죠.<br>반대로 <strong>VARCHAR</strong> 타입은 최대 크기를 지정해줄 수 있습니다. 위 예시의 VARCHAR(<strong>45</strong>)는 <strong>45-byte</strong>의 최대 크기를 지정해준 것입니다.</p>\n<p>또, 이 두 데이터 타입은 실제로 갖는 데이터 외에도 자신의 사이즈를 저장하기 위해 추가적인 공간을 사용하는데, VARCHAR 타입은 1<del>255 사이즈일 경우 1-byte, 256</del>65535 사이즈일 경우 2-byte를 사용하지만 TEXT 타입은 최대 크기가 고정적으로 65535-byte이므로 2-byte를 사용합니다.</p>\n<p>추가적으로 TEXT 타입의 행은 INDEX로 사용될 수 없고, 메모리가 아닌 하드디스크에 저장되기 때문에 쿼리시에 속도가 느릴 수 있습니다.</p>\n<h3 id=\"3-BLOB\"><a href=\"#3-BLOB\" class=\"headerlink\" title=\"3. BLOB\"></a>3. BLOB</h3><p>TEXT 타입과 비슷한 타입이 하나 더 있습니다. BLOB(Binary Large OBject)이라는 데이터 타입인데, 이 두 데이터 타입은 모두 문자열을 저장하지만 BLOB 타입은 문자셋과 콜레이션이 없는 바이너리 데이터를 저장하고, TEXT 타입은 문자셋과 콜레이션이 있는 텍스트 데이터를 저장한다는 점이다. 대표적인 문자셋으로는 utf-8이 있고, 콜레이션을 통해 대소문자 등 글자를 서로 구분하는 법칙을 지정할 수 있다. </p>\n<p>BLOB 타입의 데이터는 이미지 파일을 저장할 수 있다. 이미지를 Base64로 인코딩한 후, utf-8로 디코드하면 바이너리 형식의 긴 텍스트를 얻어낼 수 있다. 이 텍스트를 DB에 저장하고, 다시 SELECT로 불러올 때도 디코딩 과정을 거치면 이미지 파일을 얻어낼 수 있다.</p>\n<h3 id=\"4-이미지-저장\"><a href=\"#4-이미지-저장\" class=\"headerlink\" title=\"4. 이미지 저장?\"></a>4. 이미지 저장?</h3><p>작은 이미지 파일을 저장할 때는 BLOB 타입으로 충분히 감당이 가능하다. 하지만 현재의 이미지는 BLOB 타입으로 DB에 직접 저장하기에는 너무 커졌다. DB에 이미지 파일을 직접 저장하면 안되는 이유는 다음과 같다.</p>\n<ol>\n<li>백업과 복원에 상당한 시간이 소요된다. 오랜 기간 소요되는 복원은 DB의 성능에 심각한 저하를 가져오고, DB가 손상되어 급하게 복원이 필요할 때 시간이 소요되어 소비자들이 불편을 갖게 된다.</li>\n<li>상당한 자원을 소모한다. Azure나 AWS와 같은 서비스를 사용한다면 제한된 용량을 빠르게 소모할 것이고, 예상치 못한 금액을 지불해야 할 수도 있다.</li>\n<li>직관적이지 않다. BLOB으로 변환된 이미지 파일은 사람이 알아볼 수 없다.</li>\n</ol>\n<p>그렇다면 어떻게 하는 것이 좋을까?</p>\n<p>물리적인 하드디스크를 하나 사용하여 모든 이미지 파일들을 그 곳에 저장하고, DB에는 그 파일과의 연결 관계를 만들어준다. 클라우드에 저장하는 것보다 훨씬 빠르고, 저렴하게 이미지 파일을 저장할 수 있다. 이미지 파일을 열어보는 것 조차 너무나도 쉬워진다.</p>\n","text":"DB 재설계이전의 DB는 관계형DB로서의 기능을 하지 못하였습니다. 각 인스턴스 사이의 관계를 설명할 수 없었고, 자연스럽게 외래키도 잘못 연결되어 있었습니다. 그래서 다음과 같이 처음부터 다시 뜯어고쳤습니다. film과 filmInfo 테이블이 분리...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"Assemble","slug":"Assemble","count":9,"path":"api/categories/Assemble.json"}],"tags":[{"name":"Assemble","slug":"Assemble","count":9,"path":"api/tags/Assemble.json"},{"name":"mySQL","slug":"mySQL","count":4,"path":"api/tags/mySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DB-%EC%9E%AC%EC%84%A4%EA%B3%84\"><span class=\"toc-text\">DB 재설계</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-CURRENT-TIMESTAMP\"><span class=\"toc-text\">1. CURRENT_TIMESTAMP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-CHAR-VARCHAR-TEXT\"><span class=\"toc-text\">2. CHAR, VARCHAR, TEXT</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-BLOB\"><span class=\"toc-text\">3. BLOB</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A0%80%EC%9E%A5\"><span class=\"toc-text\">4. 이미지 저장?</span></a></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"7)📱iOS앱개발 - API Gateway로 DB에 정보 입력/수정하기","uid":"63d243280a5706ad4c80cf0178f771fe","slug":"Assemble/220125_07/2022-01-25-assemble07","date":"2022-01-24T15:00:00.000Z","updated":"2023-03-31T10:38:30.780Z","comments":true,"path":"api/articles/Assemble/220125_07/2022-01-25-assemble07.json","keywords":null,"cover":[],"text":"DB 틀이 어느정도 맞춰졌으니 실제로 데이터를 넣어보려고 합니다. 이전에 만들어두었던 Lambda 함수와 API Gateway를 사용하면 RESTful하게 데이터를 입력해줄 수 있습니다. API Gateway 위와 같이 리소스를 생성해주고 PUT 메서...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"Assemble","slug":"Assemble","count":9,"path":"api/categories/Assemble.json"}],"tags":[{"name":"Assemble","slug":"Assemble","count":9,"path":"api/tags/Assemble.json"},{"name":"mySQL","slug":"mySQL","count":4,"path":"api/tags/mySQL.json"},{"name":"AWS","slug":"AWS","count":5,"path":"api/tags/AWS.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"5)📱iOS앱개발 - Lambda 함수 생성 & API 배포하기","uid":"3dd5dd23bc1bf752e32b431e49dca7c1","slug":"Assemble/220112_05/2022-01-12-assemble05","date":"2022-01-11T15:00:00.000Z","updated":"2023-03-31T10:38:04.381Z","comments":true,"path":"api/articles/Assemble/220112_05/2022-01-12-assemble05.json","keywords":null,"cover":[],"text":"함수를 테스트할 로컬 환경 만들기완성된 함수를 아마존 서버에 올리고 싶어서 로컬에서 먼저 테스트하기 위한 환경을 만들어주겠습니다. 파이썬을 사용해서 MySQL에 접근해야하기 때문에 먼저 PyMySQL이라는 라이브러리를 설치해야 합니다. 아래 명령어로 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Assemble","slug":"Assemble","count":9,"path":"api/categories/Assemble.json"}],"tags":[{"name":"Python","slug":"Python","count":6,"path":"api/tags/Python.json"},{"name":"Assemble","slug":"Assemble","count":9,"path":"api/tags/Assemble.json"},{"name":"mySQL","slug":"mySQL","count":4,"path":"api/tags/mySQL.json"},{"name":"AWS","slug":"AWS","count":5,"path":"api/tags/AWS.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}