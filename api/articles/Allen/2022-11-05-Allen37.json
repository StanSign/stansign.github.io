{"title":"37)🧰 Swift - 메모리 관리 (ARC)","uid":"c821c58f061b1a40d9641a5392a7fb36","slug":"Allen/2022-11-05-Allen37","date":"2022-11-04T15:00:00.000Z","updated":"2023-03-31T10:35:00.838Z","comments":true,"path":"api/articles/Allen/2022-11-05-Allen37.json","keywords":null,"cover":[],"content":"<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8\">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>\n<h1 id=\"ARC-Automatic-Reference-Counting\"><a href=\"#ARC-Automatic-Reference-Counting\" class=\"headerlink\" title=\"ARC (Automatic Reference Counting)\"></a>ARC (Automatic Reference Counting)</h1><h2 id=\"스위프트의-메모리-관리-모델\"><a href=\"#스위프트의-메모리-관리-모델\" class=\"headerlink\" title=\"스위프트의 메모리 관리 모델\"></a>스위프트의 메모리 관리 모델</h2><h3 id=\"값-형식과-참조-형식\"><a href=\"#값-형식과-참조-형식\" class=\"headerlink\" title=\"값 형식과 참조 형식\"></a>값 형식과 참조 형식</h3><p>메모리 관리에 대해 공부하기 전에 메모리 관리가 어떤 때에 필요한 지 먼저 알아보겠습니다.</p>\n<h4 id=\"값-형식\"><a href=\"#값-형식\" class=\"headerlink\" title=\"값 형식\"></a>값 형식</h4><ul>\n<li>필요시에 메모리의 스택 영역에 값을 저장합니다.</li>\n<li>값이 들어있는 스택 영역의 스코프가 종료되면 메모리에서 자동으로 해제됩니다.</li>\n<li>Swift의 기본 타입(Int, String, …)들, 튜플, 구조체, 열거형, 컬렉션 등</li>\n</ul>\n<h4 id=\"참조-형식\"><a href=\"#참조-형식\" class=\"headerlink\" title=\"참조 형식\"></a>참조 형식</h4><ul>\n<li>필요시에 메모리의 힙 영역에 값을 저장하고, 스택 영역에 주소를 저장합니다.</li>\n<li><strong>RC(Reference Counting)</strong> 을 통해 메모리를 관리합니다. ➡️ <strong>ARC</strong></li>\n<li>클래스, 클로저</li>\n</ul>\n<p>값 형식과 참조 형식의 차이점을 보면 알 수 있듯이, 참조 형식의 데이터들은 힙 영역에 저장되기 때문에 별도의 Reference Counting 모델이 필요합니다. </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>힙 영역 데이터에는 왜 별도의 관리 모델이 필요한건가요?</p></blockquote>\n<h5 id=\"메모리의-구조\"><a href=\"#메모리의-구조\" class=\"headerlink\" title=\"메모리의 구조\"></a>메모리의 구조</h5><p>힙 영역과 스택 영역의 차이점을 기억해내기 위해 메모리의 구조를 한 번 복습해볼까요?</p>\n<ul>\n<li><strong>코드</strong>: 명령어 &#x2F; 프로그램</li>\n<li><strong>데이터</strong>: 전역 변수 &#x2F; 타입 변수<ul>\n<li>앱이 실행되는 공간 변하지 않는 공유하기 위한 데이터</li>\n</ul>\n</li>\n<li><strong>힙</strong>: 동적 할당<ul>\n<li>크기가 크고, 관리가 필요한 데이터</li>\n</ul>\n</li>\n<li><strong>스택</strong>: 함수 실행을 위한 임시 공간<ul>\n<li>크기가 작고 단기간 사용하기 위한 데이터</li>\n</ul>\n</li>\n</ul>\n<p><strong>스택 영역</strong>의 데이터들은 빠르게 사용되고 빠르게 해제되기 때문에 메모리 관리가 별도로 필요하지 않습니다. <strong>데이터 영역</strong>의 데이터들은 프로그램이 실행되는 동안 유지되는 불변의 데이터이기 때문에 마찬가지로 해제가 필요하지 않습니다.</p>\n<p>하지만 힙 영역의 데이터들은 스택 영역에 비해 비교적 오랜 기간 머물면서, 동적 할당되기 때문에 빈 공간에 임의로 영역을 잡아 저장됩니다.</p>\n<p>문제는 힙 영역의 데이터는 관리를 해주지 않으면 계속해서 메모리를 잡아먹으면서 상주한다는 점입니다. 이를 <strong>메모리 누수(Memory Leak)</strong> 라고 부릅니다.</p>\n<p>이 문제를 해결하기 위해 Swift에서는 <strong>ARC</strong>라는 메모리 관리 모델이 적용되었습니다.</p>\n<h3 id=\"Java와-Obj-C-Swift의-메모리-관리-모델\"><a href=\"#Java와-Obj-C-Swift의-메모리-관리-모델\" class=\"headerlink\" title=\"Java와 Obj-C, Swift의 메모리 관리 모델\"></a>Java와 Obj-C, Swift의 메모리 관리 모델</h3><table>\n<thead>\n<tr>\n<th align=\"center\"><strong>Java</strong></th>\n<th align=\"center\"><strong>Obj-C</strong></th>\n<th align=\"center\"><strong>Swift</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Garbage Collector)</td>\n<td align=\"center\">MRC + ARC</td>\n<td align=\"center\">ARC</td>\n</tr>\n</tbody></table>\n<h4 id=\"Java의-Garbage-Collector\"><a href=\"#Java의-Garbage-Collector\" class=\"headerlink\" title=\"Java의 Garbage Collector\"></a>Java의 Garbage Collector</h4><p>메모리 누수가 힙 영역의 메모리 할당 문제라면, 이 문제는 Swift 뿐만 아니라 다른 언어에서도 발생하는 문제일 것입니다.</p>\n<p>객체기반 언어의 어머니라고 불리는 Java에서는 Garbage Collector라는 모델이 적용되었습니다.</p>\n<p><strong>Garbage Collector</strong> 모델은 프로그램 실행중(런타임)에 힙 영역에 할당된 모든 데이터들을 스캔합니다. 그 후에 해제되어도 되겠다고 판단되는 데이터들을 알아서 메모리에서 해제해줍니다. </p>\n<p>따라서 이 모델의 장점은 개발자가 따로 신경 써주지 않아도 알아서 메모리 누수 관리가 된다는 점입니다. 반대로 단점은 힙 영역을 모두 스캔하는 과정이 필요로 하기 때문에 비교적 느리다는 점이 있습니다.</p>\n<h4 id=\"Swift의-Reference-Counting\"><a href=\"#Swift의-Reference-Counting\" class=\"headerlink\" title=\"Swift의 Reference Counting\"></a>Swift의 Reference Counting</h4><p><strong>Reference Counting</strong> 모델은 할당된 데이터가 참조되고 있는 곳의 수를 세면서 참조 카운터가 0이 되는 순간 메모리에서 해제되는 모델입니다.</p>\n<p>이 RC 모델은 카운팅을 개발자가 수동으로 해줘야하는 <strong>MRC(Manual RC)</strong> 모델과 컴파일러가 자동으로 수행해주는 <strong>ARC(Automatic RC)</strong> 모델로 나뉩니다. </p>\n<p>Swift 이전에 쓰였던 Obj-C 언어에서는 MRC와 ARC 모델을 섞어서 사용하였지만, Swift 언어로 넘어온 후부터는 ARC 모델만을 사용하게 되었습니다.</p>\n<h5 id=\"주의\"><a href=\"#주의\" class=\"headerlink\" title=\"주의\"></a>주의</h5><p>ARC 모델은 Java의 Garbage Collector 모델과는 다르게 메모리 관리 자체를 자동으로 해주지는 않습니다. </p>\n<p>ARC 모델의 Automatic은 <strong>Reference Counting을 자동으로 해준다</strong>는 점에 초점이 맞춰져 있습니다. 따라서 이 카운팅되는 법칙을 개발자가 잘 알지 못하고 사용한다면, 원하지 않을 때 카운터가 증가될수도, 감소될수도 있습니다.</p>\n<h2 id=\"MRC-Manual-Reference-Counting\"><a href=\"#MRC-Manual-Reference-Counting\" class=\"headerlink\" title=\"MRC (Manual Reference Counting)\"></a>MRC (Manual Reference Counting)</h2><p><img src=\"https://i.imgur.com/Kzh9oUV.png\"></p>\n<p>위 예시는 애플이 wwdc2016에서 발표한 내용입니다.</p>\n<p>XCode는 실제로 개발자가 작성한 코드(왼쪽)에 ARC를 위한 코드들을 삽입(오른쪽)하여 컴파일합니다. <code>refCount</code>라는 카운터 변수를 클래스에 넣어주고, <code>retain</code>과 <code>release</code>를 통해 카운터를 증가시키거나 감소시킨다는 것을 볼 수 있습니다.</p>\n<ul>\n<li><code>retain</code>: 메모리 할당 (RC + 1)</li>\n<li><code>release</code>: 메모리 해제 (RC - 1)</li>\n</ul>\n<p>MRC 모델을 사용할 때는 이와 같은 코드들을 개발자가 직접 넣어주어야 했습니다. ARC 모델을 사용하는 지금은 XCode가 컴파일할 때 자동으로 추가해줍니다!</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nvar choco: Dog? &#x3D; Dog(name: &quot;초코&quot;, weight: 15.0) &#x2F;&#x2F; retain(choco) RC 1\nvar bori: Dog? &#x3D; Dog(name: &quot;보리&quot;, weight: 10.0) &#x2F;&#x2F; retain(choco) RC 1\n\nchoco &#x3D; nil &#x2F;&#x2F; &quot;초코 메모리 해제&quot; RC 0\n&#x2F;&#x2F; release(choco)\nbori &#x3D; nil &#x2F;&#x2F; &quot;보리 메모리 해제&quot; RC 0\n&#x2F;&#x2F; release(bori)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"강한-참조-사이클과-메모리-누수\"><a href=\"#강한-참조-사이클과-메모리-누수\" class=\"headerlink\" title=\"강한 참조 사이클과 메모리 누수\"></a>강한 참조 사이클과 메모리 누수</h2><p>강한 참조 사이클은 객체가 <strong>서로를 참조</strong>하는 상황에서 일어납니다. </p>\n<p>객체가 서로를 참조하게 되면 <strong>서로의 Reference Count를 1씩 증가</strong>시킵니다.</p>\n<p>이런 상황이 발생하면 두 객체에 <code>nil</code>을 할당한다고 해도 서로의 RC를 계속해서 유지하고 있기 때문에 해제되지 못하고 상주하게 되는 문제가 발생합니다.</p>\n<p>이를 <strong>메모리 누수(Memory Leak)</strong> 라고 부릅니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tvar name: String\n\tvar owner: Person?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nclass Person &#123;\n\tvar name: String\n\tvar pet: Dog?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nvar bori: Dog? &#x3D; Dog(name: &quot;보리&quot;)\nvar gildong: Person? &#x3D; Person(name: &quot;홍길동&quot;)\n\nbori?.owner &#x3D; gildong\ngildong?.pet &#x3D; bori\n&#x2F;&#x2F; 강한 참조 사이클 발생\n\n&#x2F;&#x2F; bori?.owner &#x3D; nil\n&#x2F;&#x2F; gildong?.pet &#x3D; nil\n&#x2F;&#x2F; 강한 참조 사이클을 해소하려면 서로의 참조를 끊어주어야 한다.\n\nbori &#x3D; nil\ngildong &#x3D; nil\n&#x2F;&#x2F; nil로 해제해주었지만, 강한 참조 사이클로 인해 메모리에서 해제되지 못함\n&#x2F;&#x2F; deinit에 들어있는 print문이 실행되지 않음<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"메모리-누수의-해결-방안\"><a href=\"#메모리-누수의-해결-방안\" class=\"headerlink\" title=\"메모리 누수의 해결 방안\"></a>메모리 누수의 해결 방안</h3><ol>\n<li>RC를 고려하며 참조 해제 순서를 주의하며 코드 작성<ul>\n<li>신경쓸 것이 많고 실수할 가능성이 큼</li>\n</ul>\n</li>\n<li>약한 참조(Weak Reference) 사용</li>\n<li>비소유 참조(Unowned Reference) 사용</li>\n</ol>\n<p>위 세 가지 방법 중에서 첫 번째 방법은 너무나 번거롭고 실수가 일어나기 쉬운 방법입니다. 그다지 좋은 방법이 아니라는 뜻이죠.</p>\n<p>그래서 그 대안으로 두 번째와 세 번째 방법이 있습니다.</p>\n<p>이 두 방법은 <strong>서로의 RC를 증가시키지 않으면서 참조</strong>한다는 공통적인 특징이 있습니다.</p>\n<h4 id=\"약한-참조-Weak-Reference\"><a href=\"#약한-참조-Weak-Reference\" class=\"headerlink\" title=\"약한 참조 (Weak Reference)\"></a>약한 참조 (Weak Reference)</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tvar name: String\n\tweak var owner: Person?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nclass Person &#123;\n\tvar name: String\n\tweak var pet: Dog?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nvar bori: Dog? &#x3D; Dog(name: &quot;보리&quot;)\nvar gildong: Person? &#x3D; Person(name: &quot;홍길동&quot;)\n\nbori?.owner &#x3D; gildong\ngildong?.pet &#x3D; bori\n\nbori &#x3D; nil &#x2F;&#x2F; 보리 메모리 해제\ngildong &#x3D; nil &#x2F;&#x2F; 홍길동 메모리 해제<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>위의 예시와 같은 예시이지만 서로의 참조 부분 앞에 <code>weak</code> 키워드를 넣어주어서 약한 참조를 하도록 해주었습니다.</p>\n<p>이 경우에는 서로의 RC를 증가시키지 않기 때문에, 각각을 <code>nil</code>로 만들어주면 RC가 0이 되어 메모리에서 해제됩니다.</p>\n<p>한 가지 알아두어야 할 점이 있습니다. <strong>약한 참조</strong>의 경우에는 참조하고 있던 인스턴스가 사라지면, 해당 속성을  <strong><code>nil</code> 값으로 자동으로 초기화</strong>합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">gildong &#x3D; nil\nprint(bori?.owner) &#x2F;&#x2F; nil<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>위의 예시에서 <code>gildong</code>에 <code>nil</code> 값을 주면, 이 <code>gildong</code>을 참조하고 있던 <code>bori</code>의 <code>owner</code>이라는 속성도 자동으로 <code>nil</code> 값으로 초기화된다는 뜻입니다.</p>\n<h4 id=\"비소유-참조-Unowned-Reference\"><a href=\"#비소유-참조-Unowned-Reference\" class=\"headerlink\" title=\"비소유 참조 (Unowned Reference)\"></a>비소유 참조 (Unowned Reference)</h4><p>비소유 참조도 약한 참조와 마찬가지로 참조 타입의 변수 선언 시에 앞에 <code>unowned</code>라는 키워드를 붙여서 선언할 수 있습니다.</p>\n<p>약한 참조와의 차이점은 참조하고 있던 인스턴스가 사라져도 해당 속성을 <code>nil</code>로 초기화하지 않는다는 점입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">gildong &#x3D; nil\nprint(bori?.owner) &#x2F;&#x2F; ERROR: 실제로 메모리에 값이 없음 (nil X)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>위 코드는 약한 참조때와는 다르게 에러가 발생하며 프로그램이 종료됩니다. 비소유 참조는 <code>nil</code>로 초기화하지 않기 때문에 실제로 해당 메모리에 아무런 값이 없기 때문입니다.</p>\n<p>그래서 비소유 참조는 직접 <code>nil</code> 값을 초기화해주어야 합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">gildong &#x3D; nil\nbori?.owner &#x3D; nil\nprint(bori?.owner) &#x2F;&#x2F; nil<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>그러면 약한 참조와 비소유 참조는 각각 어떤 상황에 사용해야 적절할까요?</p></blockquote>\n<p>두 참조 방식 모두 RC를 증가시키지 않는다는 공통점을 갖고 있습니다. 하지만 참조하던 값이 사라지면 <code>nil</code> 값으로 자동으로 초기화되는지 아닌지에 따라 역할이 구분됩니다.</p>\n<p>소유자에 비해 짧은 생명주기를 가진 인스턴스를 참조할 때는 약한 참조(<code>weak</code>)를 사용하면 좋습니다. 반대로 소유자보다 인스턴스의 생명주기가 더 길거나 같은 경우에는 비소유 참조(<code>unowned</code>)를 사용하면 좋습니다.</p>\n<p>한마디로 한 인스턴스가 참조하는 인스턴스보다 더 오래 메모리에 유지될 경우에는 <code>weak</code>을, 더 일찍 해제될 경우에는 <code>unowned</code>를 사용하면 좋습니다.</p>\n<p><code>unowned</code>의 속도가 더 빠르다고 하지만 그 차이가 미미하고, <code>unowned</code>는 고려해야할 사항이 하나 더 생기는 것이기 때문에 실제 사용시에는 <code>weak</code>만 사용해도 무방하다고 합니다.</p>\n<h2 id=\"클로저와-메모리-관리\"><a href=\"#클로저와-메모리-관리\" class=\"headerlink\" title=\"클로저와 메모리 관리\"></a>클로저와 메모리 관리</h2><p><a href=\"https://stansign.github.io/allenbootcamp/2022/11/01/Allen35.html#h-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC\"># 35)🧰 Swift - 클로저 (Closure)</a></p>\n<p>여기부터의 내용은 클로저에 대한 이해가 필요합니다.<br>이전 게시물을 확인해주세요!</p>\n<h3 id=\"캡처리스트의-형태\"><a href=\"#캡처리스트의-형태\" class=\"headerlink\" title=\"캡처리스트의 형태\"></a>캡처리스트의 형태</h3><ol>\n<li>파라미터가 없는 경우</li>\n</ol>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#123; [캡처리스트] in\n\tprint(&quot;프린트&quot;)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>파라미터가 있는 경우</li>\n</ol>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#123; [캡처리스트] (파라미터) -&gt; 리턴형 in\n\t print(&quot;프린트&quot;)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func calculate() -&gt; ((Int) -&gt; Int) &#123;\n\tvar sum &#x3D; 0\n\n\tfunc square(num: Int) -&gt; Int &#123;\n\t\tsum +&#x3D; (num * num)\n\t\treturn sum\n\t&#125;\n\n\treturn square\n&#125;\n\nvar squareFunc &#x3D; calculateFunc()\nsquareFunc(10) &#x2F;&#x2F; 100\nsquareFunc(20) &#x2F;&#x2F; 500\nsquareFunc(30) &#x2F;&#x2F; 1400<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>위 예시의 캡처 현상을 기억하시나요? </p>\n<p><code>squareFunc</code>에 저장한 <code>square</code> 함수를 실행하기 위해 필요한 <code>sum</code>이라는 변수는 <code>calculateFunc</code> 함수의 실행이 종료되면서 메모리에서 해제됩니다.</p>\n<p>이럴 때 발생하는 필연적인 에러를 방지하기 위해 <code>squareFunc</code>에 함수가 할당될 때 내부에 있지는 않지만 <strong>필요한 변수들의 값을 해당 시점에 캡처</strong>하여 <strong>함께 저장</strong>해두는 현상이였습니다.</p>\n<p>이런 이유로 <strong>클로저가 외부 변수를 사용하는 경우</strong>에는 <strong>무조건! 캡처가 발생</strong>됩니다.</p>\n<h3 id=\"클로저-실행-시-값-타입의-캡처\"><a href=\"#클로저-실행-시-값-타입의-캡처\" class=\"headerlink\" title=\"클로저 실행 시 값 타입의 캡처\"></a>클로저 실행 시 값 타입의 캡처</h3><h4 id=\"캡처-리스트를-사용하지-않은-경우\"><a href=\"#캡처-리스트를-사용하지-않은-경우\" class=\"headerlink\" title=\"캡처 리스트를 사용하지 않은 경우\"></a>캡처 리스트를 사용하지 않은 경우</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var num &#x3D; 1\nlet valueCaptureClosure &#x3D; &#123;\n\tprint(&quot;밸류 값 출력(캡처): \\(num)&quot;)\n&#125;\n\nnum &#x3D; 7\nvalueCaptureClosure() &#x2F;&#x2F; 7\n\nnum &#x3D; 1\nvalueCaptureClosure() &#x2F;&#x2F; 1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>이 예시의 <code>valueCaptureClosure</code>는 <strong>캡처 리스트를 사용하지 않은</strong> 예시입니다.</p>\n<p>외부에 있는 <code>num</code> 변수를 사용하기 위해 변수를 캡처 해야하는데, <strong>캡처 리스트를 사용하지 않은 경우</strong>에는 힙 영역의 클로저는 <strong>변수의 주소를 캡처</strong>합니다.</p>\n<p>그래서 <code>num</code> 변수의 값을 바꾼 후에 <code>valueCaptureClosure</code>를 실행시키면, 바뀐 변수의 값을 받아올 수 있는 것입니다.</p>\n<h4 id=\"캡처-리스트를-사용한-경우\"><a href=\"#캡처-리스트를-사용한-경우\" class=\"headerlink\" title=\"캡처 리스트를 사용한 경우\"></a>캡처 리스트를 사용한 경우</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var num &#x3D; 1\nlet valueCaptureListClosure &#x3D; &#123; [num] in\n\tprint(&quot;밸류 값 출력(캡처리스트): \\(num)&quot;)\n&#125;\n\nnum &#x3D; 7\nvalueCaptureListClosure() &#x2F;&#x2F; 1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>이번 예시의 <code>valueCaptureListClosure</code>는 <strong>캡처 리스트를 사용한</strong> 예시입니다.</p>\n<p>마찬가지로 외부에 있는 <code>num</code> 변수를 캡처하는데, <strong>캡처 리스트를 사용</strong>했기 때문에 주소가 아니라 <strong>값 자체를 힙 영역에 함께 복사하여 캡처</strong>합니다.</p>\n<p>따라서 <code>num</code> 변수의 값을 바꾸더라도 바뀐 값이 적용되지 않고 힙 영역에 저장된 값을 계속 사용하게 됩니다.</p>\n<h3 id=\"클로저-실행-시-참조-타입의-캡처\"><a href=\"#클로저-실행-시-참조-타입의-캡처\" class=\"headerlink\" title=\"클로저 실행 시 참조 타입의 캡처\"></a>클로저 실행 시 참조 타입의 캡처</h3><p>지금까지의 예시는 값 타입의 변수들을 캡처할 때 발생하는 일들이였습니다.</p>\n<p>그렇다면 <code>class</code>나 <code>closure</code> 같은 참조 타입을 캡처할 때는 어떤 일이 발생할까요?</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class SomeClass &#123;\n\tvar num &#x3D; 0\n&#125;\n\nvar x &#x3D; SomeClass()\nvar y &#x3D; SomeClass()\n\nprint(x.num, y.num) &#x2F;&#x2F; 0, 0\n\nlet refTypeCapture &#x3D; &#123; [x] in\n\tprint(&quot;참조 출력 값(캡처리스트): &quot;, x.num, y.num)\n&#125;\n\nx.num &#x3D; 1\ny.num &#x3D; 1\n\nprint(x.num, y.num) &#x2F;&#x2F; 1, 1\nrefTypeCapture() &#x2F;&#x2F; 1, 1\nprint(x.num, y.num) &#x2F;&#x2F; 1, 1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>refTypeCapture</code> 부분을 보면 <code>[x]</code>와 같이 <code>x</code> 클래스만 캡처리스트를 통해 받아온 것을 확인할 수 있습니다.</p>\n<p>두 값을 바꾼 후에 출력을 했을 때 값 타입때와는 다르게 이번에는 두 값 모두 바뀐 상태로 출력되었습니다.</p>\n<p>이런 일이 일어난 이유는 참조 타입임을 생각해보면 알 수 있습니다.</p>\n<p>먼저 캡처 리스트를 통해 복사해서 사용한 <code>x</code> 클래스의 경우에는 값 타입때와 같은 이유로 <code>x</code> 인스턴스의 주소값을 그대로 복사하여 저장했기 때문에 바로 힙 영역의 인스턴스로 찾아가 값이 바뀌었습니다.</p>\n<p>문제는 <code>y</code> 클래스인데, 클래스는 <strong>참조 타입</strong>이기 때문에 힙 영역의 클로저에서 <strong>스택 영역의 원본의 주소</strong>로 찾아가게 되면, 그곳에는 또 <strong>힙 영역에 할당되어 있는 원본 <code>y</code> 인스턴스의 주소</strong>가 담겨있습니다.</p>\n<ul>\n<li>힙 영역의 클로저(<code>y</code> 변수의 주소) ➡️ 스택 영역의 변수 (<code>y</code>의 주소) ➡️ 힙 영역의 인스턴스</li>\n</ul>\n<p>이렇게 결국 원본의 주소에 찾아가게 되기 때문에 값의 변경이 적용될 수 있었던 것입니다.</p>\n<h3 id=\"강한-참조-사이클-문제의-해결\"><a href=\"#강한-참조-사이클-문제의-해결\" class=\"headerlink\" title=\"강한 참조 사이클 문제의 해결\"></a>강한 참조 사이클 문제의 해결</h3><p>자 그런데 참조하면 고려해야할 점이 하나 있습니다.<br>바로 메모리의 천적 <strong>강한 참조</strong>입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var z &#x3D; SomeClass()\nlet refTypeCapture &#x3D; &#123; [z] in\n\tprint(&quot;참조 출력값(캡처리스트): &quot;, z.num)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>참조 타입을 캡처하면 주소를 갖게 되고 인스턴스의 RC를 하나 올리게 됩니다. 이 말은 곧 캡처된 인스턴스가 다시 클로저를 참조하게 되면 강한 참조가 발생한다는 의미가 될 것입니다.</p>\n<p>그래서 캡처리스트에도 약한 참조(<code>weak</code>)와 비소유 참조(<code>unowned</code>)를 사용할 수 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var z &#x3D; SomeClass()\nlet refTypeCapture &#x3D; &#123; [weak z] in\n\tprint(&quot;참조 출력값(캡처리스트):&quot;, z?.num)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>약한 참조와 비소유 참조의 경우 , 할당이 해제되면 값이 사라질 수 있기 때문에 <code>Optional</code>로 결과가 나왔었죠. 여기서도 마찬가지인 점 유의합시다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>강한 참조..? 오히려 좋아</p></blockquote>\n<p>그런데 강한 참조가 꼭 나쁜 것이냐 하면 그건 또 아닙니다. 강한 참조의 특징은 RC를 증가시킨다는 것이고, RC가 증가하면 메모리에서 해제가 되지 않겠죠.</p>\n<p>정말 꼭 필요한 인스턴스라면 강한 참조를 사용해서 오히려 RC를 일부러 증가시켜 외부 요인들로 인해서 메모리 해제가 되지 않도록 방지하는 역할도 할 수 있습니다.</p>\n<p>나쁜 기능을 쓰라고 만들어 뒀을리는 없으니 코딩을 할 때 생각하면서 작성해야겠습니다.</p>\n<h4 id=\"캡처리스트-바인딩\"><a href=\"#캡처리스트-바인딩\" class=\"headerlink\" title=\"캡처리스트 바인딩\"></a>캡처리스트 바인딩</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var s &#x3D; SomeClass()\nlet captureBinding &#x3D; &#123; [weak z &#x3D; s] in\n\t&#x2F;&#x2F; ...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"일반적인-클로저의-사용\"><a href=\"#일반적인-클로저의-사용\" class=\"headerlink\" title=\"일반적인 클로저의 사용\"></a>일반적인 클로저의 사용</h2><h3 id=\"객체-내에서의-사용\"><a href=\"#객체-내에서의-사용\" class=\"headerlink\" title=\"객체 내에서의 사용\"></a>객체 내에서의 사용</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tvar name &#x3D; &quot;초코&quot;\n\n\tfunc doSomething() &#123;\n\t\t&#x2F;&#x2F; 비동기 동작 클로저\n\t\tDispatchQueue.global().async &#123;\n\t\t\tprint(&quot;나의 이름은 \\(self.name)입니다.&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\nvar choco &#x3D; Dog()\nchoco.doSomething()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>실제로 앱을 만들 때는 객체 안에서 클로저를 사용하는 경우가 거의 대부분입니다. <code>UIView</code>, <code>UIViewController</code> 등의 컴포넌트들도 전부 객체이기 때문이죠.</p>\n<p>그런데 클로저 안에서 객체의 속성이나 메서드에 접근하기 위해서는 반드시 <code>self</code> 키워드를 붙여줘야 합니다.</p>\n<p>클로저의 scope 안에 있는 속성&#x2F;메서드인지 외부인 객체에 있는 속성&#x2F;메서드인지 알 수가 없겠죠.</p>\n<p>이 <code>self</code>를 붙여주는 방법이 두가지 있습니다.</p>\n<p>첫 번째 방법은 위 예시처럼 <code>self.name</code>과 같은 형태로 속성이나 메서드앞에 붙여주는 방법입니다.</p>\n<p>두 번째 방법은 캡처 리스트에서 사용해주는 방법입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func doSomething() &#123;\n\tDispatchQueue.global().async &#123; [self] in\n\t\tprint(&quot;나의 이름은 \\(name)입니다.&quot;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>이 두 번째 방법은 약한 참조와 함께 사용하는 형태로 굉장히 많이 쓰이고 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func doSomething() &#123;\n\tDispatchQueue.global().async &#123; [weak self] in\n\t\tprint(&quot;나의 이름은 \\(self?.name)입니다.&quot;)\n\t&#125;\n&#125;\n\nfunc doSomething() &#123;\n\tDispatchQueue.global().async &#123; [weak self] in\n\t\tguard let weakSelf &#x3D; self else &#123; return &#125;\n\t\tprint(&quot;나의 이름은 \\(weakSelf.name)입니다.&quot;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"메모리-누수의-사례\"><a href=\"#메모리-누수의-사례\" class=\"headerlink\" title=\"메모리 누수의 사례\"></a>메모리 누수의 사례</h3><p>아무래도 개념만 보면 어떤 때에 강한 참조 순환이 생기는건지 가늠이 안되죠.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tvar name &#x3D; &quot;초코&quot;\n\tvar run: (() -&gt; Void)?\n\n\tfunc walk() &#123;\n\t\tprint(&quot;\\(self.name)가 걷는다.&quot;)\n\t&#125;\n\n\tfunc saveClosure() &#123;\n\t\trun &#x3D; &#123;\n\t\t\tprint(&quot;\\(self.name)가 뛴다.&quot;)\n\t\t&#125;\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(self.name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nfunc doSomething() &#123;\n\tlet choco: Dog? &#x3D; Dog()\n\tchoco?.saveClosure() &#x2F;&#x2F; 강한 참조 사이클\n&#125;\n\ndoSomething()\n&#x2F;&#x2F; doSomething()이 종료되어도 choco가 참조하는 run 클로저와 run 클로저가 self.name으로 참조하는 choco 사이에서 강한 참조 순환 발생<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"View-Controller에서의-예시\"><a href=\"#View-Controller에서의-예시\" class=\"headerlink\" title=\"View Controller에서의 예시\"></a>View Controller에서의 예시</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class ViewController: UIViewController &#123;\n\tvar name: String &#x3D; &quot;뷰 컨트롤러&quot;\n\n\tfunc doSomething() &#123;\n\t\tDispatchQueue.global().async &#123;\n\t\t\tsleep(3)\n\t\t\tprint(&quot;글로벌 큐에서 출력: \\(self.name)&quot;)\n\t\t&#125;\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nfunc localScopeFunction() &#123;\n\tlet vc &#x3D; ViewController()\n\tvc.doSomething()\n&#125;\n\nlocalScopeFunction()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>(3초후)<br>글로벌 큐에서 출력: 뷰 컨트롤러<br>뷰 컨트롤러 메모리 해제</p></blockquote>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class ViewController: UIViewController &#123;\n\tvar name: String &#x3D; &quot;뷰 컨트롤러&quot;\n\n\tfunc doSomething() &#123;\n\t\tDispatchQueue.global().async &#123; [weak self] in\n\t\t\tsleep(3)\n\t\t\tprint(&quot;글로벌 큐에서 출력: \\(self.name)&quot;)\n\t\t&#125;\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nfunc localScopeFunction() &#123;\n\tlet vc &#x3D; ViewController()\n\tvc.doSomething()\n&#125;\n\nlocalScopeFunction()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>(3초후)<br>뷰 컨트롤러 메모리 해제<br>글로벌 큐에서 출력: nil</p></blockquote>\n<p><code>sleep(3)</code>이 실행되기 전에 약한 참조(<code>weak</code>)를 받은 <code>vc</code> 인스턴스가 메모리에서 해제되어 <code>nil</code>값이 출력된다.</p>\n","text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) ARC (Automatic Reference Counting)스위프트의 메모리 관리 모델값 형식과 참조 형식메모리 관리에 대해 공부하기 전에 메모리 관리가 어떤 때에 필요한 지 ...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ARC-Automatic-Reference-Counting\"><span class=\"toc-text\">ARC (Automatic Reference Counting)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%AA%A8%EB%8D%B8\"><span class=\"toc-text\">스위프트의 메모리 관리 모델</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EA%B0%92-%ED%98%95%EC%8B%9D%EA%B3%BC-%EC%B0%B8%EC%A1%B0-%ED%98%95%EC%8B%9D\"><span class=\"toc-text\">값 형식과 참조 형식</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EA%B0%92-%ED%98%95%EC%8B%9D\"><span class=\"toc-text\">값 형식</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%B0%B8%EC%A1%B0-%ED%98%95%EC%8B%9D\"><span class=\"toc-text\">참조 형식</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EA%B5%AC%EC%A1%B0\"><span class=\"toc-text\">메모리의 구조</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Java%EC%99%80-Obj-C-Swift%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%AA%A8%EB%8D%B8\"><span class=\"toc-text\">Java와 Obj-C, Swift의 메모리 관리 모델</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Java%EC%9D%98-Garbage-Collector\"><span class=\"toc-text\">Java의 Garbage Collector</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Swift%EC%9D%98-Reference-Counting\"><span class=\"toc-text\">Swift의 Reference Counting</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%A3%BC%EC%9D%98\"><span class=\"toc-text\">주의</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MRC-Manual-Reference-Counting\"><span class=\"toc-text\">MRC (Manual Reference Counting)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EA%B0%95%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EC%82%AC%EC%9D%B4%ED%81%B4%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98\"><span class=\"toc-text\">강한 참조 사이클과 메모리 누수</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88\"><span class=\"toc-text\">메모리 누수의 해결 방안</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%95%BD%ED%95%9C-%EC%B0%B8%EC%A1%B0-Weak-Reference\"><span class=\"toc-text\">약한 참조 (Weak Reference)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B9%84%EC%86%8C%EC%9C%A0-%EC%B0%B8%EC%A1%B0-Unowned-Reference\"><span class=\"toc-text\">비소유 참조 (Unowned Reference)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\"><span class=\"toc-text\">클로저와 메모리 관리</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%BA%A1%EC%B2%98%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%98%95%ED%83%9C\"><span class=\"toc-text\">캡처리스트의 형태</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%8B%A4%ED%96%89-%EC%8B%9C-%EA%B0%92-%ED%83%80%EC%9E%85%EC%9D%98-%EC%BA%A1%EC%B2%98\"><span class=\"toc-text\">클로저 실행 시 값 타입의 캡처</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%BA%A1%EC%B2%98-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0\"><span class=\"toc-text\">캡처 리스트를 사용하지 않은 경우</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%BA%A1%EC%B2%98-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EA%B2%BD%EC%9A%B0\"><span class=\"toc-text\">캡처 리스트를 사용한 경우</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%8B%A4%ED%96%89-%EC%8B%9C-%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85%EC%9D%98-%EC%BA%A1%EC%B2%98\"><span class=\"toc-text\">클로저 실행 시 참조 타입의 캡처</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EA%B0%95%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%AC%B8%EC%A0%9C%EC%9D%98-%ED%95%B4%EA%B2%B0\"><span class=\"toc-text\">강한 참조 사이클 문제의 해결</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%BA%A1%EC%B2%98%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\"><span class=\"toc-text\">캡처리스트 바인딩</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%9D%98-%EC%82%AC%EC%9A%A9\"><span class=\"toc-text\">일반적인 클로저의 사용</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EA%B0%9D%EC%B2%B4-%EB%82%B4%EC%97%90%EC%84%9C%EC%9D%98-%EC%82%AC%EC%9A%A9\"><span class=\"toc-text\">객체 내에서의 사용</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-%EC%82%AC%EB%A1%80\"><span class=\"toc-text\">메모리 누수의 사례</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#View-Controller%EC%97%90%EC%84%9C%EC%9D%98-%EC%98%88%EC%8B%9C\"><span class=\"toc-text\">View Controller에서의 예시</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"14)🍎 Swift - Rx 없이 Reactive Binding 해보기","uid":"01b2dffc69fa4db38318456db0dbef20","slug":"Swift/2022-11-20-Swift14","date":"2022-11-19T15:00:00.000Z","updated":"2023-03-31T10:42:38.383Z","comments":true,"path":"api/articles/Swift/2022-11-20-Swift14.json","keywords":null,"cover":null,"text":"Rx 없이 View ➡️ ViewModel Binding하기Rx라는 놈 공부할 땐 어려웠는데..한 번 써보니까 없이 기능 구현을 할 때 갈증이 계속해서 일어나는 현상을 겪고 있습니다. 하지만 라이브러리에 의존하는 것은 좋지 않으니까 Rx 없이 데이터 바...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Swift","slug":"Swift","count":29,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"36)🧰 Swift - 고차함수 (High-Order Function)","uid":"e87344a11426ba57cb8d3c641a799f55","slug":"Allen/2022-11-04-Allen36","date":"2022-11-03T15:00:00.000Z","updated":"2023-03-31T10:34:54.018Z","comments":true,"path":"api/articles/Allen/2022-11-04-Allen36.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 고차 함수 함수를 파라미터로 사용하거나, 함수 실행의 결과를 함수로 리턴하는 함수 mapmap 함수는 기존 배열등의 컬렉션을 새롭게 매핑해서 새로운 배열을 리턴하는 함수입니다. ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}