{"title":"32)🧰 Swift - 프로토콜 (Protocol)","uid":"5b935310e5ab86264b239e5fd2bbef6c","slug":"Allen/2022-10-11-Allen32","date":"2022-10-10T15:00:00.000Z","updated":"2023-03-31T10:34:14.305Z","comments":true,"path":"api/articles/Allen/2022-10-11-Allen32.json","keywords":null,"cover":null,"content":"<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8\">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>\n<h1 id=\"프로토콜-protocol\"><a href=\"#프로토콜-protocol\" class=\"headerlink\" title=\"프로토콜 (protocol)\"></a>프로토콜 (protocol)</h1><h2 id=\"프로토콜의-개념\"><a href=\"#프로토콜의-개념\" class=\"headerlink\" title=\"프로토콜의 개념\"></a>프로토콜의 개념</h2><h3 id=\"프로토콜의-필요성\"><a href=\"#프로토콜의-필요성\" class=\"headerlink\" title=\"프로토콜의 필요성\"></a>프로토콜의 필요성</h3><ul>\n<li>클래스 상속의 단점<ol>\n<li><strong>하나</strong>의 클래스만 상속 가능 (다중 상속 불가)</li>\n<li>상위 클래스의 <strong>메모리 구조</strong>를 따라감 (필요하지 않은 저장속성&#x2F;메서드도 상속)</li>\n<li><strong>클래스</strong>(참조 타입)에서만 가능</li>\n</ol>\n</li>\n<li>프로토콜의 특징<ol>\n<li>클래스에서 벗어난 <strong>별도</strong>의 규칙</li>\n<li><strong>다중 상속</strong> 가능</li>\n<li>필요한 경우 어떤 클래스&#x2F;구조체건 <strong>원할 때 상속</strong> 가능</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#x2F;&#x2F; 클래스 상속의 단점\n\nclass Bird &#123;\n\tvar isFemale &#x3D; true\n\n\tfunc layEgg() &#123;\n\t\tif isFemale &#123;\n\t\t\tprint(&quot;새가 알을 낳는다.&quot;)\n\t\t&#125;\n\t&#125;\n\n\tfunc fly() &#123;\n\t\tprint(&quot;새가 하늘로 날아간다.&quot;)\n\t&#125;\n&#125;\n\nclass Eagle: Bird &#123;\n\tfunc soar() &#123;\n\t\tprint(&quot;공중으로 치솟아 난다.&quot;)\n\t&#125;\n&#125;\n\nclass Penguin: Bird &#123;\n\n\t&#x2F;&#x2F; Penguin은 Bird를 상속 받았기 때문에\n\t&#x2F;&#x2F; 자동으로 fly() 메서드를 상속 받는다.\n\t&#x2F;&#x2F; 펭귄은 날지 못하는데...?\n\t&#x2F;&#x2F; func fly()\n\n\tfunc swim() &#123;\n\t\tprint(&quot;헤엄친다.&quot;)\n\t&#125;\n&#125;\n\nclass Airplane: Bird &#123;\n\n\t&#x2F;&#x2F; Airplane 또한 Bird를 상속받았다.\n\t&#x2F;&#x2F; layEgg() 메서드를 상속 받았다.\n\t&#x2F;&#x2F; 비행기가 알을 낳아?\n\t&#x2F;&#x2F; func layEgg()\n\n\toverride func fly() &#123;\n\t\tprint(&quot;비행기가 엔진을 사용하여 날아간다.&quot;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"잠깐\"><a href=\"#잠깐\" class=\"headerlink\" title=\"잠깐!\"></a>잠깐!</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>그냥 상속받지 말고 새로 만들면 안돼요?</p></blockquote>\n<p>되기는 하는데, 프로젝트가 커지거나 실무에 들어가면 예제처럼 클래스가 메서드 한두개만 갖지는 않습니다.<br>이미 구현되어 있는 그 많은 메서드들을 재사용하기 위해서 클래스를 새로 만들고 복붙을 한다는 건 너무나 성가시고 낭비도 심합니다.<br>현실적으로 상속을 하는게 맞기 때문에 클래스의 이러한 속성은 단점으로 작용할 때가 꽤 많습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>그러면 fly() 메서드 같이 몇몇 하위 클래스들에겐 필요 없는 메서드들을 분리해서 상속을 하지 않아도 사용할 수는 없나요?</p></blockquote>\n<p>그것이 바로 오늘의 주인공 프로토콜이 하는 일입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#x2F;&#x2F; 프로토콜의 형태\n\nprotocol CanFly &#123; &#x2F;&#x2F; 프로토콜은 구체적인 구현은 하지 않는다.\n\tfunc fly()\n&#125;\n\nstruct Penguin: CanFly &#123; &#x2F;&#x2F; 구조체도 채택 가능\n\tfunc fly() &#123;\n\t\tprint(&quot;날아갑니다.&quot;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>프로토콜의 경우 채택을 했는데 포로토콜의 모든 메서드를 구현하지 않으면, 에러를 발생시킵니다. 채택한 프로토콜의 <strong>모든 메서드는 구현</strong>되어야 합니다!</p>\n<p>한가지 특징이 더 있습니다.<br>프로토콜을 타입처럼 사용할 수 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">struct FlyingMuseum &#123;\n\tfunc flyingDemo(flyingObject: CanFly) &#123;\n\t\tflyingObject.fly()\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>위 예시에서  <code>CanFly</code>의 의미는 <code>CanFly</code> 프로토콜을 채택한 인스턴스를 받는다는 의미입니다.</p>\n<h2 id=\"프로토콜-문법\"><a href=\"#프로토콜-문법\" class=\"headerlink\" title=\"프로토콜 문법\"></a>프로토콜 문법</h2><ul>\n<li>프로토콜에서는 구체적인 구현은 하지 않고 최소 요구사항만을 정의한다.</li>\n<li>클래스의 상위 클래스가 있는 경우, 상위 클래스를 먼저 표기한다.</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol MyProtocol &#123;\n\tfunc doSomething() -&gt; Int\n&#125;\n\nclass MyClass &#123; &#125;\n\nclass MySecondClass: MyClass, MyProtocol &#123;\n\tfunc doSomething() -&gt; Int &#123;\n\t\treturn 7\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"속성-요구사항\"><a href=\"#속성-요구사항\" class=\"headerlink\" title=\"속성 요구사항\"></a>속성 요구사항</h3><ul>\n<li><code>var</code>로만 선언 가능</li>\n<li><code>get</code>, <code>set</code> 키워드를 통해서 읽기&#x2F;쓰기 가능 여부 설정</li>\n<li>저장속성&#x2F;계산속성 모두 가능</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol RemoteMouse &#123;\n\tvar id: String &#123; get &#125; &#x2F;&#x2F; let (get만 가능)\n\tvar name: String &#123; get set &#125;\n\n\t&#x2F;&#x2F; 타입 저장 속성: static\n\t&#x2F;&#x2F; 타입 계산 속성: class\n\tstatic var type: String &#123; get set &#125;\n&#125;\n\nstruct TV: RemoteMouse &#123;\n\tlet id: String &#x3D; 456\n\tvar name: String &#x3D; &quot;Samsung TV&quot;\n\t\n\tstatic var type: String &#x3D; &quot;Remote Control&quot; &#x2F;&#x2F; 재정의 불가능\n\tclass var type: String &#123; &#x2F;&#x2F; 재정의 가능 (클래스에서 채택 시)\n\t\tget &#123; &quot;Remote Control&quot; &#125;\n\t\tset &#123; &#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"메서드-요구사항\"><a href=\"#메서드-요구사항\" class=\"headerlink\" title=\"메서드 요구사항\"></a>메서드 요구사항</h3><ul>\n<li>메서드의 헤드 부분만 요구사항으로 정의</li>\n<li><code>mutating</code>: 구조체에서 저장 속성 변경 시 필요한 키워드</li>\n<li>타입 메서드로 구현 시에는 <code>static</code>만 붙여주면 됨<ul>\n<li>채택하는 쪽에서 <code>static</code>, <code>class</code> 선택</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"생성자-요구사항\"><a href=\"#생성자-요구사항\" class=\"headerlink\" title=\"생성자 요구사항\"></a>생성자 요구사항</h3><ul>\n<li>클래스는 상속을 고려해야 하기 때문에 채택하는 쪽에서 <code>required</code>를 붙여줘야 한다.<ul>\n<li>구조체는 상속이 없기 때문에 <code>required</code> 키워드가 필요하지 않다!</li>\n</ul>\n</li>\n<li>혹은  <code>final</code> 키워드로 상속을 막으면 필수생성자로 구현하지 않아도 된다.</li>\n<li>클래스일 경우 편의생성자(<code>convenience</code>)로 구현해도 된다.</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol SomeProtocol &#123;\n\tinit(num: Int)\n&#125;\n\nclass SomeClass: SomeProtocol &#123;\n\trequired init(num: Int) &#123;\n\t&#125;\n&#125;\n\nclass SomeClass2: SomeClass &#123;\n\t&#x2F;&#x2F; 다른 생성자 구현하지 않을 시 필수생성자 자동 상속\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol AProtocol &#123;\n\tinit()\n&#125;\n\nclass ASuperClass &#123;\n\tinit() &#123;\n\t\t\n\t&#125;\n&#125;\n\nclass ASubClass: ASuperClass, Aprotocol &#123;\n\t&#x2F;&#x2F; 상속으로 인한 재정의 키워드 (override)\n\t&#x2F;&#x2F; 프로토콜 채택으로 인한 필수 키워드 (required)\n\trequired override init() &#123;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"실패가능-생성자일-경우\"><a href=\"#실패가능-생성자일-경우\" class=\"headerlink\" title=\"실패가능 생성자일 경우\"></a>실패가능 생성자일 경우</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol AProtocol &#123;\n\tinit?(num: Int)\n&#125;\n\nstruct AStruct: AProtocol &#123;\n\t&#x2F;&#x2F; 실패가능, 실패불가능, 일반 모두 가능\n\t&#x2F;&#x2F; 범위의 개념!\n\tinit?(num: Int) &#123; &#125;\n\n\tinit(num: Int) &#123; &#125;\n\n\tinit!(num: Int) &#123; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"서브스크립트-요구사항\"><a href=\"#서브스크립트-요구사항\" class=\"headerlink\" title=\"서브스크립트 요구사항\"></a>서브스크립트 요구사항</h3><ul>\n<li><code>get</code>, <code>set</code>을 사용하여 읽기&#x2F;쓰기 여부 설정</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol DataList &#123;\n\tsubscript(idx: Int) -&gt; Int &#123; get &#125;\n&#125;\n\nstruct DataStructure: DataList &#123;\n\tsubscript(idx: Int) -&gt; &#123;\n\t\tget &#123;\n\t\t\treturn 0\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"타입으로써의-프로토콜\"><a href=\"#타입으로써의-프로토콜\" class=\"headerlink\" title=\"타입으로써의 프로토콜\"></a>타입으로써의 프로토콜</h2><ul>\n<li>프로토콜은 타입이다…!<ul>\n<li>프로토콜을 변수에 할당할 수 있다.</li>\n<li>함수를 호출할 때, 프로토콜을 파라미터로 전달할 수 있다.</li>\n<li>함수에서 프로토콜을 반환할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol Remote &#123;\n\tfunc turnOn()\n\tfunc turnOff()\n&#125;\n\nclass TV: Remote &#123;\n\tfunc turnOn() &#123;\n\t\tprint(&quot;TV 켜기&quot;)\n\t&#125;\n\n\tfunc turnOff() &#123;\n\t\tprint(&quot;TV 끄기&quot;)\n\t&#125;\n\n\tfunc changeChannel() &#123;\n\t\tprint(&quot;채널 바꾸기&quot;)\n\t&#125;\n&#125;\n\nclass SetTopBox: Remote &#123;\n\tfunc turnOn() &#123; &#125;\n\tfunc turnOff() &#123; &#125;\n\tfunc doNetflix() &#123; &#125;\n&#125;\n\nlet tv: Remote &#x3D; TV()\ntv.turnOn() &#x2F;&#x2F; &quot;TV 켜기&quot;\ntv.turnOff() &#x2F;&#x2F; &quot;TV 끄기&quot;\ntv.changeChannel() &#x2F;&#x2F; Error\nlet sbox: Remote &#x3D; SetTopBox()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"타입으로써의-장점\"><a href=\"#타입으로써의-장점\" class=\"headerlink\" title=\"타입으로써의 장점\"></a>타입으로써의 장점</h3><h4 id=\"같은-프로토콜끼리-묶어서-취급\"><a href=\"#같은-프로토콜끼리-묶어서-취급\" class=\"headerlink\" title=\"같은 프로토콜끼리 묶어서 취급\"></a>같은 프로토콜끼리 묶어서 취급</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let electronics: [Remote] &#x3D; [tv, sbox]\nfor item in electronics &#123;\n\titem.turnOn()\n&#125;\n\nfunc turnOnElectronics(item: Remote) &#123;\n\titem.turnOff()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"프로토콜-준수성-검사\"><a href=\"#프로토콜-준수성-검사\" class=\"headerlink\" title=\"프로토콜 준수성 검사\"></a>프로토콜 준수성 검사</h4><ul>\n<li><code>is</code>: 특정 타입이 프로토콜을 채택하고 있는지 검사</li>\n<li><code>as</code>: 타입캐스팅<ul>\n<li>특정 인스턴스를 프로토콜로 변환, 혹은 프로토콜을 인스턴스 실제 형식으로 캐스팅</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let newBox &#x3D; sbox as Remote\n\nlet sbox2 &#x3D; electronic[1] as? SetTopBox\nsbox2?.doNetflix()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"프로토콜의-상속\"><a href=\"#프로토콜의-상속\" class=\"headerlink\" title=\"프로토콜의 상속\"></a>프로토콜의 상속</h2><ul>\n<li>프로토콜도 <strong>상속</strong>이 가능하다.<ul>\n<li>프로토콜을 채택할 때 적용됐던 <strong>다중상속</strong>도 지원한다.</li>\n</ul>\n</li>\n<li>단순하게 요구사항들의 나열들이라고 생각하면 된다.</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol Remote &#123;\n\tfunc turnOn()\n\tfunc turnOff()\n&#125;\n\nprotocol AirconRemote &#123;\n\tfunc up()\n\tfunc down()\n&#125;\n\nprotocol SuperRemoteProtocol: Remote, AirconRemote &#123;\n\tfunc remote()\n&#125;\n\nclass HomePod: SuperRemoteProtocol &#123;\n\tfunc turnOn()\n\tfunc turnOff()\n\tfunc up()\n\tfunc down()\n\tfunc remote()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"클래스-전용-프로토콜-AnyObject\"><a href=\"#클래스-전용-프로토콜-AnyObject\" class=\"headerlink\" title=\"클래스 전용 프로토콜 (AnyObject)\"></a>클래스 전용 프로토콜 (AnyObject)</h3><ul>\n<li><code>AnyObject</code>도 프로토콜 중의 하나이다.<ul>\n<li>해당 프로토콜은 <strong>클래스만 채택</strong>할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol SomeProtocol: AnyObject &#123;\n\t&#x2F;&#x2F; ...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"프로토콜의-합성\"><a href=\"#프로토콜의-합성\" class=\"headerlink\" title=\"프로토콜의 합성\"></a>프로토콜의 합성</h3><ul>\n<li>하나의 타입으로 <strong>여러가지 프로토콜을 채택</strong>하는 것</li>\n<li><code>[Protocol] &amp; [Protocol]</code></li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol Named &#123;\n\tvar name: String &#123; get &#125;\n&#125;\n\nprotocol Aged &#123;\n\tvar age: Int &#123; get &#125;\n&#125;\n\nstruct Person: Named, Aged &#123;\n\tvar name: String\n\tvar age: Int\n&#125;\n\nfunc wishHappyBirthday(to celebrator: Named &amp; Aged) &#123;\n\tprint(&quot;HBD, \\(celebrator.name), you&#39;re now \\(celebrator.age) years old.&quot;)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"선택적-요구사항-Optional-Protocol-Requirements\"><a href=\"#선택적-요구사항-Optional-Protocol-Requirements\" class=\"headerlink\" title=\"선택적 요구사항 (Optional Protocol Requirements)\"></a>선택적 요구사항 (Optional Protocol Requirements)</h2><h3 id=\"어트리뷰트-Attribute\"><a href=\"#어트리뷰트-Attribute\" class=\"headerlink\" title=\"어트리뷰트 (Attribute)\"></a>어트리뷰트 (Attribute)</h3><ul>\n<li><code>@objc</code>: Swift로 작성한 코드를 Obj-C 코드로도 사용할 수 있도록 해주는 어트리뷰트</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">@objc protocol Remote &#123;\n\t@objc optional var isOn: Bool &#123; get set &#125;\n\tfunc turnOn()\n\tfunc turnOff()\n\t@objc optional func doNetflix()\n&#125;\n\nclass TV: Remote &#123; &#x2F;&#x2F; No Error\n\tfunc turnOn() &#123; &#125;\n\tfunc turnOff() &#123; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"프로토콜의-확장\"><a href=\"#프로토콜의-확장\" class=\"headerlink\" title=\"프로토콜의 확장\"></a>프로토콜의 확장</h2><ul>\n<li>프로토콜의 확장을 통해 <strong>기본(default) 내용 구현</strong>이 가능하다.</li>\n<li>기본(default) 구현이기 때문에 채택한 쪽에서 내용을 구현하면 해당 내용이 우선 적용된다. <ul>\n<li>데이터 영역에 만들어진 테이블에 찾아간다.(<strong>Witness Table</strong>)</li>\n</ul>\n</li>\n<li><code>extension</code>으로 확장된 프로토콜에서 요구 사항으로 정의되지 않은 메서드를 구현하면 타입에 따라 구현된다. <ul>\n<li>코드 영역에 있는 코드 주소에 직접 찾아간다.(<strong>Direct Dispatch</strong>)</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol Remote &#123;\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D; Witness Table &#x3D;&#x3D;&#x3D;\n\tfunc turnOn()\n\tfunc turnOff()\n&#125;\n\nextension Remote &#123;\n\t&#x2F;&#x2F; 요구사항에 선언되어 있기 때문에 채택 시에 구현되지 않으면\n\t&#x2F;&#x2F; 해당 기본 구현 내용을 실행한다.\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D; Witness Table &#x3D;&#x3D;&#x3D;\n\tfunc turnOn() &#123; print(&quot;리모컨 켜기&quot;) &#125;\n\tfunc turnOff() &#123; print(&quot;리모컨 끄기&quot;) &#125;\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\t&#x2F;&#x2F; 요구사항에 선언되어 있지 않기 때문에\n\t&#x2F;&#x2F; 타입에 따라 구현되거나 되지 않는다.\n\t&#x2F;&#x2F; 테이블에 추가되지 않음 (호출 시 직접적으로 주소로 찾아가 실행)\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D; Direct Dispatch &#x3D;&#x3D;&#x3D;\n\tfunc doAnotherAction() &#123;\n\t\tprint(&quot;또 다른 동작&quot;)\n\t&#125;\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#125;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Ipad: Remote &#123;\n\tfunc turnOn() &#123; print(&quot;아이패드 켜기&quot;) &#125;\n\tfunc doAnotherAction() &#123; print(&quot;아이패드 다른 동작&quot;) &#125;\n&#125;\n\n&#x2F;* \n[Ipad Class의 Virtual Table]\n - func turnOn() - print(&quot;아이패드 켜기&quot;)\n - func turnOff() - print(&quot;리모컨 끄기&quot;) -&gt; 기본 구현\n - func doAnotherAction() - print(&quot;아이패드 다른 동작&quot;)\n*&#x2F;\nlet ipad: Ipad &#x3D; Ipad()\nipad.turnOn() &#x2F;&#x2F; &quot;아이패드 켜기&quot;\nipad.turnOff() &#x2F;&#x2F; &quot;리모컨 끄기&quot; -&gt; 기본 구현\nipad.doAnotherAction() &#x2F;&#x2F; &quot;아이패드 다른 동작&quot;\n\nlet ipad2: Remote &#x3D; Ipad()\nipad2.turnOn() &#x2F;&#x2F; &quot;아이패드 켜기&quot;\nipad2.turnOff() &#x2F;&#x2F; &quot;리모컨 끄기&quot; -&gt; 기본 구현\nipad2.doAnotherAction() &#x2F;&#x2F; &quot;또 다른 동작&quot; -&gt; 기본 구현<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"확장-제한\"><a href=\"#확장-제한\" class=\"headerlink\" title=\"확장 제한\"></a>확장 제한</h3><ul>\n<li><code>Self</code>: 타입 자기 자신</li>\n<li>특정 프로토콜을 채택한 타입에만 프로토콜 확장이 가능하도록 제한</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">protocol Bluetooth &#123;\n\tfunc blueOn()\n\tfunc blueOff()\n&#125;\n\nextension Bluetooth where Self: Remote &#123;\n\tfunc blueOn() &#123; print(&quot;블루투스 켜기&quot;) &#125;\n\tfunc blueOff() &#123; print(&quot;블루투스 끄기&quot;) &#125;\n&#125;\n\nclass SmartPhone: Remote, Bluetooth &#123;\n\t\n&#125;\nlet smartphone: SmartPhone &#x3D; SmartPhone()\nsmartphone.blueOn() &#x2F;&#x2F; &quot;블루투스 켜기&quot;\nsmartphone.blueOff() &#x2F;&#x2F; &quot;블루투스 끄기&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"프로토콜-지향-프로그래밍\"><a href=\"#프로토콜-지향-프로그래밍\" class=\"headerlink\" title=\"프로토콜 지향 프로그래밍\"></a>프로토콜 지향 프로그래밍</h2><ul>\n<li>애플은 Swift를 “프로토콜 지향 프로그래밍”이라고 소개하고 있다.<ul>\n<li>“객체 지향 프로그래밍”의 단점을 보완</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"상속의-관점에서-생각해보는-프로토콜\"><a href=\"#상속의-관점에서-생각해보는-프로토콜\" class=\"headerlink\" title=\"상속의 관점에서 생각해보는 프로토콜\"></a>상속의 관점에서 생각해보는 프로토콜</h4><ol>\n<li>여러개의 프로토콜 채택 가능 (<strong>다중 상속</strong>)</li>\n<li><strong>메모리 구조</strong>에 대한 특정 <strong>요구사항 없음</strong> (<code>@objc optional</code>)</li>\n<li><strong>모든 타입</strong>에서 채택 가능 (값타입도 채택 가능)</li>\n<li><strong>타입으로 사용</strong> 가능하여 활용성 ⬆️</li>\n<li><strong>구성&#x2F;재사용성</strong> ⬆️</li>\n<li>애플이 이미 만들어둔 데이터타입도 채택하여 활용 가능 (<strong>소급적 적용</strong>)</li>\n</ol>\n","text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 프로토콜 (protocol)프로토콜의 개념프로토콜의 필요성 클래스 상속의 단점 하나의 클래스만 상속 가능 (다중 상속 불가) 상위 클래스의 메모리 구조를 따라감 (필요하지 않은 ...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":81,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":81,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-protocol\"><span class=\"toc-text\">프로토콜 (protocol)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%EA%B0%9C%EB%85%90\"><span class=\"toc-text\">프로토콜의 개념</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\"><span class=\"toc-text\">프로토콜의 필요성</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%9E%A0%EA%B9%90\"><span class=\"toc-text\">잠깐!</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%AC%B8%EB%B2%95\"><span class=\"toc-text\">프로토콜 문법</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%86%8D%EC%84%B1-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\"><span class=\"toc-text\">속성 요구사항</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\"><span class=\"toc-text\">메서드 요구사항</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\"><span class=\"toc-text\">생성자 요구사항</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%8B%A4%ED%8C%A8%EA%B0%80%EB%8A%A5-%EC%83%9D%EC%84%B1%EC%9E%90%EC%9D%BC-%EA%B2%BD%EC%9A%B0\"><span class=\"toc-text\">실패가능 생성자일 경우</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%84%9C%EB%B8%8C%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\"><span class=\"toc-text\">서브스크립트 요구사항</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C%EC%8D%A8%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\"><span class=\"toc-text\">타입으로써의 프로토콜</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C%EC%8D%A8%EC%9D%98-%EC%9E%A5%EC%A0%90\"><span class=\"toc-text\">타입으로써의 장점</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EA%B0%99%EC%9D%80-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EB%81%BC%EB%A6%AC-%EB%AC%B6%EC%96%B4%EC%84%9C-%EC%B7%A8%EA%B8%89\"><span class=\"toc-text\">같은 프로토콜끼리 묶어서 취급</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A4%80%EC%88%98%EC%84%B1-%EA%B2%80%EC%82%AC\"><span class=\"toc-text\">프로토콜 준수성 검사</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%EC%83%81%EC%86%8D\"><span class=\"toc-text\">프로토콜의 상속</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-AnyObject\"><span class=\"toc-text\">클래스 전용 프로토콜 (AnyObject)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%ED%95%A9%EC%84%B1\"><span class=\"toc-text\">프로토콜의 합성</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%84%A0%ED%83%9D%EC%A0%81-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-Optional-Protocol-Requirements\"><span class=\"toc-text\">선택적 요구사항 (Optional Protocol Requirements)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8-Attribute\"><span class=\"toc-text\">어트리뷰트 (Attribute)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%ED%99%95%EC%9E%A5\"><span class=\"toc-text\">프로토콜의 확장</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%99%95%EC%9E%A5-%EC%A0%9C%ED%95%9C\"><span class=\"toc-text\">확장 제한</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\"><span class=\"toc-text\">프로토콜 지향 프로그래밍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%83%81%EC%86%8D%EC%9D%98-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%8A%94-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\"><span class=\"toc-text\">상속의 관점에서 생각해보는 프로토콜</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"33)🧰 Swift - 메서드 디스패치 (Method Dispatch)","uid":"69f8880ec5c4a5498a069d7bb5807eb6","slug":"Allen/2022-10-14-Allen33","date":"2022-10-13T15:00:00.000Z","updated":"2023-03-31T10:34:18.824Z","comments":true,"path":"api/articles/Allen/2022-10-14-Allen33.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) Method Dispatch코드 영역에 저장된 함수&#x2F;메서드를 실행시키려면 그 주소를 알아야합니다.이 메서드를 실행시키는 방법에는 크게 3가지 방법이 있습니다. Swift...","link":"","photos":[],"count_time":{"symbolsCount":679,"symbolsTime":"1 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":81,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":81,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"12)🍎 Swift - Bounds vs Frame","uid":"00b2e378bc58cce5d9b436f772921098","slug":"Swift/2022-10-11-Swift12","date":"2022-10-10T15:00:00.000Z","updated":"2023-03-31T10:42:24.785Z","comments":true,"path":"api/articles/Swift/2022-10-11-Swift12.json","keywords":null,"cover":[],"text":"오늘은 frame과 bounds의 실체와 차이점에 대해 공부해볼거에요.두 친구 모두 코드 상에서 UIView에 변경을 가할 때 자주 보게 되는 용어들이죠.근데 지금까지는 그냥 둘 다 써보고 제가 원하던 프로퍼티가 있으면 사용하곤 했습니다.view.bo...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Swift","slug":"Swift","count":30,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":81,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":81,"path":"api/tags/iOS.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}