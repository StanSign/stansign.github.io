{"title":"42)🧰 Swift - 동시성 프로그래밍","uid":"8fd8cb15083779ba6732fe56b2a7d55a","slug":"Allen/2022-12-04-Allen42","date":"2022-12-03T15:00:00.000Z","updated":"2023-03-31T10:35:30.349Z","comments":true,"path":"api/articles/Allen/2022-12-04-Allen42.json","keywords":null,"cover":[],"content":"<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8\">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>\n<h1 id=\"비동기-프로그래밍\"><a href=\"#비동기-프로그래밍\" class=\"headerlink\" title=\"비동기 프로그래밍\"></a>비동기 프로그래밍</h1><h2 id=\"비동기-처리가-필요한-이유\"><a href=\"#비동기-처리가-필요한-이유\" class=\"headerlink\" title=\"비동기 처리가 필요한 이유\"></a>비동기 처리가 필요한 이유</h2><h3 id=\"네트워크-통신과-비동기-처리\"><a href=\"#네트워크-통신과-비동기-처리\" class=\"headerlink\" title=\"네트워크 통신과 비동기 처리\"></a>네트워크 통신과 비동기 처리</h3><p>대부분의 앱에서는 서버와의 통신이 필요합니다. </p>\n<img src=\"https://i.imgur.com/ziUlpZG.png\" width=\"350\">\n당근 마켓의 화면입니다. UIKit의 요소만 보자면 단순하게 테이블뷰를 나열한 것이지만, 그 내용은 서버에서 받아온 데이터들로 이루어져 있습니다.\n\n<p>그런데 이 테이블뷰를 스크롤하면 새롭게 화면에 보여지는 내용을 보여주기 위해서 서버와 통신을 해야겠죠.</p>\n<p>이 통신 과정을 동기적으로 처리한다면, 스크롤 할 때마다 화면이 버벅이는 현상이 발생합니다.</p>\n<h3 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h3><p>우리가 코드로 적은 프로그램은 CPU의 쓰레드에서 한 줄 씩 실행됩니다.</p>\n<p><img src=\"https://i.imgur.com/2lWdLCE.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>출처: <a href=\"https://lena-chamna.netlify.app/post/concurrency_programming_thread_and_queue/\">레나참나님 블로그</a></p></blockquote>\n<p>그런데 별 다른 명시가 없다면(비동기 프로그래밍을 하지 않는다면) 이 코드의 실행이 모두 1번 쓰레드(메인 쓰레드)에서 실행됩니다.</p>\n<p><code>print</code>문과 같은 단순한 작업들은 전부 메인 쓰레드에서 동작해도 아무 문제가 없지만, 네트워킹과 같은 비교적 무거운 작업들은 메인 쓰레드에서 동작시키면 상당히 긴 작업시간을 잡아먹어버리게 됩니다.</p>\n<p>그러면 이런 무거운 작업들을 놀고 있는 2번 쓰레드, 3번 쓰레드 등에 넘겨주면 메인 쓰레드는 다른 가벼운 작업들을 멈춤 없이 실행할 수 있겠죠!</p>\n<p>사실 메인 쓰레드는 우리가 입력한 코드 외에도 할 일이 매우 많습니다.</p>\n<h3 id=\"앱의-시작-과정과-동작-원리\"><a href=\"#앱의-시작-과정과-동작-원리\" class=\"headerlink\" title=\"앱의 시작 과정과 동작 원리\"></a>앱의 시작 과정과 동작 원리</h3><p>앱의 시작 과정과 동작은 모두 메인 쓰레드에서 담당합니다.</p>\n<p>앱을 처음 실행하면, 다른 모든 프로그램들과 마찬가지로 <code>main</code> 함수가 실행됩니다.</p>\n<p>이 <code>main</code> 함수는 <code>UIApplicationMain()</code>이라는 앱 객체를 생성하고 UI 구성, 앱 상태 측정등의 앱 준비 과정을 거쳐서 앱이 실행됩니다.</p>\n<p>앱이 실행된 후에는 런루프가 생성됩니다. 이 런루프는 무한 반복문으로서 유저의 인터랙션(터치, 핀치 등)을 받아 그 이벤트를 처리하는 객체입니다.</p>\n<ul>\n<li>ex) <code>@IBAction</code>, <code>#selector</code></li>\n</ul>\n<img src=\"https://i.imgur.com/7Yo9WFp.png\" width=\"300\">\n\n<p>아이폰의 화면은 대부분 60Hz입니다. <em>(최근엔 144Hz까지 지원하는 기종도 있지만)</em></p>\n<p>그렇다면 1초에 60번 화면을 출력해야 하는데 이 1초의 과정을 <strong>Update Cycle</strong>이라고 하고, 메인 쓰레드가 담당하여 화면 출력을 위한 연산을 합니다.</p>\n<p>그래서 사실 우리가 입력하는 코드는 이 사이클 중간중간에 끼워넣어지는 것이죠..!</p>\n<p>화면이 버벅이는 현상은 여기서 발생합니다.</p>\n<p>네트워킹과 같은 무거운 작업이 메인 쓰레드를 붙잡고 있어버리면, 이 업데이트 사이클이 돌지 못해버리는 현상이 발생합니다.</p>\n<p>따라서 화면이 새로 그려지지 못하고, 멈추는 것과 같은 현상이 발생하는 것이죠.</p>\n<p>그래서 화면을 그리는 일을 방해하지 않으면서 무거운 작업을 하기 위해서는 <strong>동시성 프로그래밍</strong>을 해야한다는 것입니다.</p>\n<p>다행히 iOS의 동시성 프로그래밍은 매우매우 쉬운 편입니다.</p>\n<h3 id=\"iOS에서의-동시성-프로그래밍\"><a href=\"#iOS에서의-동시성-프로그래밍\" class=\"headerlink\" title=\"iOS에서의 동시성 프로그래밍\"></a>iOS에서의 동시성 프로그래밍</h3><p>iOS에서는 작업(Task)를 “대기행렬”(Queue)에 보내기만 해주면, iOS가 알아서 순서대로 작업 처리를 해줍니다.</p>\n<p>할 일을 iOS에서 관리해주는 <strong>Queue에 던져주기만 하면 알아서 순서대로</strong> 작업을 해준다는 뜻입니다.</p>\n<p>조금 더 정확히 설명하면, Queue에 넣어준 작업(Task)들은 FIFO 방식으로 즉시 각각의 쓰레드에 배치됩니다.</p>\n<p>iOS는 두 가지 Queue를 제공합니다.</p>\n<ol>\n<li>DispatchQueue<ul>\n<li>&#x3D; GCD(Grand Central DispatchQueue)</li>\n</ul>\n</li>\n<li>OperationQueue</li>\n</ol>\n<p>여기서 우리가 주목해야할 것은 <code>DispatchQueue</code>입니다. <code>OperationQueue</code>는 상당히 어려운 개념이고, 실무에서도 거의 사용되지 않기 때문에 우선 <code>DispatchQueue</code>만 공부해보도록 하겠습니다!</p>\n<h3 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h3><p>자 그런데, 사실 프로그래밍을 하며 관리하는 소프트웨어적인 쓰레드(NSThread)는 하드웨어의 쓰레드와 1:1 매칭되는 객체는 아닙니다.</p>\n<p>물리적인 쓰레드는 하나하나가 굉장히 빠릅니다.</p>\n<p>사실 소프트웨어적으로 아무리 작업을 끼워넣어도 하드웨어적인 쓰레드에게는 매우 여유로운 일입니다.</p>\n<p>그래서 하드웨어적인 쓰레드는 한가지 NSThread에서만 일하지 않고, 여러 군데에 왔다갔다하면서 작업을 수행합니다.</p>\n<p>이 과정은 OS가 알아서 해주는 동작이라서 코딩을 하는 우리는 <strong>NSThread의 개수가 하드웨어적으로 명시된 쓰레드의 개수보다는 훨씬 많겠구나!</strong> 정도만 알아두면 될 것 같습니다.</p>\n<h2 id=\"비동기-async-동시-concurrent-의-개념\"><a href=\"#비동기-async-동시-concurrent-의-개념\" class=\"headerlink\" title=\"비동기(async), 동시(concurrent)의 개념\"></a>비동기(async), 동시(concurrent)의 개념</h2><h3 id=\"동기-sync-vs-비동기-async\"><a href=\"#동기-sync-vs-비동기-async\" class=\"headerlink\" title=\"동기(sync) vs 비동기(async)\"></a>동기(sync) vs 비동기(async)</h3><img src=\"https://i.imgur.com/8Sb5G1i.png\" width=\"500\">\n- 비동기(asynchronous)\n    - 작업을 시작한 후에, 작업이 끝나길 기다리지 않는다\n    - 작업을 시작시킨 후에 다른 작업을 하러 간다.\n- 동기(synchronous)\n    - 작업을 시작한 후에, 작업이 끝날때까지 기다린다.\n    - 작업이 수행되는 동안 쓰레드는 block된다.\n\n<h3 id=\"직렬-Serial-vs-병렬-concurrent\"><a href=\"#직렬-Serial-vs-병렬-concurrent\" class=\"headerlink\" title=\"직렬(Serial) vs 병렬(concurrent)\"></a>직렬(Serial) vs 병렬(concurrent)</h3><ul>\n<li>직렬(serial)<ul>\n<li>하나의 쓰레드만 생성하여 하나의 쓰레드로만 작업 전달</li>\n<li>순서가 중요한 작업을 처리할 때 사용</li>\n</ul>\n</li>\n<li>병렬(concurrent)<ul>\n<li>여러개의 쓰레드를 생성하여 알아서 알맞는 쓰레드에 작업 전달</li>\n<li>각자 독립적이지만 유사한 여러개의 작업을 처리할 때 사용</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"GCD의-개념-및-종류\"><a href=\"#GCD의-개념-및-종류\" class=\"headerlink\" title=\"GCD의 개념 및 종류\"></a>GCD의 개념 및 종류</h2><h3 id=\"큐-Queue-의-종류\"><a href=\"#큐-Queue-의-종류\" class=\"headerlink\" title=\"큐(Queue)의 종류\"></a>큐(Queue)의 종류</h3><table>\n<thead>\n<tr>\n<th>:큐의 종류</th>\n<th></th>\n<th>생성 코드</th>\n<th>특징</th>\n<th>직렬&#x2F;동시</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dispatch  Queue</td>\n<td>.main</td>\n<td><code>DispatchQueue.main</code></td>\n<td>메인큐 &#x3D; 메인쓰레드</td>\n<td>Serial</td>\n</tr>\n<tr>\n<td></td>\n<td>.global()</td>\n<td><code>DispatchQueue.global(qos:)</code></td>\n<td>6가지 Qos (작업에 따라 Qos 상승 가능)</td>\n<td>Concurrent</td>\n</tr>\n<tr>\n<td></td>\n<td>custom</td>\n<td><code>DispatchQueue(label: &quot;...&quot;)</code></td>\n<td>Qos추론 &#x2F; 설정 가능</td>\n<td>Both</td>\n</tr>\n<tr>\n<td>:OperationQueue</td>\n<td></td>\n<td><code>let opQ = OperationQueue()</code></td>\n<td>디폴트: .background, underlying 디스패치큐에 영향</td>\n<td>Both</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#x2F;&#x2F; 직렬 Queue\nlet privateQueue &#x3D; DispatchQueue(label: &quot;com.inflearn.serial&quot;)\n\nlet concurrentQueue &#x3D; DispatchQueue(label: &quot;custom&quot;, attributes: .concurrent)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"GCD-사용-시-주의해야-할-사항\"><a href=\"#GCD-사용-시-주의해야-할-사항\" class=\"headerlink\" title=\"GCD 사용 시 주의해야 할 사항\"></a>GCD 사용 시 주의해야 할 사항</h2><h3 id=\"1-반드시-메인큐에서-처리해야하는-작업\"><a href=\"#1-반드시-메인큐에서-처리해야하는-작업\" class=\"headerlink\" title=\"1) 반드시 메인큐에서 처리해야하는 작업\"></a>1) 반드시 메인큐에서 처리해야하는 작업</h3><p>화면을 그리는 <strong>UI와 관련된 작업들은 메인쓰레드</strong>에서 동작해야합니다.</p>\n<p>따라서 GCD를 사용하여 메인쓰레드가 아닌 쓰레드에서 동작하던 코드 중간에 UI와 관련된 작업이 필요하다면, 메인 쓰레드에 이 작업을 보내주는 작업이 필요합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">&#x2F;&#x2F; URLSession은 내부적으로 비동기 작업\nURLSession.shared.dataTask(with: url) &#123; data, response, error in\n\tif let error &#x3D; error &#123;\n\t\tprint(&quot;에러&quot;)\n\t&#125;\n\n\tguard let imageData &#x3D; data else &#123; return &#125;\n\tlet photoImage &#x3D; UIImage(data: imageData)\n\tDispatchQueue.main.async &#123; &#x2F;&#x2F; UI 관련 작업은 main thread에서\n\t\timageView?.image &#x3D; photoImage\n\t&#125;\n&#125;.resume()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-컴플리션-핸들러의-존재-이유-올바른-콜백-함수의-사용\"><a href=\"#2-컴플리션-핸들러의-존재-이유-올바른-콜백-함수의-사용\" class=\"headerlink\" title=\"2) 컴플리션 핸들러의 존재 이유 - 올바른 콜백 함수의 사용\"></a>2) 컴플리션 핸들러의 존재 이유 - 올바른 콜백 함수의 사용</h3><p>비동기 처리를 사용하다보면 발생하는 문제점이 하나 있습니다.</p>\n<p>비동기적이라고 하면 일을 시작시키고 작업이 끝날때까지 기다리지 않고 다른 일을 처리하러 간다는 장점이 있었습니다.</p>\n<p>비동기적으로 처리시킨 작업이 끝나는 시점에 필요한 작업이 있다면 어떻게 해야할까요? 예를 들면 작업이 끝났을 때 나온 결과를 <code>return</code>해야할 경우가 있습니다.</p>\n<p><code>return</code> 구문을 사용한다면 작업이 끝나기 전에 끝나버리기 때문에 항상 <code>nil</code> 값을 받아올 것입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func getImages(str: String) -&gt; UIImage? &#123;\n\tURLSession.shared.dataTask(...) &#123;\n\t&#125;.resume()\n\treturn photoImage &#x2F;&#x2F; nil (작업이 끝나지 않았는데 return)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>이 때 바로 <strong><code>@escaping</code> 클로저</strong>가 등장합니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func getImage(str: String, completion: @escaping ((UIImage?) -&gt; Void) &#123;\n\tURLSession.shared.dataTask(...) &#123;\n\t\tcompletion(photoImage) &#x2F;&#x2F; 내부 작업이 끝나면 escaping closure 호출\n\t&#125;.resume()\n&#125;\n\ngetImage(&quot;url&quot;) &#123; image in\n\timageView?.setImage(image)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>@escaping</code> 클로저의 파라미터로 데이터를 받아 처리를 하면, 해당 함수가 “끝난” 시점에 클로저를 호출할 수 있기 때문에 이런 방식으로 사용해야합니다.</p>\n<h3 id=\"3-weak-strong-캡처의-주의\"><a href=\"#3-weak-strong-캡처의-주의\" class=\"headerlink\" title=\"3) weak, strong 캡처의 주의\"></a>3) weak, strong 캡처의 주의</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">DispatchQueue.global(qos: .utility).async &#123; [weak self] in\n\tguard let self &#x3D; self else &#123; return &#125;\n\tDispatchQueue.main.async &#123;\n\t\tself.textLabel.text &#x3D; &quot;New posts updated.&quot;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>대부분의 경우, 캡처리스트 안에서 <code>weak self</code>로 선언하는 것이 권장됩니다.</p>\n<h3 id=\"4-동기함수를-비동기적으로-동작하는-함수로-변형\"><a href=\"#4-동기함수를-비동기적으로-동작하는-함수로-변형\" class=\"headerlink\" title=\"4) 동기함수를 비동기적으로 동작하는 함수로 변형\"></a>4) 동기함수를 비동기적으로 동작하는 함수로 변형</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func longTimePrint(name: String) -&gt; String &#123;\n\tprint(&quot;1&quot;)\n\tsleep(1)\n\tprint(&quot;2&quot;)\n\tsleep(2)\n\tprint(&quot;3&quot;)\n\tsleep(3)\n\treturn &quot;작업 종료&quot;\n&#125;\n\nfunc asyncLongTimePrint(name: String, completion: @escaping (String -&gt; Void) &#123;\n\tDispatchQueue.global().async &#123;\n\t\tlet n &#x3D; longtimePrint(name: name)\n\t\tcompletion(n)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"비동기-함수-x2F-메서드의-이해\"><a href=\"#비동기-함수-x2F-메서드의-이해\" class=\"headerlink\" title=\"비동기 함수&#x2F;메서드의 이해\"></a>비동기 함수&#x2F;메서드의 이해</h2><h3 id=\"URLSession\"><a href=\"#URLSession\" class=\"headerlink\" title=\"URLSession\"></a>URLSession</h3><p>대표적으로 <code>URLSesison</code>은 이미 내부적으로 GCD를 이용해서 비동기적으로 처리하는 메서드로 생각해야 합니다.</p>\n<p>따라서 굳이 <code>DispatchQueue</code>로 감싸주지 않아도 됩니다.</p>\n<p>그런데 비슷한 동작을 하는 <code>Data(contentsOf: url)</code>의 경우에는 비동기적으로 만들어져 있지 않습니다.</p>\n<p>애플 공식 문서를 보고 비동기적으로 구현된 함수인지 아닌지 확인하면서 사용해야할 것 같습니다!</p>\n<h2 id=\"async-x2F-await의-도입\"><a href=\"#async-x2F-await의-도입\" class=\"headerlink\" title=\"async&#x2F;await의 도입\"></a>async&#x2F;await의 도입</h2><p>Swift 5.5이후 <code>async</code>와 <code>await</code>가 도입되었습니다. 파이썬과 자바스크립트에서 사용되던 패턴을 Swift에 맞게 가져온 개념입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func processImageData(completion: (_ result: Image) -&gt; Void) &#123;\n\tloadWebResource(&quot;dataprofile.txt&quot;) &#123; dataResource in\n\t\tloadWebResource(&quot;imagedata.dat&quot;) &#123; imageResource in\n\t\t\tdecodeImage(dataResource, imageResource) &#123; imageTmp in\n\t\t\t\tdewarpAndCleanupImage(imageTmp) &#123; imageResult in\n\t\t\t\t\tcompletion(imageResult)\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>와우.. 보기만해도 숨이 막히죠</p>\n<p><code>async</code>, <code>await</code>를 사용하면 이런 들여쓰기의 반복을 해소할 수 있습니다. 또한 <code>return</code>을 사용할 수 있게 됩니다..!</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">func processImageData() async throws -&gt; Image &#123;\n\tlet dataResource &#x3D; try await loadWebResource(&quot;dataprofile.txt&quot;)\n\tlet imageResource &#x3D; try await loadWebResource(&quot;imagedata.dat&quot;)\n\tlet imageTmp &#x3D; try await decodeImage(dataResource, imageResource)\n\tlet imageResult &#x3D; try await dewarpAndCleanupImage(imageTmp)\n\treturn imageResult\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"동시성-프로그래밍의-메모리-구조\"><a href=\"#동시성-프로그래밍의-메모리-구조\" class=\"headerlink\" title=\"동시성 프로그래밍의 메모리 구조\"></a>동시성 프로그래밍의 메모리 구조</h2><p>코드-데이터-힙-스택의 메모리 구조 중에서 <strong>“스택”</strong> 영역을 쓰레드마다 각각 가지게 됩니다.</p>\n<p>동작이 할당될때마다 각자의 스택 영역에 해당 메서드를 쌓아두면서 실행합니다.</p>\n<p>반면 코드-데이터-힙 영역은 모든 쓰레드가 공유하는 자원입니다.</p>\n<h2 id=\"동시성-프로그래밍과-관련된-문제점\"><a href=\"#동시성-프로그래밍과-관련된-문제점\" class=\"headerlink\" title=\"동시성 프로그래밍과 관련된 문제점\"></a>동시성 프로그래밍과 관련된 문제점</h2><h3 id=\"1-경쟁-상황-x2F-경쟁-조건-Race-Condition\"><a href=\"#1-경쟁-상황-x2F-경쟁-조건-Race-Condition\" class=\"headerlink\" title=\"1) 경쟁 상황 &#x2F; 경쟁 조건 (Race  Condition)\"></a>1) 경쟁 상황 &#x2F; 경쟁 조건 (Race  Condition)</h3><p>같은 시점에 여러개의 쓰레드에서 하나의 메모리에 동시 접근하는 문제입니다.</p>\n<p>메모리에 쓰고 있는 동안에는 여러 쓰레드에서 접근하지 못하도록 해당 메모리를 잠구는 기능을 Thread-Safe 처리한다 라고 합니다.</p>\n<h3 id=\"2-교착-상태-Deadlocks\"><a href=\"#2-교착-상태-Deadlocks\" class=\"headerlink\" title=\"2) 교착 상태 (Deadlocks)\"></a>2) 교착 상태 (Deadlocks)</h3><p>Thread-Safe 처리한다고 해서 모든 문제점이 사라지는 건 아닙니다.</p>\n<p>Thread2와 Thread3이 있다고 가정하고, 각각이 <code>person1.name = &quot;홍길동&quot;</code>, <code>persone2.name = &quot;임꺽정&quot;</code>과 같이 정의하고 Thread-Safe 처리했다고 합시다.</p>\n<img src=\"https://i.imgur.com/yQuo3q9.png\" width=\"450\">\n\n<p>Thread2와 Thread3이 같은 시점에 서로의 데이터 영역에 있는 값에 접근을 하면, 두 값 모두 잠겨있기 때문에 두 쓰레드 모두 작업을 종료하지 못하고 앱이 충돌하며 강제종료되게 됩니다.</p>\n<h2 id=\"동시성-프로그래밍-문제점의-해결\"><a href=\"#동시성-프로그래밍-문제점의-해결\" class=\"headerlink\" title=\"동시성 프로그래밍 문제점의 해결\"></a>동시성 프로그래밍 문제점의 해결</h2><h3 id=\"동시큐에서-직렬큐로-보내기\"><a href=\"#동시큐에서-직렬큐로-보내기\" class=\"headerlink\" title=\"동시큐에서 직렬큐로 보내기\"></a>동시큐에서 직렬큐로 보내기</h3><p>아주 간단한 해결방법이 있습니다. 동시큐에서 각자 작업을 한 뒤에, 데이터 영역이나 힙 영역에 접근을 하는 부분에서만 직렬큐로 작업을 보내주어서 처리하는 방법입니다.</p>\n<p>직렬큐는 하나의 일만 할 수 있기 때문에, 경쟁 상황을 해소할 수 있습니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var array &#x3D; [String]()\n\nlet serialQueue &#x3D; DispatchQueue(label: &quot;serial&quot;)\n\nfor i in 1...20 &#123;\n\tDispatchQueue.global().async &#123; &#x2F;&#x2F; 여러개의 쓰레드\n\t\tprint(&quot;\\(i)&quot;)\n\t\tarray.append(&quot;\\(i)&quot;) &#x2F;&#x2F; 동시 다발적으로 배열의 메모리에 접근\n\t&#125;\n&#125;\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 5) &#123;\n\tprint(array) &#x2F;&#x2F; [&quot;2&quot;, &quot;6&quot;, &quot;4&quot;, ..., &quot;1&quot;, &quot;19&quot;] 빠지는 숫자가 생긴다\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var array &#x3D; [String]()\n\nlet serialQueue &#x3D; DispatchQueue(label: &quot;serial&quot;)\n\nfor i in 1...20 &#123;\n\tDispatchQueue.global().async &#123; &#x2F;&#x2F; 여러개의 쓰레드\n\t\tprint(&quot;\\(i)&quot;)\n\t\tserialQueue.async &#123;\n\t\t\tarray.append(&quot;\\(i)&quot;) &#x2F;&#x2F; 한 번에 하나의 작업만 접근\n\t\t&#125;\n\t&#125;\n&#125;\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 5) &#123;\n\tprint(array) &#x2F;&#x2F; [&quot;2&quot;, &quot;6&quot;, &quot;4&quot;, ..., &quot;1&quot;, &quot;19&quot;] 모든 숫자가 제대로 들어간다\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>왜 UI를 메인쓰레드에서만 업데이트 해야 할까?</p></blockquote>\n<ol>\n<li>UIKit의 모든 속성을 Thread-Safe하게 설계하면, 느려짐과 같은 성능 저하가 발생할 수 있기 때문에 그렇게 설계할 수 없다. (<strong>Thread-Safe하지 않게 설계한 것은 애플의 의도</strong>이다!)</li>\n<li><strong>메인 런루프(Runloop)</strong> 가 뷰의 업데이트를 관리하는 <strong>View Drawing Cycle</strong>을 통해 뷰를 동시에 업데이트 하고 있는데, 백그라운드 쓰레드가 각자의  런루프로  동작을 하면 뷰가 제멋대로 동작할 수 있다.</li>\n<li>iOS가 그림을 그리는 <strong>렌더링 프로세스</strong>에서 여러 쓰레드가 각자의 변경사항을 <strong>GPU</strong>로 보내면, GPU는 각각의 정보를 모두 해석해야해서 느려지거나 비효율적이다.</li>\n</ol>\n","text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 비동기 프로그래밍비동기 처리가 필요한 이유네트워크 통신과 비동기 처리대부분의 앱에서는 서버와의 통신이 필요합니다. 당근 마켓의 화면입니다. UIKit의 요소만 보자면 단순하게 테...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":82,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":82,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\"><span class=\"toc-text\">비동기 프로그래밍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0\"><span class=\"toc-text\">비동기 처리가 필요한 이유</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%86%B5%EC%8B%A0%EA%B3%BC-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC\"><span class=\"toc-text\">네트워크 통신과 비동기 처리</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Thread\"><span class=\"toc-text\">Thread</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%95%B1%EC%9D%98-%EC%8B%9C%EC%9E%91-%EA%B3%BC%EC%A0%95%EA%B3%BC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\"><span class=\"toc-text\">앱의 시작 과정과 동작 원리</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#iOS%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\"><span class=\"toc-text\">iOS에서의 동시성 프로그래밍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NSThread\"><span class=\"toc-text\">NSThread</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-async-%EB%8F%99%EC%8B%9C-concurrent-%EC%9D%98-%EA%B0%9C%EB%85%90\"><span class=\"toc-text\">비동기(async), 동시(concurrent)의 개념</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%8F%99%EA%B8%B0-sync-vs-%EB%B9%84%EB%8F%99%EA%B8%B0-async\"><span class=\"toc-text\">동기(sync) vs 비동기(async)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%A7%81%EB%A0%AC-Serial-vs-%EB%B3%91%EB%A0%AC-concurrent\"><span class=\"toc-text\">직렬(Serial) vs 병렬(concurrent)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GCD%EC%9D%98-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%A2%85%EB%A5%98\"><span class=\"toc-text\">GCD의 개념 및 종류</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%81%90-Queue-%EC%9D%98-%EC%A2%85%EB%A5%98\"><span class=\"toc-text\">큐(Queue)의 종류</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GCD-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%B4%EC%95%BC-%ED%95%A0-%EC%82%AC%ED%95%AD\"><span class=\"toc-text\">GCD 사용 시 주의해야 할 사항</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%EB%B0%98%EB%93%9C%EC%8B%9C-%EB%A9%94%EC%9D%B8%ED%81%90%EC%97%90%EC%84%9C-%EC%B2%98%EB%A6%AC%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9E%91%EC%97%85\"><span class=\"toc-text\">1) 반드시 메인큐에서 처리해야하는 작업</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%EC%BB%B4%ED%94%8C%EB%A6%AC%EC%85%98-%ED%95%B8%EB%93%A4%EB%9F%AC%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%B4%EC%9C%A0-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98%EC%9D%98-%EC%82%AC%EC%9A%A9\"><span class=\"toc-text\">2) 컴플리션 핸들러의 존재 이유 - 올바른 콜백 함수의 사용</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-weak-strong-%EC%BA%A1%EC%B2%98%EC%9D%98-%EC%A3%BC%EC%9D%98\"><span class=\"toc-text\">3) weak, strong 캡처의 주의</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%EB%8F%99%EA%B8%B0%ED%95%A8%EC%88%98%EB%A5%BC-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98%EB%A1%9C-%EB%B3%80%ED%98%95\"><span class=\"toc-text\">4) 동기함수를 비동기적으로 동작하는 함수로 변형</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98-x2F-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%9D%B4%ED%95%B4\"><span class=\"toc-text\">비동기 함수&#x2F;메서드의 이해</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#URLSession\"><span class=\"toc-text\">URLSession</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#async-x2F-await%EC%9D%98-%EB%8F%84%EC%9E%85\"><span class=\"toc-text\">async&#x2F;await의 도입</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\"><span class=\"toc-text\">동시성 프로그래밍의 메모리 구조</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90\"><span class=\"toc-text\">동시성 프로그래밍과 관련된 문제점</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%EA%B2%BD%EC%9F%81-%EC%83%81%ED%99%A9-x2F-%EA%B2%BD%EC%9F%81-%EC%A1%B0%EA%B1%B4-Race-Condition\"><span class=\"toc-text\">1) 경쟁 상황 &#x2F; 경쟁 조건 (Race  Condition)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C-Deadlocks\"><span class=\"toc-text\">2) 교착 상태 (Deadlocks)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EC%A0%9C%EC%A0%90%EC%9D%98-%ED%95%B4%EA%B2%B0\"><span class=\"toc-text\">동시성 프로그래밍 문제점의 해결</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%8F%99%EC%8B%9C%ED%81%90%EC%97%90%EC%84%9C-%EC%A7%81%EB%A0%AC%ED%81%90%EB%A1%9C-%EB%B3%B4%EB%82%B4%EA%B8%B0\"><span class=\"toc-text\">동시큐에서 직렬큐로 보내기</span></a></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"43)🧰 Swift - 제네릭 (Generics)","uid":"c2e56e6a64d2c2ad251d398ab5d466c0","slug":"Allen/2022-12-05-Allen43","date":"2022-12-04T15:00:00.000Z","updated":"2023-03-31T10:35:34.166Z","comments":true,"path":"api/articles/Allen/2022-12-05-Allen43.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 제네릭 (Generics)제네릭이 왜 필요한가?var num1 &#x3D; 10 var num2 &#x3D; 20 func swapTwoInts(_ a: inout Int, _ ...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":82,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":82,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"15)🍎 Swift - ReactorKit","uid":"1cd419cd63835d685fc8cde482245df5","slug":"Swift/2022-12-04-Swift15","date":"2022-12-03T15:00:00.000Z","updated":"2023-03-31T10:42:54.374Z","comments":true,"path":"api/articles/Swift/2022-12-04-Swift15.json","keywords":null,"cover":[],"text":"ReactorKit앱스토어에 등록된 앱들의 오픈소스를 훔쳐보면 꽤나 자주 보였던 ReactorKit입니다. 사실 막연하게 React Native랑 관련된건가보다~ 하고 지나치곤 했었는데.. 전혀 아니였죠? 😜 겨울 프로젝트 동안 사용해야 할 것 같아서...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"Swift","slug":"Swift","count":31,"path":"api/categories/Swift.json"}],"tags":[{"name":"Swift","slug":"Swift","count":82,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":82,"path":"api/tags/iOS.json"},{"name":"ReactorKit","slug":"ReactorKit","count":1,"path":"api/tags/ReactorKit.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 목적 있는 성장을 지향하는 <br/> iOS 개발자 준비생 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}