{"title":"23)🧰 Swift - 메서드(Method)","uid":"142b77ed1f32b84f0b8d08fde4f6ac05","slug":"Allen/2022-09-30-Allen23","date":"2022-09-29T15:00:00.000Z","updated":"2023-03-31T10:33:24.909Z","comments":true,"path":"api/articles/Allen/2022-09-30-Allen23.json","keywords":null,"cover":[],"content":"<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8\">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>\n<h1 id=\"구조체와-클래스의-메서드\"><a href=\"#구조체와-클래스의-메서드\" class=\"headerlink\" title=\"구조체와 클래스의 메서드\"></a>구조체와 클래스의 메서드</h1><h2 id=\"메서드의-메모리-동작\"><a href=\"#메서드의-메모리-동작\" class=\"headerlink\" title=\"메서드의 메모리 동작\"></a>메서드의 메모리 동작</h2><ol>\n<li><strong>코드 영역</strong>에서 <code>bori.sit()</code>과 같은 접근연산자를 사용한 메서드를 마주친다.</li>\n<li><strong>스택 영역</strong>의 <code>bori</code> 변수에 찾아간다.<ul>\n<li><code>bori</code> 변수는 힙 영역의 보리 객체를 가리키고 있다.</li>\n</ul>\n</li>\n<li><strong>힙 영역</strong>의 <code>bori</code> 객체에 찾아간다.<ul>\n<li><code>bori</code>의 메서드는 데이터 영역의 클래스 타입에 저장되어 있다.</li>\n</ul>\n</li>\n<li><strong>데이터 영역</strong>의 <code>Dog</code>(<code>bori</code>의 상위 클래스) 클래스 타입에 찾아간다.<ul>\n<li>클래스 타입의 메서드는 실제로는 <strong>코드 영역의 주소값</strong>을 테이블 형태로 지닌다.</li>\n</ul>\n</li>\n<li><strong>코드 영역</strong>의 <code>sit()</code> 함수를 찾아 실행한다.</li>\n</ol>\n<h5 id=\"잠깐\"><a href=\"#잠깐\" class=\"headerlink\" title=\"잠깐!\"></a>잠깐!</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>아니 왜 이렇게 복잡하게 실행하는거에요..?</p></blockquote>\n<p>우선 메서드의 개수가 많아질 경우에는 힙 영역에 메서드를 전부  복사할 경우, 메모리의 누수가 굉장히 많아집니다.<br>또한 클래스의 <strong>상속</strong> 기능을 지원하기 위해서입니다. 이후 상속 포스트에서 자세하게 다뤄볼겁니다!<br><img src=\"https://stansign.github.io/blog/Allen25\" alt=\"🧰 Swift - 클래스(Class)의 상속과 초기화\"></p>\n<p>실제로 구조체(struct)의 경우에는 상속을 지원하지 않기 때문에 위와 같은 복잡한 메모리 접근 구조가 필요가 없습니다. 때문에 구조체의 메서드는 호출 하는 부분의 코드 영역에 <strong>메서드의 코드 영역 메모리 주소</strong>를 직접 명시해버립니다. 이를 <strong>Direct Dispatch</strong>라고 부릅니다.</p>\n<h2 id=\"인스턴스-메서드-Instance-Methods\"><a href=\"#인스턴스-메서드-Instance-Methods\" class=\"headerlink\" title=\"인스턴스 메서드 (Instance Methods)\"></a>인스턴스 메서드 (Instance Methods)</h2><ul>\n<li>가장 기본적인 메서드</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n\n\tfunc sit() &#123;\n\t\tprint(&quot;\\(name)가 앉았습니다.&quot;)\n\t&#125;\n\n\tfunc layDown() &#123;\n\t\tprint(&quot;\\(name)가 누웠습니다.&quot;)\n\t&#125;\n\n\tfunc play() &#123;\n\t\tprint(&quot;열심히 놉니다.&quot;)\n\t&#125;\n\n\tfunc training() &#123;\n\t\tsit()\n\t\tself.sit()\n\t\tself.sit()\n\t&#125;\n\n\tfunc changeName(newName name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\nlet bori &#x3D; Dog(name: &quot;보리&quot;, weight: 20.0)\nbori.sit()\nbori.layDown()\nbori.play()\n\nbori.changeName(newName: &quot;말썽쟁이 보리&quot;)\nprint(bori.name) &#x2F;&#x2F; &quot;말썽쟁이 보리&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"구조체의-인스턴스-메서드\"><a href=\"#구조체의-인스턴스-메서드\" class=\"headerlink\" title=\"구조체의 인스턴스 메서드\"></a>구조체의 인스턴스 메서드</h3><ul>\n<li>값타입에서는 기본적으로 인스턴스 메서드 내에서 속성을 수정할 수 없다.</li>\n<li><code>mutating</code> 키워드를 붙이면 속성 수정이 가능하다.</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">struct Dog &#123;\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n\n\tfunc sit() &#123;\n\t\tprint(&quot;\\(name)가 앉았습니다.&quot;)\n\t&#125;\n\n\tmutating func changeName(newName name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"잠깐-1\"><a href=\"#잠깐-1\" class=\"headerlink\" title=\"잠깐!\"></a>잠깐!</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>아니 왜 mutating이라는 키워드까지 붙여서  속성을 바꿔야 하나요? 그냥 바꾸게 두면 안돼요?</p></blockquote>\n<p>구조체는 <strong>값타입</strong>입니다. 값타입의 데이터는 값을 바꾸게 되면 해당 데이터의 값을 바꾸는 것이 아니라, 바꿀 데이터를 가진 <strong>새로운 데이터</strong>를 만들어버립니다. 그 이유는 스택 메모리의 특성 상 <strong>새로운 데이터를 만드는 것이 더 빠르고</strong>, <strong>목적</strong> 또한 그렇게 사용하기 위함이였기 때문입니다.</p>\n<p>그래서 <code>dog.name = &quot;Doggie&quot;</code>와 같이 값을 변경하면, 내부적으로는 <code>&quot;Doggie&quot;</code>의 값을 갖는 새로운 <code>Dog()</code> 객체를 생성하고, 원래 있던 오래된 객체를 pop시킵니다.</p>\n<p><code>mutating</code>은 이런 현상을 막기 위해 주어지는 키워드입니다. <code>mutating</code> 키워드가 주어지면, 값타입 데이터의 값에 변경이 일어날 때 새로운 데이터를 만드는 대신 해당 속성의 <strong>주소값에 접근하여 값 자체를 수정</strong>합니다. 이는 Swift의 <code>inout</code> 방식과 동일하고, C언어의 포인터와 같은 기능이라고 볼 수 있겠습니다.</p>\n<p>겉으로 보기에는 같은 기능이지만, 내부적으로는 전혀 다른 동작 방식이였던 것이죠! 조금 더 나아가서 생각해보면, <code>class</code>는 참조타입이기 때문에 <code>mutating</code> 키워드를 사용할 필요가 전혀 없습니다. 때문에 XCode도 에러를 발생시키죠!</p>\n<h3 id=\"오버로딩-Overloading\"><a href=\"#오버로딩-Overloading\" class=\"headerlink\" title=\"오버로딩 (Overloading)\"></a>오버로딩 (Overloading)</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">struct Dog &#123;\n\tfunc sit() &#123;\n\t\tprint(&quot;앉았습니다.&quot;)\n\t&#125;\n\n\tfunc sit(a: String) &#123;\n\t\tprint(&quot;\\(a)가 앉았습니다.&quot;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"타입-메서드-Type-Method\"><a href=\"#타입-메서드-Type-Method\" class=\"headerlink\" title=\"타입 메서드 (Type Method)\"></a>타입 메서드 (Type Method)</h2><ul>\n<li>타입 속성과 비슷하게 타입에 종속<ul>\n<li>내&#x2F;외부에서 <code>Type.method()</code>로 접근</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tstatic var species &#x3D; &quot;Dog&quot;\n\n\tstatic func letMeKnow() &#123;\n\t\tprint(&quot;종은 항상 \\(species)입니다.&quot;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"클래스를-사용한-상속\"><a href=\"#클래스를-사용한-상속\" class=\"headerlink\" title=\"클래스를 사용한 상속\"></a>클래스를 사용한 상속</h3><ul>\n<li><code>static</code> 대신  <code>class</code> 키워드를 사용하여 상속할 때 <code>override</code> 가능</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class Dog &#123;\n\tclass func someTypeMethod() &#123;\n\t\tprint(&quot;타입과 관련된 공통된 기능의 구현&quot;)\n\t&#125;\n&#125;\n\nclass Dog2: Dog &#123;\n\toverride class func someTypeMethod() &#123;\n\t\tprint(&quot;타입과 관련된 공통된 기능의 구현 (업데이트)&quot;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"서브-스크립트-Subscripts\"><a href=\"#서브-스크립트-Subscripts\" class=\"headerlink\" title=\"서브 스크립트 (Subscripts)\"></a>서브 스크립트 (Subscripts)</h2><ul>\n<li><code>[]</code>(대괄호)는 사실 특별한 형태의 메서드 호출 역할<ul>\n<li><code>array[0]</code>, <code>dictionary[&quot;A&quot;]</code></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">class myData &#123;\n\tvar datas &#x3D; [&quot;Apple&quot;, &quot;Swift&quot;, &quot;iOS&quot;, &quot;Hello&quot;]\n\n\tsubscript(index: Int) -&gt; String &#123;\n\t\tget &#123;\n\t\t\treturn datas[index]\n\t\t&#125;\n\t\tset(parameterName) &#123;\n\t\t\tdatas[index] &#x3D; parameterName\n\t\t&#125;\n\t&#125;\n&#125;\n\nvar data &#x3D; myData()\n\n&#x2F;&#x2F; subsript 추가 전\nprint(data[3]) &#x2F;&#x2F; Error\nprint(data.datas[3]) &#x2F;&#x2F; &quot;Hello&quot;\n\n&#x2F;&#x2F; subscript 추가 후\nprint(data[0]) &#x2F;&#x2F; &quot;Apple&quot;\ndata[0] &#x3D; &quot;AAA&quot;\nprint(data[0]) &#x2F;&#x2F; &quot;AAA&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"사용-예시\"><a href=\"#사용-예시\" class=\"headerlink\" title=\"사용 예시\"></a>사용 예시</h3><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">struct TimesTable &#123;\n\tlet multiplier: Int &#x3D; 3\n\n\tsubscript(index: Int) -&gt; Int &#123;\n\t\treturn multiplier * index\n\t&#125;\n&#125;\n\nlet threeTimesTable &#x3D; TimesTable()\nprint(&quot;6에 3배를 하면 숫자 \\(threeTimesTable[6])이 나옵니다.&quot;) &#x2F;&#x2F; 18<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"타입-서브-스크립트-Type-Subscripts\"><a href=\"#타입-서브-스크립트-Type-Subscripts\" class=\"headerlink\" title=\"타입 서브 스크립트 (Type Subscripts)\"></a>타입 서브 스크립트 (Type Subscripts)</h2><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">enum Planet: Int &#123;\n\tcase mercury &#x3D; 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n\n\tstatic subscript(n: Int) -&gt; Planet &#123; &#x2F;&#x2F; or Planet 대신 Self\n\t\treturn Planet(rawValue.n)!\n\t&#125;\n&#125;\n\nlet mars &#x3D; Planet[4]\nprint(mars) &#x2F;&#x2F; mars<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h5><p>여기까지 이해했다면 이제  <code>Int</code>나 <code>String</code> 등의 타입의 구조를 이해할 수 있습니다.<br>이런 타입은 구조체로 구현되어 있습니다. 그리고 타입 메서드들을 사용하여 개발자들에게 사용할 수 있도록 제공하는 형태입니다.</p>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">struct Int &#123;\n\tstatic func random(in range: Range&lt;Int&gt;) -&gt; Int &#123; ... &#125;\n&#125;\n\nInt.random(1...10)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 구조체와 클래스의 메서드메서드의 메모리 동작 코드 영역에서 bori.sit()과 같은 접근연산자를 사용한 메서드를 마주친다. 스택 영역의 bori 변수에 찾아간다. bori 변수...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":80,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":80,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C\"><span class=\"toc-text\">구조체와 클래스의 메서드</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8F%99%EC%9E%91\"><span class=\"toc-text\">메서드의 메모리 동작</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%9E%A0%EA%B9%90\"><span class=\"toc-text\">잠깐!</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C-Instance-Methods\"><span class=\"toc-text\">인스턴스 메서드 (Instance Methods)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%9D%98-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C\"><span class=\"toc-text\">구조체의 인스턴스 메서드</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%9E%A0%EA%B9%90-1\"><span class=\"toc-text\">잠깐!</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9-Overloading\"><span class=\"toc-text\">오버로딩 (Overloading)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%83%80%EC%9E%85-%EB%A9%94%EC%84%9C%EB%93%9C-Type-Method\"><span class=\"toc-text\">타입 메서드 (Type Method)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%83%81%EC%86%8D\"><span class=\"toc-text\">클래스를 사용한 상속</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%84%9C%EB%B8%8C-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Subscripts\"><span class=\"toc-text\">서브 스크립트 (Subscripts)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C\"><span class=\"toc-text\">사용 예시</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%ED%83%80%EC%9E%85-%EC%84%9C%EB%B8%8C-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Type-Subscripts\"><span class=\"toc-text\">타입 서브 스크립트 (Type Subscripts)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%B0%B8%EA%B3%A0\"><span class=\"toc-text\">참고</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"25)🧰 Swift - 클래스(Class)의 상속","uid":"ed9964861ab21bcd20187bc915c28720","slug":"Allen/2022-10-01-Allen25","date":"2022-09-30T15:00:00.000Z","updated":"2023-03-31T10:33:38.122Z","comments":true,"path":"api/articles/Allen/2022-10-01-Allen25.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 클래스의 상속과 재정의클래스의 상속 (Inheritance)상속의 기본 개념 성격이 비슷한 타입을 새로 만들어 데이터(저장속성)를 추가하거나 기능(메서드)을 변형시켜 사용하는 것...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":80,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":80,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"24)🧰 Swift - 접근제어와 싱글턴","uid":"f43f96db698ca2fadca27d4600f204fb","slug":"Allen/2022-09-30-Allen24","date":"2022-09-29T15:00:00.000Z","updated":"2023-03-31T10:33:32.131Z","comments":true,"path":"api/articles/Allen/2022-09-30-Allen24.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 접근 제어 (Access Control)class SomeClass &#123; var name &#x3D; &quot;이름&quot; func nameChange(name: S...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":80,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":80,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}