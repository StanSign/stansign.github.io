{"title":"17)🧰 Swift - Collection","uid":"bc8ee1187329b643d5f24f6ff5a92ac2","slug":"Allen/2022-09-27-Allen17","date":"2022-09-26T15:00:00.000Z","updated":"2023-03-31T10:32:54.557Z","comments":true,"path":"api/articles/Allen/2022-09-27-Allen17.json","keywords":null,"cover":null,"content":"<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%A4%EC%BF%A8\">앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)</a></p>\n<h1 id=\"컬렉션-Collection\"><a href=\"#컬렉션-Collection\" class=\"headerlink\" title=\"컬렉션 (Collection)\"></a>컬렉션 (Collection)</h1><h2 id=\"스위프트의-컬렉션\"><a href=\"#스위프트의-컬렉션\" class=\"headerlink\" title=\"스위프트의 컬렉션\"></a>스위프트의 컬렉션</h2><ul>\n<li><strong>컬렉션</strong>: 여러개의 데이터를 한꺼번에 다루는 바구니 타입<ul>\n<li>데이터를 효율적으로 관리하기 위한 자료형(타입)****</li>\n<li>배열(Array), 딕셔너리(Dictionary), 세트(Set)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"배열-Array\"><a href=\"#배열-Array\" class=\"headerlink\" title=\"배열 (Array)\"></a>배열 (Array)</h3><ul>\n<li>데이터를 순서대로 저장하는 컬렉션</li>\n<li><code>let numsArray: Array&lt;Int&gt; = [1, 2, 3, 4, 5]</code><ul>\n<li><code>Array&lt;Int&gt;</code> &#x3D;&#x3D; <code>[Int]</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"배열의-규칙\"><a href=\"#배열의-규칙\" class=\"headerlink\" title=\"배열의 규칙\"></a>배열의 규칙</h4><ol>\n<li>배열의 인덱스는 0부터 자동으로 순서가 지정</li>\n<li>배열의 데이터는 중복 가능 (순서가 있기 때문에)</li>\n<li>한 개의 배열에는 동일한 데이터 타입만 담을 수 있음</li>\n</ol>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var numsArray &#x3D; [1, 2, 3, 4, 5]\nlet numsArray1 &#x3D; [20, 2, 6, 5, 9, 7, 6]\nvar stringArray &#x3D; [&quot;Apple&quot;, &quot;Swift&quot;, &quot;iOS&quot;, &quot;Cocoa&quot;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"배열의-타입-표기\"><a href=\"#배열의-타입-표기\" class=\"headerlink\" title=\"배열의 타입 표기\"></a>배열의 타입 표기</h4><ul>\n<li>정식 문법: <code>Array&lt;String&gt;</code></li>\n<li>단축 문법: <code>[String]</code></li>\n</ul>\n<h4 id=\"빈-배열의-생성\"><a href=\"#빈-배열의-생성\" class=\"headerlink\" title=\"빈 배열의 생성\"></a>빈 배열의 생성</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let emptyArray: [Int] &#x3D; []\nlet emptyArray2 &#x3D; Array&lt;Int&gt;() &#x2F;&#x2F; (): 생성자\nlet emptyArray3 &#x3D; [Int]()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"배열의-기본-기능\"><a href=\"#배열의-기본-기능\" class=\"headerlink\" title=\"배열의 기본 기능\"></a>배열의 기본 기능</h4><ul>\n<li><code>count</code>: 배열의 원소 개수</li>\n<li><code>isEmpty</code>: 배열이 비어있는가?</li>\n<li><code>contains([element])</code>: 파라미터로 받은 값을 지니는가?</li>\n<li><code>randomElement()</code>: 랜덤한 원소</li>\n<li><code>swapAt([index1], [index2])</code>: index1과 index2의 원소를 교환</li>\n</ul>\n<h4 id=\"배열의-각-요소에-대한-접근\"><a href=\"#배열의-각-요소에-대한-접근\" class=\"headerlink\" title=\"배열의 각 요소에 대한 접근\"></a>배열의 각 요소에 대한 접근</h4><ul>\n<li><code>[]</code>: 서브스크립트 문법</li>\n<li><strong>인덱스</strong>: 메모리 주소<ul>\n<li>배열의 시작 주소로부터 단위 공간만큼 얼마나 뒤의 주소인가?</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var numsArray: [Int] &#x3D; [1, 2, 3, 4, 5]\nprint(numsArray[0]) &#x2F;&#x2F; 1\nprint(numsArray[1]) &#x2F;&#x2F; 2\nprint(numsArray[2]) &#x2F;&#x2F; 3\nprint(numsArray[3]) &#x2F;&#x2F; 4\nprint(numsArray[4]) &#x2F;&#x2F; 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">print(numsArray.first) &#x2F;&#x2F; Optional(1) - 배열이 비어있을 수 있다.\nprint(numsArray.last) &#x2F;&#x2F; Optional(5)\nprint(numsArray.startIndex) &#x2F;&#x2F; 0\nprint(numsArray.endIndex) &#x2F;&#x2F; 5\nprint(numsArray[numsArray.endIndex - 1]) &#x2F;&#x2F; 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>5개의 원소를 갖는 배열<ul>\n<li>(n): 인덱스</li>\n<li><code>startIndex</code>(0) ◼️ (1) ◼️ (2) ◼️ (3) ◼️ (4) ◼️ <code>endIndex</code>(5)</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">numsArray.firstIndex(of: 3) &#x2F;&#x2F; 앞에서부터 찾았을 때 3이 처음 발견되는 인덱스\nnumsArray.lastIndex(of: 3) &#x2F;&#x2F; 뒤에서부터 찾았을 때 3이 처음 발견되는 인덱스\n&#x2F;&#x2F; 왜 있죠?\n&#x2F;&#x2F; 배열은 같은 값의 원소를 가질 수 있기 때문에!\n\nif let index &#x3D; numsArray.firstIndex(of: 2) &#123;\n\tprint(index)\n\tprint(numsArray[index])\n&#125;\n&#x2F;&#x2F; return 값이 Optional이기 때문에 if let을 활용하는 경우가 많다.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"배열-조물딱하기\"><a href=\"#배열-조물딱하기\" class=\"headerlink\" title=\"배열 조물딱하기\"></a>배열 조물딱하기</h4><h5 id=\"삽입-insert\"><a href=\"#삽입-insert\" class=\"headerlink\" title=\"삽입 (insert)\"></a>삽입 (insert)</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var alphabet &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]\nalphabet.insert(&quot;H&quot;, at: 0) &#x2F;&#x2F; index 0의 위치에(맨앞)\nalphabet.insert([&quot;H&quot;, &quot;I&quot;], at: 7) &#x2F;&#x2F; contentsOf: 는 사실 배열을 받는다.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"교체-replace\"><a href=\"#교체-replace\" class=\"headerlink\" title=\"교체 (replace)\"></a>교체 (replace)</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">alphabet[0] &#x3D; &quot;a&quot; &#x2F;&#x2F; 인덱스 0 자리의 원소를 교체\nalphabet[0...2] &#x3D; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] &#x2F;&#x2F; 범위 교체\n\nalphabet[0...1] &#x3D; [] &#x2F;&#x2F; 범위 삭제\n\nalphabet.replaceSubrange(0...2, with: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) &#x2F;&#x2F;  지원하는 함수 역시 당연히 있다.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"추가-append\"><a href=\"#추가-append\" class=\"headerlink\" title=\"추가 (append)\"></a>추가 (append)</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">alphabet.append(&quot;H&quot;) &#x2F;&#x2F; 마지막 끝에 추가\nalphabet.append(contentsOf: [&quot;H&quot;, &quot;I&quot;])\nalphabet.append(7) &#x2F;&#x2F; Error: TypeError<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"삭제-remove\"><a href=\"#삭제-remove\" class=\"headerlink\" title=\"삭제 (remove)\"></a>삭제 (remove)</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">alphabet[0...2] &#x3D; []\nalphabet.remove(at: 2) &#x2F;&#x2F; 인덱스 2 위치의 원소 삭제\nalphabet.removeSubrange(0...2) &#x2F;&#x2F; 인덱스 범위 0~2 위치의 원소 삭제\n\nalphabet.removeFirst() &#x2F;&#x2F; 맨 앞의 원소 삭제하고 삭제된 원소 return\nalphabet.removeFirst(2) &#x2F;&#x2F; 맨 앞의 두 원소 삭제하고 삭제된 원소들 return\nalphabet.removeLast() &#x2F;&#x2F; 맨 뒤의 원소 삭제하고 삭제된 원소 return\nalphabet.removeLast(2) &#x2F;&#x2F; 맨 뒤의 두 원소 삭제하고 삭제된 원소들 return\n\nalphabet.removeAll() &#x2F;&#x2F; 원소 전부 삭제\nalphabet.removeAll(keepingCapacity: true) &#x2F;&#x2F; 저장 공간을 일단은 보관 (데이터만 삭제)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"그외\"><a href=\"#그외\" class=\"headerlink\" title=\"그외\"></a>그외</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">alphabet.sort() &#x2F;&#x2F; 배열 자체를 정렬 (오름차순)\nalphabet.sorted() &#x2F;&#x2F; 정렬된 배열을 return (오름차순) - 원래의 배열을 변경하지는 않음\n\nalphabet.reverse() &#x2F;&#x2F; 배열을 거꾸로 정렬\nalphabet.reversed()\n\nalphabet.shuffle() &#x2F;&#x2F; 원소의 순서 랜덤하게 섞섞\nalphabet.shuffled()\n\nalphabet.sorted().reversed() &#x2F;&#x2F; 여러개 겹쳐서 사용 가능<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"배열의-비교\"><a href=\"#배열의-비교\" class=\"headerlink\" title=\"배열의 비교\"></a>배열의 비교</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let a &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]\nlet b &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n\na &#x3D;&#x3D; b &#x2F;&#x2F; false\na !&#x3D; b &#x2F;&#x2F; true<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"활용-예시\"><a href=\"#활용-예시\" class=\"headerlink\" title=\"활용 예시\"></a>활용 예시</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var puppy &#x3D; [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;]\n\nif let lastIndexOfP &#x3D; puppy.lastIndex(of: &quot;p&quot;) &#123;\n\tpuppy.remove(at: lastIndexOfP)\n&#125; &#x2F;&#x2F; 마지막 &quot;p&quot; 삭제\n\nif !puppy.isEmpty &#123;\n\tprint(&quot;\\(puppy.count) element(s)&quot;)\n&#125; else &#123;\n\tprint(&quot;Empty Array&quot;)\n&#125;\n\nvar data &#x3D; [[1, 2, 3],\n\t\t    [4, 5, 6],\n\t\t    [7, 8, 9]]\ndata[0][2] &#x2F;&#x2F; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"반복문과의-결합\"><a href=\"#반복문과의-결합\" class=\"headerlink\" title=\"반복문과의 결합\"></a>반복문과의 결합</h4><ul>\n<li>enumerate: 열거하다.<ul>\n<li><code>enumerated()</code>: 열거된 것들을 <code>named tuple</code> 형태로 한 개씩 전달</li>\n<li>index와 값을 차례대로 함께 꺼내서 사용할 일들이 있을 때 사용</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var nums &#x3D; [1, 2, 3, 4, 5, 6, 7]\n\nfor i in nums &#123;\n\tprint(i)\n&#125;\n\nfor tuple in nums.enumerated() &#123;\n\tprint(tuple) &#x2F;&#x2F; (offset: 0, element: 1), ...\n\tprint(&quot;\\(tuple.0) - \\(tuple.1)&quot;) &#x2F;&#x2F; &quot;0 - 1&quot;, ...\n&#125;\n\nfor (index, word) in nums.enumerated() &#123;\n\tprint(&quot;\\(index) - \\(word)&quot;) &#x2F;&#x2F; &quot;0 - 1&quot;, &quot;1 - 2&quot;, ...\n&#125;\n\nfor (index, word) in nums.enumerated().reversed() &#123;\n\tprint(&quot;\\(index) - \\(value)&quot;) &#x2F;&#x2F; &quot;6 - 7&quot;, &quot;5 - 6&quot;, ...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"딕셔너리-Dictionary\"><a href=\"#딕셔너리-Dictionary\" class=\"headerlink\" title=\"딕셔너리 (Dictionary)\"></a>딕셔너리 (Dictionary)</h3><ul>\n<li>데이터를 키와 값으로 하나의 쌍으로 만들어 관리하는 컬렉션<ul>\n<li>“키”: “값”</li>\n</ul>\n</li>\n<li><code>let dic: Dictionary&lt;String, String&gt; = [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;]</code></li>\n</ul>\n<h4 id=\"규칙\"><a href=\"#규칙\" class=\"headerlink\" title=\"규칙\"></a>규칙</h4><ul>\n<li>키 값은 유일해야함 (중복 불가능), 밸류값은 중복 가능</li>\n<li>동일한 타입의 쌍만 데이터로 담을 수 있음</li>\n<li>딕셔너리의 값에 딕셔너리&#x2F;배열을 사용하여 중첩적 사용 가능<ul>\n<li><code>[String: [String]]</code> ➡️ <code>[&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]]</code></li>\n</ul>\n</li>\n<li>딕셔너리의 키 값은 <strong>Hashable</strong> 해야함</li>\n</ul>\n<h4 id=\"Hash-x2F-HashValue-x2F-Hashable\"><a href=\"#Hash-x2F-HashValue-x2F-Hashable\" class=\"headerlink\" title=\"Hash &#x2F; HashValue &#x2F; Hashable\"></a>Hash &#x2F; HashValue &#x2F; Hashable</h4><ul>\n<li>Hash 함수: 고정된 길이의 숫자 or 글자이면서 유일한 값이 결과로 나온다.<ul>\n<li>ex) “steve”, “cook”, “musk”  ➡️ Hash Function ➡️ 1234, 8492, 3284</li>\n</ul>\n</li>\n<li>특정 입력에 대해서는 항상 출력(HashValue)가 같다.<ul>\n<li>다른 입력값으로는 해당 출력(HashValue)를 절대 얻지 못한다.</li>\n</ul>\n</li>\n<li>보통 <strong>Hash Table</strong>을 만들어 사용</li>\n</ul>\n<h5 id=\"HashTable과-딕셔너리\"><a href=\"#HashTable과-딕셔너리\" class=\"headerlink\" title=\"HashTable과 딕셔너리\"></a>HashTable과 딕셔너리</h5><ul>\n<li><code>contain</code>을 사용하면, 배열의 경우 모든 값을 확인한다.<ul>\n<li>속도가 매우 느림</li>\n</ul>\n</li>\n<li><strong>딕셔너리</strong>의 경우 <strong>HashTable</strong>을 사용하여 검색 속도가 빠르다.</li>\n</ul>\n<h5 id=\"Hashable\"><a href=\"#Hashable\" class=\"headerlink\" title=\"Hashable?\"></a>Hashable?</h5><ul>\n<li><p>Hash 함수에 input으로서 쓰일 수 있는 <strong>타입</strong></p>\n<ul>\n<li>Hashable 프로토콜 채택</li>\n<li>Swift의 기본 타입은 모두 Hashable</li>\n</ul>\n</li>\n<li><p>그래서 결론은</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>딕셔너리의 키 값은 Hashable 해야한다!</p></blockquote>\n</li>\n</ul>\n<h4 id=\"딕셔너리의-타입-표기\"><a href=\"#딕셔너리의-타입-표기\" class=\"headerlink\" title=\"딕셔너리의 타입 표기\"></a>딕셔너리의 타입 표기</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var words: [String: String] &#x3D; [:] &#x2F;&#x2F; 단축 문법\nlet words: Dictionary&lt;Int, String&gt; &#x2F;&#x2F; 정식 문법<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"빈-딕셔너리의-생성\"><a href=\"#빈-딕셔너리의-생성\" class=\"headerlink\" title=\"빈 딕셔너리의 생성\"></a>빈 딕셔너리의 생성</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let emptyDic1: Dictionary&lt;Int, String&gt; &#x3D; [:]\nlet emptyDic2 &#x3D; Dictionary&lt;Int, String&gt;()\nlet emptyDic3 &#x3D; [Int: String]()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"딕셔너리의-기본-기능\"><a href=\"#딕셔너리의-기본-기능\" class=\"headerlink\" title=\"딕셔너리의 기본 기능\"></a>딕셔너리의 기본 기능</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">dict &#x3D; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;, &quot;C&quot;: &quot;City&quot;]\n\ndict.count\ndict.isEmpty\n\ndict.randomElement()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"딕셔너리의-각-요소에-대한-접근\"><a href=\"#딕셔너리의-각-요소에-대한-접근\" class=\"headerlink\" title=\"딕셔너리의 각 요소에 대한 접근\"></a>딕셔너리의 각 요소에 대한 접근</h4><ul>\n<li>딕셔너리는 기본적으로 서브스크립트(<code>[]</code>)를 이용한 문법을 주로 사용한다.</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">dict &#x3D; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;, &quot;C&quot;: &quot;City&quot;]\nprint(dict[&quot;A&quot;]) &#x2F;&#x2F; Optional(&quot;Apple&quot;)\ndict[&quot;Q&quot;] &#x2F;&#x2F; nil일 가능성이 있다.\ndict[&quot;Q&quot;, default: &quot;Empty&quot;] &#x2F;&#x2F; String 타입 return, &quot;Empty&quot;\n\nprint(dict.keys) &#x2F;&#x2F; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] key만 묶어서\nprint(dict.values) &#x2F;&#x2F; [&quot;Apple&quot;, &quot;Banana&quot;, &quot;City&quot;] value만 묶어서<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"업데이트-update\"><a href=\"#업데이트-update\" class=\"headerlink\" title=\"업데이트 (update)\"></a>업데이트 (update)</h4><ul>\n<li>배열의 삽입, 교체, 추가 대신 <strong>업데이트</strong> 사용<ul>\n<li>딕셔너리는 순서가 없기 때문에 세분화할 필요가 없다.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">words &#x3D; [:]\nwords[&quot;A&quot;] &#x3D; &quot;Apple&quot;\nwords[&quot;B&quot;] &#x3D; &quot;Banana&quot;\nwords[&quot;B&quot;] &#x3D; &quot;Blue&quot;\nprint(words) &#x2F;&#x2F; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Blue&quot;]\n\nwords.updateValue(&quot;City&quot;, forKey: &quot;C&quot;)\n&#x2F;&#x2F; update를 하면서 새로운 값이 들어가면 nil return,\n&#x2F;&#x2F; 원래 있던 값을 교체할 때는 원래 있던 값을 return<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"삭제-remove-1\"><a href=\"#삭제-remove-1\" class=\"headerlink\" title=\"삭제 (remove)\"></a>삭제 (remove)</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">dict &#x3D; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;, &quot;C&quot;: &quot;City&quot;]\ndict[&quot;B&quot;] &#x3D; nil\ndict.removeValue(forKey: &quot;A&quot;)\ndict.removeAll()\ndict.removeAll(keepingCapacity: true)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"집합-Set\"><a href=\"#집합-Set\" class=\"headerlink\" title=\"집합 (Set)\"></a>집합 (Set)</h3><ul>\n<li>순서가 없는 컬렉션</li>\n<li><code>let set: Set&lt;Int&gt; = [1, 1, 2, 3]</code></li>\n</ul>\n<h4 id=\"규칙-1\"><a href=\"#규칙-1\" class=\"headerlink\" title=\"규칙\"></a>규칙</h4><ul>\n<li>생성 시 타입 선언</li>\n<li>중복된 원소를 넣어도, 중복 저장이 되지 않음<ul>\n<li>각 요소는 유일한 값 (Hashable)</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var set: Set &#x3D; [1, 1, 2, 3, 2, 2, 4, 3]\nprint(set) &#x2F;&#x2F; [2, 3, 1, 4]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"용도\"><a href=\"#용도\" class=\"headerlink\" title=\"용도\"></a>용도</h4><ul>\n<li>Hashable에 집중해야한다.</li>\n<li>정렬 순서보다 검색 속도가 더 중요할 때 사용</li>\n<li>집합의 수학적 개념을 이용할 필요가 있을 때<ul>\n<li>ex) 합집합, 차집합, 여집합, …</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"빈-Set의-생성\"><a href=\"#빈-Set의-생성\" class=\"headerlink\" title=\"빈 Set의 생성\"></a>빈 Set의 생성</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">let emptySet: Set&lt;Int&gt; &#x3D; []\nlet emptySet1 &#x3D; Set&lt;Int&gt;()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"Set의-기본-기능\"><a href=\"#Set의-기본-기능\" class=\"headerlink\" title=\"Set의 기본 기능\"></a>Set의 기본 기능</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">set.count\nset.isEmpty\n\nset.contains(1)\nset.randomElement()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"업데이트-update-1\"><a href=\"#업데이트-update-1\" class=\"headerlink\" title=\"업데이트 (update)\"></a>업데이트 (update)</h4><ul>\n<li>마찬가지로 순서가 없기 때문에 업데이트로 통합</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">set.update(with: 1)\nset.update(with: 7)\n&#x2F;&#x2F; update를 하면서 새로운 값이 들어가면 nil return,\n&#x2F;&#x2F; 원래 있던 값을 교체할 때는 원래 있던 값을 return<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"삭제-remove-2\"><a href=\"#삭제-remove-2\" class=\"headerlink\" title=\"삭제 (remove)\"></a>삭제 (remove)</h4><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var stringSet: Set&lt;String&gt; &#x3D; [&quot;Apple&quot;, &quot;Banana&quot;, &quot;City&quot;]\nstringSet.remove(&quot;Apple&quot;)\n&#x2F;&#x2F; 삭제할 값이 없으면 nil return\n&#x2F;&#x2F; 있다면 삭제한 원소를 return\nstringSet.removeAll()\nstringSet.removeAll(keepingCapacity: true)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"Set의-활용\"><a href=\"#Set의-활용\" class=\"headerlink\" title=\"Set의 활용\"></a>Set의 활용</h4><h5 id=\"부분집합-x2F-상위집합-x2F-서로소\"><a href=\"#부분집합-x2F-상위집합-x2F-서로소\" class=\"headerlink\" title=\"부분집합 &#x2F; 상위집합 &#x2F; 서로소\"></a>부분집합 &#x2F; 상위집합 &#x2F; 서로소</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\nb &#x3D; [1, 3, 5, 7, 9]\nc &#x3D; [2, 4, 6, 8, 10]\nd &#x3D; [1, 7, 5, 9, 3]\n\nb.isSubset(of: a) &#x2F;&#x2F; 부분집합인가? true\nb.isStrictSubset(of: a) &#x2F;&#x2F; 진부분집합인가? false\n\na.isSuperset(of: b) &#x2F;&#x2F; 상위집합인가? true\na.isStrictSuperset(of: b) &#x2F;&#x2F; 진상위집합인가? false\n\nd.isDisjoint(with: c) &#x2F;&#x2F; 서로소인가? true<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"합집합\"><a href=\"#합집합\" class=\"headerlink\" title=\"합집합\"></a>합집합</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var unionSet &#x3D; b.union(c)\nb.formUnion(c) &#x2F;&#x2F; 원본 변경<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h5 id=\"교집합\"><a href=\"#교집합\" class=\"headerlink\" title=\"교집합\"></a>교집합</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var interSet &#x3D; a.intersection(b)\na.formIntersection(b) &#x2F;&#x2F; 원본 변경<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h5 id=\"차집합\"><a href=\"#차집합\" class=\"headerlink\" title=\"차집합\"></a>차집합</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var subSet &#x3D; a.subtracting(b)\na.subtract(b) &#x2F;&#x2F; 원본 변경<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h5 id=\"대칭차집합\"><a href=\"#대칭차집합\" class=\"headerlink\" title=\"대칭차집합\"></a>대칭차집합</h5><pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var symmetricSet &#x3D; a.symmetricDifference(b)\na.formSymmetricDifference(b) &#x2F;&#x2F; 원본 변경<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h5 id=\"유의점\"><a href=\"#유의점\" class=\"headerlink\" title=\"유의점\"></a>유의점</h5><ul>\n<li>Set에  <code>sorted</code>를 사용할 수 있다.<ul>\n<li>하지만 <code>return</code> 값의 타입은 <code>Array</code>이다.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-Swift\" data-language=\"Swift\"><code class=\"language-Swift\">var newArray: Array &#x3D; newSet.sorted()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"KeyValuePairs\"><a href=\"#KeyValuePairs\" class=\"headerlink\" title=\"KeyValuePairs\"></a>KeyValuePairs</h3><ul>\n<li>딕셔너리와 유사한 형태이지만 배열처럼 순서가 있는 컬렉션</li>\n<li>Swift 5.2에 새롭게 등장한 컬렉션</li>\n<li>key 값이 Hashable하지 안하도 됨</li>\n<li>key 값이 동일한 것도 가능</li>\n<li><code>let introduct: KeyValuePairs = [&quot;first: &quot;Hellow&quot;, &quot;second&quot;: &quot;My Name&quot;, &quot;third&quot;: &quot;is&quot;]</code></li>\n</ul>\n<p>그렇게 많이 사용되지는 않고 있기 때문에 이런게 있다 정도만 알고 넘어갑시다!</p>\n","text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 컬렉션 (Collection)스위프트의 컬렉션 컬렉션: 여러개의 데이터를 한꺼번에 다루는 바구니 타입 데이터를 효율적으로 관리하기 위한 자료형(타입)**** 배열(Array), ...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EC%BB%AC%EB%A0%89%EC%85%98-Collection\"><span class=\"toc-text\">컬렉션 (Collection)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8%EC%9D%98-%EC%BB%AC%EB%A0%89%EC%85%98\"><span class=\"toc-text\">스위프트의 컬렉션</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%B0%B0%EC%97%B4-Array\"><span class=\"toc-text\">배열 (Array)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EA%B7%9C%EC%B9%99\"><span class=\"toc-text\">배열의 규칙</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%83%80%EC%9E%85-%ED%91%9C%EA%B8%B0\"><span class=\"toc-text\">배열의 타입 표기</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B9%88-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%83%9D%EC%84%B1\"><span class=\"toc-text\">빈 배열의 생성</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5\"><span class=\"toc-text\">배열의 기본 기능</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EA%B0%81-%EC%9A%94%EC%86%8C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%91%EA%B7%BC\"><span class=\"toc-text\">배열의 각 요소에 대한 접근</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B0%B0%EC%97%B4-%EC%A1%B0%EB%AC%BC%EB%94%B1%ED%95%98%EA%B8%B0\"><span class=\"toc-text\">배열 조물딱하기</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%82%BD%EC%9E%85-insert\"><span class=\"toc-text\">삽입 (insert)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EA%B5%90%EC%B2%B4-replace\"><span class=\"toc-text\">교체 (replace)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%B6%94%EA%B0%80-append\"><span class=\"toc-text\">추가 (append)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%82%AD%EC%A0%9C-remove\"><span class=\"toc-text\">삭제 (remove)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EA%B7%B8%EC%99%B8\"><span class=\"toc-text\">그외</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EB%B9%84%EA%B5%90\"><span class=\"toc-text\">배열의 비교</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%ED%99%9C%EC%9A%A9-%EC%98%88%EC%8B%9C\"><span class=\"toc-text\">활용 예시</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B0%98%EB%B3%B5%EB%AC%B8%EA%B3%BC%EC%9D%98-%EA%B2%B0%ED%95%A9\"><span class=\"toc-text\">반복문과의 결합</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionary\"><span class=\"toc-text\">딕셔너리 (Dictionary)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EA%B7%9C%EC%B9%99\"><span class=\"toc-text\">규칙</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Hash-x2F-HashValue-x2F-Hashable\"><span class=\"toc-text\">Hash &#x2F; HashValue &#x2F; Hashable</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#HashTable%EA%B3%BC-%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC\"><span class=\"toc-text\">HashTable과 딕셔너리</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Hashable\"><span class=\"toc-text\">Hashable?</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%EC%9D%98-%ED%83%80%EC%9E%85-%ED%91%9C%EA%B8%B0\"><span class=\"toc-text\">딕셔너리의 타입 표기</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B9%88-%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%EC%9D%98-%EC%83%9D%EC%84%B1\"><span class=\"toc-text\">빈 딕셔너리의 생성</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5\"><span class=\"toc-text\">딕셔너리의 기본 기능</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC%EC%9D%98-%EA%B0%81-%EC%9A%94%EC%86%8C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%91%EA%B7%BC\"><span class=\"toc-text\">딕셔너리의 각 요소에 대한 접근</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-update\"><span class=\"toc-text\">업데이트 (update)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%82%AD%EC%A0%9C-remove-1\"><span class=\"toc-text\">삭제 (remove)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%A7%91%ED%95%A9-Set\"><span class=\"toc-text\">집합 (Set)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EA%B7%9C%EC%B9%99-1\"><span class=\"toc-text\">규칙</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%9A%A9%EB%8F%84\"><span class=\"toc-text\">용도</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EB%B9%88-Set%EC%9D%98-%EC%83%9D%EC%84%B1\"><span class=\"toc-text\">빈 Set의 생성</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Set%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5\"><span class=\"toc-text\">Set의 기본 기능</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-update-1\"><span class=\"toc-text\">업데이트 (update)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EC%82%AD%EC%A0%9C-remove-2\"><span class=\"toc-text\">삭제 (remove)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Set%EC%9D%98-%ED%99%9C%EC%9A%A9\"><span class=\"toc-text\">Set의 활용</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EB%B6%80%EB%B6%84%EC%A7%91%ED%95%A9-x2F-%EC%83%81%EC%9C%84%EC%A7%91%ED%95%A9-x2F-%EC%84%9C%EB%A1%9C%EC%86%8C\"><span class=\"toc-text\">부분집합 &#x2F; 상위집합 &#x2F; 서로소</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%ED%95%A9%EC%A7%91%ED%95%A9\"><span class=\"toc-text\">합집합</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EA%B5%90%EC%A7%91%ED%95%A9\"><span class=\"toc-text\">교집합</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%B0%A8%EC%A7%91%ED%95%A9\"><span class=\"toc-text\">차집합</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EB%8C%80%EC%B9%AD%EC%B0%A8%EC%A7%91%ED%95%A9\"><span class=\"toc-text\">대칭차집합</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%EC%9C%A0%EC%9D%98%EC%A0%90\"><span class=\"toc-text\">유의점</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#KeyValuePairs\"><span class=\"toc-text\">KeyValuePairs</span></a></li></ol></li></ol></li></ol>","author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}},"mapped":true,"prev_post":{"title":"16)🧰 Swift - Optional","uid":"678abc472084fa82fc126653c5a66c11","slug":"Allen/2022-09-27-Allen16","date":"2022-09-26T15:00:00.000Z","updated":"2023-03-31T10:32:50.129Z","comments":true,"path":"api/articles/Allen/2022-09-27-Allen16.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 옵셔널 (Optional)우선 옵셔널 타입의 필요성을 느껴보기 위해 다음과 같은 상황을 살펴봅시다. var yourName: String print(yourName) 위의 코드를...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}},"next_post":{"title":"9)🧰 Swift - 반복문","uid":"989a634ef691c286f5536c37d3f65d2d","slug":"Allen/2022-09-26-Allen09","date":"2022-09-25T15:00:00.000Z","updated":"2023-03-31T10:32:16.415Z","comments":true,"path":"api/articles/Allen/2022-09-26-Allen09.json","keywords":null,"cover":null,"text":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정) 반복문for문 특정 조건을 만족하는 동안 반복 for [item] in [범위 / 컬렉션] &#123; [반복될 코드] &#125; for index in 1...5 &#123;...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"AllenBootCamp","slug":"AllenBootCamp","count":45,"path":"api/categories/AllenBootCamp.json"}],"tags":[{"name":"Swift","slug":"Swift","count":78,"path":"api/tags/Swift.json"},{"name":"iOS","slug":"iOS","count":78,"path":"api/tags/iOS.json"},{"name":"Allen","slug":"Allen","count":45,"path":"api/tags/Allen.json"}],"author":{"name":"nomatterjun","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/60438045?v=4","link":"/","description":"안녕하세요 👋 <br/> 바쁜 현대인들의 일상에 <br/> 작은 변화를 심고 싶은 개발자 <br/> 이창준입니다.","socials":{"github":"https://github.com/nomatterjun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"instagram":{"icon":"/assets/instagram.svg","link":"https://www.instagram.com/nomatter_jun/"}}}}}}