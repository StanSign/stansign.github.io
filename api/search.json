[{"id":"3109988ad89a1ccaa9db523d69ee2dd9","title":"31)🍎 Swift - Sign in with Apple","content":"Swift - Sign in with Apple오늘은 애플로 로그인을 구현해볼겁니다!\n바로 가볼까요~\nHIG애플로 로그인은 애플의 SDK를 사용하는 것이니 애플이 제시한 디자인 가이드를 잘 따라주어야 합니다. Sign in with Apple에 대한 HIG 문서는 여기에 있습니다.\nOffering Sign in with Apple애플로 로그인을 구현하면서 다음과 같은 점들을 따라야 합니다.\n\n로그인을 함으로써 사용자가 이득을 얻을 수 있는 경우에만 애플로 로그인을 제공할 것\n로그인의 시점을 미룰 수 있다면 최대한 미룰 것\n가입이 필요하다면 가입 이후에 SDK 로그인을 선택할 수 있도록 할 것\n기존에 사용하던 애플로 로그인에 연결될 수 있도록 구현할 것\n커머스 앱일 경우, 물품을 실제로 구매하기 직전에 로그인을 요구할 것\n애플로 로그인이 성공함과 동시에 사용자가 계정을 사용할 수 있는 화면으로 반겨줄 것\n애플로 로그인되어 있다는 사실을 안내할 것\n\n중요한 점은 사용자들이 가입을 하는 것을 원하지는 않으니, 가입이 필요한 이유를 설명 하고 응당하는 가치를 제공 해야 한다. 로그인 시점은 최대한 늦추는 것 이 좋고 이전&#x2F;다른 기기에서 사용하던 계정과의 연동 이 이루어져야 한다.\nCollecting Data애플로 로그인을 이용하면 사용자의 이름과 이메일 주소를 제공받을 수 있습니다.하지만 경우에 따라 추가적인 정보가 필요할 때가 있겠죠. (생일이나 거주지 같은)이럴 때를 위한 가이드라인도 제공하고 있습니다.\n\n부가 제공 정보가 필수적인지, 권장인지를 명확하게 전달할 것\n사용자가 직접 비밀번호를 입력하게 하지 말 것\n사용자가 이메일 가리기 옵션을 제공할 경우, 실제 이메일 주소를 요구하지 말 것\n부가적인 정보를 요구하기 전에 앱을 사용해 볼 수 있도록 할 것\n데이터 수집에 대해 투명할 것\n\n사실 대부분 도의적으로 알고 있는 부분들이죠?4번의 경우가 눈에 띄는데, “일단 둘러보기” 옵션이 상용 앱에 점점 많아지는 이유가 아닐까 싶습니다.\nDisplaying Buttons자 이제 실제로 어떤 디자인을 요구하는 지 살펴볼까요..\n애플로 로그인은 애플이 제공하는 컴포넌트를 사용하는 것이 가장 쉽고 좋은 방법입니다.\n\n이 모양의 버튼 여기저기서 많이 보셨잖아요? 😋하지만 앱의 기획이나 디자인에 따라 다른 형태로 사용하고 싶을 때도 있겠죠?애플이 제공하는 가이드라인만 따른다면, 커스텀으로 제작하는 것도 가능합니다.\n\n다른 로그인 옵션들과 동일한 사이즈를 가질 것\n로그인 버튼을 찾기위해 유저가 스크롤할 일이 없을 것\n\n이 두가지 핵심 가이드라인을 생각하며 세부 내용들을 살펴봅시다.\n커스텀 애플로 로그인 버튼에서 가장 중요한 점은 당연하게도 해당 버튼이 “애플로 로그인” 기능을 한다는 것을 명시 해주는 것입니다.애플이 제공하는 버튼과 같이 “애플로 로그인” 타이포와 로고를 함께 넣거나, 애플 로고 단일의 버튼을 넣는 식으로 말이죠.참고로 애플이 제공하는 디자인 리소스(애플 로고와 같은)들은 여기서 얻을 수 있답니다.\n애플 로고를 사용하는 만큼 가이드라인도 굉장히 많습니다..브랜드가 직접적으로 노출되는 버튼인만큼 브랜드에 대한 통일성을 지키기 위해서겠죠?찬찬히 읽어보면서 그렇구나~ 정도로 봐도 괜찮을 것 같습니다.\n\n로고\n로고 자체를 버튼으로 쓰지말고, 버튼 안에 로고가 포함되는 형태로 구성할 것\n버튼의 높이와 로고의 높이를 동일하게 설정할 것\n로고 파일을 잘라서 사용하지 말 것\n상하단에 패딩을 추가하지 말 것\n\n버튼 속성\n버튼 타이틀은 “Sign in with Apple”, “Sign up with Apple”, “Continue with Apple”만 사용할 것\n로고와 텍스트가 포함된 버튼은 항상 사각형의 형태를 유지하고, 로고만 있는 버튼은 사각형이나 원형일 것\n로고와 타이틀 색상은 검정 혹은 흰색일 것 (커스텀 컬러 사용 금지)\n타이틀 폰트는 변경이 가능 (weight와 size 포함)\n대문자 자율적으로 사용 가능 (모든 글자를 대문자로 하는 것도 가능)\n배경 형태(질감, 그래디언트)는 앱에 맞게 변형 가능 (단 흰색, 검정 색상은 유지할 것)\nCorner Radius는 다른 버튼들에 맞게 변경 가능\n테두리와 그림자도 다른 버튼들에 맞게 변경 가능\n\nImplementing Sign in with Apple자 이제 디자인적으로 고려해야할 점들은 알았으니 실제로 앱에 적용해봅시다.\nCapability 추가\n앱 환경 설정의 Signing &amp; Capabilities 탭에서 “+ Capability” 버튼을 통해 Sign in with Apple을 추가해줍니다.그리고 Apple Developer의 Certificates, Identifiers &amp; Profiles에서 애플로 로그인을 추가해줄 앱의 Identifier에 찾아들어갑시다.\n\n그리고 이렇게 프로젝트 설정과 동일하게 “Sign in with Apple” Capability를 켜줍니다.\n\n환경 설정은 보통 여기서 끝나지만..저의 경우에는 깃허브 액션을 사용하고 있어서 프로비저닝을 자동으로 관리해주는 옵션을 꺼두었기 때문에 직접 추가해주어야 합니다.\nApp ID에 Capability를 켜준 뒤에 Profiles 탭에서 업데이트된 프로비전 파일을 다운받아줍니다.\n \n다운로드한 프로비전 파일을 import하고 정상적으로 적용이 됐다면..! 로컬에서는 세팅이 끝난겁니다.저와 같이 깃허브 액션에 프로비전을 등록해두신 분들은 암호화 &amp; 업로드도 다시 해야한다는 것을 잊지 말아주세요!\nAdd a Sign in with Apple Button자 이제 진짜 진짜 구현에 들어갑시다.\n우선 필요한 프레임워크를 import 해줍니다.\nimport AuthenticationServices\n\n애플로 로그인을 트리거해줄 버튼부터 만들어야겠죠?애플이 기본적으로 제공하는 컴포넌트를 사용한다면, ASAuthorizationAppleIDButton을 사용해줍시다.\nfunc setupProviderLoginView() &#123;\n  let authorizationButton = ASAuthorizationAppleIDButton()\n  authorizationButton.addTarget(self, action: #selector(handleAuthorizationAppleIDButtonPress), for: .touchUpInside)\n  self.loginProviderStackView.addArrangedSubview(authorizationButton)\n&#125;\n\n\n저는 디자이너님이 만들어주신 이 커스텀 버튼을 사용해볼게요!#selector 에 들어가는 메서드의 기능만 동일하면 되니 기본 컴포넌트나 커스텀 버튼이나 동일하게 진행해줍시다.\nRequest Authorization with Apple ID이제 버튼의 액션에 해당되는 handleAuthorizationiAppleIDButtonPress() 메서드를 구현해봅시다.\nfunc handleSignInWithApple() &#123;\n  let provider = ASAuthorizationAppleIDProvider()\n  let request = provider.createRequest()\n  request.requestedScopes = [.fullName, .email]\n\n  let authorizationController = ASAuthorizationController(authorizationRequests: [request])\n  authorizationController.delegate = self\n  authorizationController.presentationContextProvider = self\n  authorizationController.performRequests()\n&#125;\n\n일단 Provider 인스턴스를 생성해주고, 리퀘스트를 보내야 하기 때문에 createRequest() 와 요구하는 Scope를 설정해줍니다.\nextension ASAuthorization.Scope &#123;\n  @available(iOS 13.0, *)\n  public static let fullName: ASAuthorization.Scope\n\n  @available(iOS 13.0, *)\n  public static let email: ASAuthorization.Scope\n&#125;\n\n사실 Scope라고 해봐야 두 개가 전부입니다. 😅저희는 이메일과 이름 둘 다 필요하기 때문에 두 개 모두 요구 Scope에 추가해주었습니다.\nrequest 세팅이 끝났다면, ASAuthorizationController 인스턴스의 delegate 와 presentationContextProvider 의 위임자를 설정해주고 performRequests 로 실제 리퀘스트를 보내줍니다.\n\n\n\n\n\n\n\n\n\nASAuthorizationControllerDelegate 채택 관련 트러블!\n자.. 그런데 위임자를 설정해줄 때 분명 애플이\n\n이 두 가지 함수를 구현해주어야 한다고 했거든요..?\n\n저는 근데 왜 이런 애들이 나올까요…\n조금 찾아보니 이 친구들은 NSObjectProtocol 이라는 프로토콜에 필요한 요소들이였습니다.\n@available(iOS 13.0, *)\npublic protocol ASAuthorizationControllerDelegate : NSObjectProtocol &#123;\n  optional func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization)\n\n  optional func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error)\n&#125;\n\nASAuthorizationControllerDelegate 가 NSObjectProtocol 을 채택하고 있거든요.\n\n공식 문서에서 Obj-C 오브젝트들에 모두 필요한 프로토콜이라고 합니다.그래서 문제는.. 저는 Reactor 라는 커스텀 레이어 위에서 작업하고 있었다는 것이죠.. Reactor 는 NSObjectProtocol 을 채택하고 있지 않거든요..! 😠그래서 이 로직을 어디서 구현해줘야 하느냐..?어디겠어요 뷰컨트롤러죠..UIViewController 는 NSObject 의 서브클래스이고, NSObject 가 NSObjectProtocol 을 채택하고 있습니다..\n깨알같이 didCompleteWithAuthorization 과 didCompleteWithError 메서드는 optional 이였네요..그래서 XCode가 제안하는 프로토콜 충족 기능으로는 추가가 안됐던 것입니다..! 😅\nextension AuthSignInViewController: ASAuthorizationControllerDelegate, ASAuthorizationControllerPresentationContextProviding &#123;\n  public func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor &#123;\n    return self.view.window!\n  &#125;\n\n  func handleSigninWithApple() &#123;\n    let provider = ASAuthorizationAppleIDProvider()\n    let request = provider.createRequest()\n    request.requestedScopes = [.fullName, .email]\n\n    let authorizationController = ASAuthorizationController(authorizationRequests: [request])\n    authorizationController.delegate = self\n    authorizationController.presentationContextProvider = self\n    authorizationController.performRequests()\n  &#125;\n&#125;\n\n그래서 이렇게 뷰컨으로 로직들을 옮겨주고 이어서 작업해보겠습니다.\n먼저 필수적으로 충족해야하는 ASAuthorizationControllerPresentationContextProviding 프로토콜의 presentationAnchor 메서드부터 구현해줍니다.\n애플로 로그인이 수행되기 위한 UIWindow 를 받기 위한 간단한 메서드라서 현재 뷰컨의 윈도우를 제공해주는 것으로 간단하게 구현해줍시다.\n여기까지 됐다면 애플로 로그인 버튼을 눌렀을 때, 애플로 로그인 화면이 나와야합니다.\n과연…!\n\n앗.. 🫣애플 로그인 해주고요.. 다시..\n\n오..! 됐어요 됐어요 🎉\nHandle User Credentials이제 사용자가 로그인을 했을 때 실제로 받게 되는 값을 앱에서 처리해줘야 합니다.\n로그인이 성공했을 때 호출되는 didCompleteWithAuthroization delegate 함수부터 구현해줍시다.이 함수에서는 제공되는 userIdentifier, fullName, email 의 값을 사용해 앱에서 사용되는 계정 을 등록해주어야 합니다.쉽게 말해서 제공되는 데이터를 사용해 회원가입 절차를 통과시켜주어야 한다는 것이죠.\n애플이 제공하는 예시에서는 AppleIDCredential 과 ASPasswordCredential 의 두 가지 방법을 제시하고 있습니다.여기서 ASPasswordCredential 은 iCloud에 비밀번호를 연동할 때 사용되는 Credential이기 때문에 제외하고 사용하였습니다.\npublic func authorizationController(\n  controller: ASAuthorizationController,\n  didCompleteWithAuthorization authorization: ASAuthorization\n) &#123;\n  guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else &#123; return &#125;\n\n  let userIdentifier = appleIDCredential.user\n  let fullName = appleIDCredential.fullName\n  let email = appleIDCredential.email\n\n  // Handle Sign Up Task\n  \n&#125;\n\n자 이렇게 AppleIDCredential을 이용해서 사용자에 대한 정보를 받아올 수 있습니다.이 데이터들을 어떻게 사용해서 회원가입을 시킬 지.. 는 앱과 서버의 환경마다 다르겠죠..?\n애플 로그인이 실패하는 경우에는 didCompleteWithError 함수가 호출됩니다.\npublic func authorizationController(\n  controller: ASAuthorizationController,\n  didCompleteWithError error: Error\n) &#123;\n  // Handle Error\n  print(error)\n&#125;\n\nRequest Existing Credentials위의 경우는 애플 로그인을 이용해 “처음” 가입할 때의 경우였습니다.그런데 로그아웃이나 앱을 삭제 한 뒤 다시 설치해서 로그인을 할 때는요?이전의 계정 정보들을 그대로 사용할 수 있어야겠죠!\n그럴 때는 한 번 가입했던 애플 로그인에 다시 한 번 로그인하는 로직이 필요합니다.\n근데요.. 사실 이전에 구현했던 handleSignInWithApple() 함수와 상당히 유사하게 구현할 수 있습니다.\nfunc handleSignInWithApple() &#123;\n  let provider = ASAuthorizationAppleIDProvider()\n  let request = provider.createRequest()\n\n  let authorizationController = ASAuthorizationController(authorizationRequests: [request])\n  authorizationController.delegate = self\n  authorizationController.presentationContextProvider = self\n  authorizationController.performRequests()\n&#125;\n\n\n\n\n\n\n\n\n\n\nKeychain &#x2F; iCloud PW와 관련하여 추가 학습 중\nCheck User Credentials at Launch이제 애플 로그인을 다 구현했으니 자동 로그인도 구현해봅시다.\n앱의 시작 구간에서 (보통 AppDelegate나 SceneDelegate겠죠?) getCredentialState(forUserID:completion:) 함수를 사용해 사용자의 애플 아이디와 앱의 연동 상황을 체크할 수 있습니다.\n// AppDelegate.swift\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool &#123;\n\n  let appleIDProvider = ASAuthorizationAppleIDProvider()\n  appleIDProvider.getCredentialState(forUserID: KeychainItem.currentUserIdentifier) &#123; (credentialState, error) in\n    switch credentialState &#123;\n    case .authorized:\n      break // The Apple ID credential is valid.\n    case .revoked, .notFound:\n      // The Apple ID credential is either revoked or was not found, so show the sign-in UI.\n      DispatchQueue.main.async &#123;\n        self.window?.rootViewController?.showLoginViewController()\n      &#125;\n    default:\n      break\n    &#125;\n  &#125;\n  return true\n&#125;\n\n\n\n\n\n\n\n\n\n\n흠.. getCredentialState 에 애플 아이디가 필요하네요..?\n제가 원래 AppleIDCredential 중 userIdentifier 는 사용하지 않으려고 했었는데.. 여기서 필요하네요..?그래서 해당 아이디를 키체인으로 저장해두는 로직이 추가적으로 필요할 것 같습니다.\n해당 내용까지 적용 후에 마저 글을 작성해보도록 하겠습니다.. 🥲\n\n\n\n\n\n\n\n\n\n참고 문서\nApple Developer - Implementing User Authentication with Sign in with Apple\nWWDC19 - Introducing Sign in with Apple\n","slug":"Swift/2023-06-21-Swift31","date":"2023-06-20T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"358b9ce668b5d19c091a8d1511c207a6","title":"03)🎊 WWDC23 - SwiftData","content":"WWDC23 - SwiftData오늘은 SwiftData를 알아볼거에요Widget에다 써먹어야되거든요 😄\n저는 일단 CoreData를 써본 적이 없습니다.아마 조만간 쓸 것 같기는 한데.. 일단은 없어요..왜 안썼냐면요.. 슬쩍 봐도 파일이 너무 여기저기 분산되게 되는 것 같더라구요..전용의 파일 형식도 있고 말이죠…?그래서 대신 Realm을 자주 썼었습니다.\n그런데.. SwiftData가 새로 나왔어요!iOS 17부터 지원해서 실무에서는 4~5년 뒤에나 쓰게 될 것 같지만 나온게 어딘가요 😂일단 Schema를 정의해주는 과정부터 너무 간단합니다.\n출발해보죠!\nUsing the Model MacroSwiftData의 Schema 는 일반 클래스에 @Model 매크로 를 붙여주는 것으로 끝입니다.\nimport SwiftData\n\n@Model\nclass Trip &#123;\n  var name: String\n  var destination: String\n  var endDate: Date\n  var startDate: Date\n\n  var bucketList: [BucketListItem]? = []\n  var livingAccommodation: LivingAccommodation?\n&#125;\n\n너무 쉽고 간단하죠..?\n@Model 매크로는 클래스 내부의 Stored Property 들을 Persisted Property 로 바꿔줍니다.\n사용할 수 있는 타입들은 이렇습니다.\n\n기본적인 Value Types (Int, String, …)\nstruct\nenum\nCodable\n[ANY VALUE TYPE]\n\n다른 @Model 클래스를 참조하는 것으로 관계 구조를 형성할 수도 있습니다.\n\n[BucketListItem]? 와 같은..\n\n\n\n\n\n\n\n\n\n\nSwiftData 클래스와 실제 사용되는 클래스는 동일한가요?\n개인적으로 가장 궁금한 점이였습니다.\npublic protocol Storable &#123;\n  associatedtype RealmObject: RealmSwift.Object\n  associatedtype PropertyValue: PropertyValueType\n\n  /// 데이터 모델의 식별자로 사용되는 프로퍼티\n  var identifier: Int &#123; get &#125;\n\n  init(realmObject: RealmObject)\n  func realmObject() -> RealmObject\n&#125;\n\nRealm을 사용하다보니 DB에서 사용하는 Data 구조체와 실제로 사용되는 도메인 형태의 구조체는 다른 구조체를 사용하곤 했거든요..(보통 멀티 쓰레딩의 과정에서 문제들이 발생했습니다.)\n하지만 SwiftData는 저희가 원래 사용하던 코드와 별 차이가 없도록 애플이 노력했기 때문에 Model 클래스를 직접적으로 UI 레이어 등에서 사용할 수 있다 고 합니다.\n\n@Attribute 와 @Relationship 으로 프로퍼티에 추가적인 제어를 할 수 있습니다.\n@Attribute@Attribute(.unique) var name: String\n\n@Attribute(.unique) 로 PK를 설정해줄 수 있습니다. PK로 설정된 프로퍼티와 같은 값을 가진 모델이 Create에 대응되는 insert()로 인해 추가될 때 Update에 대응되는 upsert()로 전환되는 효과를 가집니다.\n@Attribute(originalName: \"start_date\") var startDate: Date\n\n@Attribute(originalName) 으로는 Migration이 가능합니다. 프로퍼티의 이름은 바꾸고 싶지만 데이터는 그대로 남겨두고 싶을 때 사용할 수 있습니다.\n그 외에도\n\n외부 대용량 데이터 사용\nTransformable\nSpotlight\nHash 수정등의 작업이 가능하다고 하네요.\n\n@Relationship각 모델간 Relationship이 설정되어 있을 때, 삭제 정책의 기본값은 Nullify 입니다.\n예시로 살펴보면 Trip이 삭제됐을때, BucketListItem과 LivingAccommodation의 Inverse Relationship으로 등록되어 있던 trip이라는 프로퍼티가 NULL이 되는 것이죠.\n하지만 .cascade 정책으로 Nullify 대신 함께 삭제 되도록 할 수도 있습니다.\n@Relationship(.cascade) var bucketList: [BucketListItem]? = []\n\n\noriginalName\ntoMany Relationship일 때의 개수 제한\nHash 수정\n\n@Transient@Transient var tripViews: Int = 0\n\n@Transient 매크로를 사용하면 해당 프로퍼티가 SwiftData로 쓰이는 것을 막을 수도 있습니다.\n대신 해당 프로퍼티는 기본값 을 꼭 가져야만 합니다.\nEvolving Schemas앱을 개발하거나 상용화를 한 이후에도 DB의 구조는 언제든지 바뀔 수 있습니다.\n때문에 Migration은 필수적인 요건이죠.\nSwiftData도 VersionedSchema와 SchemaMigrationPlan을 통해 이를 지원합니다.\nenum SampleTripSchemaV1: VersionedSchema &#123;\n  static var models: [any PersistentModel.Type] &#123;\n    [Trip.self, BucketListItem.self, LivingAccommodation.self]\n  &#125;\n\n  @Model\n  final class Trip &#123;\n    var name: String\n    var destination: String\n    var start_date: Date\n    var end_date: Date\n\n    var bucketList: [BucketListItem]? = []\n    var livingAccommodation: LivingAccommodation?\n&#125;\n\nenum SampleTripSchemaV2: VersionedSchema &#123;\n  static var models: [any PersistentModel.Type] &#123;\n    [Trip.self, BucketListItem.self, LivingAccommodation.self]\n  &#125;\n\n  @Model\n  final class Trip &#123;\n    @Attribute(.unique) var name: String\n    var destination: String\n    @Attribute(originalName: \"srart_date\") var startDate: Date\n    @Attribute(originalName: \"end_date\") var endDate: Date\n\n    var bucketList: [BucketListItem]? = []\n    var livingAccommodation: LivingAccommodation?\n&#125;\n\nSchemaMigrationPlan으로는 이렇게 바꾼 데이터들을 어떤 순서대로 변경할지 등의 세부적인 사항들을 정할 수 있습니다.\nenum SampleTripsMigrationPlan: SchemaMigrationPlan &#123;\n  static var schemas: [any VersionedSchema.Type) &#123;\n    [SampleTripsSchemaV1.self, SampletripsSchemaV2.self, SampleTripSchemaV3.self]\n\n  static var stages: [MigrationStage] &#123;\n    [migrateV1toV2]\n  &#125;\n\n  static let migrateV1toV2 = MigrationStage.custom(\n    fromVersion: SampleTripSchemaV1.self\n    toVersion: SampleTripSchema2.self    ,\n    willMigrate: &#123; context in\n      let trips = try? context.fetch(FetchDescriptor&lt;SampleTripsSchemaV1.Trip>())\n      try? context.save()  \n    &#125;, didMigrate: nil\n  )\n&#125;\n\nWorking with your DataModel ContainerSchema 는 단순히 “어떤 형태로 저장되는 지에 대한 가이드라인” 정도의 역할이기 때문에 실제로 데이터를 저장하는 무언가도 있어야겠죠?\n그것이 바로 Model Container 입니다.\n\nModel Container는 Schema를 사용하여 실제로 데이터베이스를 구축합니다.\n그리고 이렇게 인스턴스화 된 각 데이터들(Persistence)은 Model Context 를 통해서 접근이 가능하죠.\n그러니까 Model Container 는 Schema와 Persistence 사이의 연결목 역할을 하는겁니다.\nModel Container는 이런 작업들을 합니다.\n\n버전 관리\nMigration\nGraph 분리\n\nContainer 인스턴스를 생성하는 것은 간단합니다.\nimport SwiftData\n\nlet container = try ModelContainer(for: [Trip.self,\n                                         BucketListItem.self,\n                                         LiveAccommodation.self])  \n\n그리고 더 복잡한 형태의 DB를 구축할 수 있도록 추가적인 Configuration도 제공합니다.\nimport SwiftData\n\nlet container = try ModelContainer(for: [Trip.self, LivingAccommodation.self],\n                                   configuration: ModelConfiguration(url: URL(\"path\")))         \n\nModel Configurationlet fullSchema = Schema([Trip.self,\n                         BucketListItem.self,\n                         LivingAccommodations.self,\n                         Person.self,\n                         Address.self])\n\nlet trips = ModelConfiguration(schema: Schema([Trip.self,\n                                               BucketListItem.self,\n                                               LivingAccommodations.self]),\n                               url: URL(filePath: \"/path/to/trip.store\"),\n                               cloudKitContainerIdentifier: \"com.example.trips\")\n\nlet people = ModelConfiguration(schema: Schema([Person.self,\n                                                Address.self]),\n                                url: URL(filePath: \"/path/to/people.store\"),\n                                cloudKitContainerIdentifier: \"com.example.people\")\n\nlet container = try ModelContainer(for: fullSchema, trips, people)    \n\nModelConfiguration 을 통해서는\n\nSchema의 Persistence를 설명하거나 (메모리 혹은 디스크)\n저장되는 위치를 지정하거나\nRead-Only 모드도 지원하고\nCloudKit을 사용하는 경우 identifier를 제공합니다.\n\n위 예시의 경우 trips와 people의 그래프를 저장되는 위치와 CloudKit의 identifier를 분리해서 다르게 설정해주고 있네요.\n이후, ModelContainer 를 생성할 떄 만들어둔 Schema와 Graph들을 하나로 묶어 생성하고 관리할 수 있습니다.\nModel ContextModel Context 는 Model에 생기는 변화를 관찰하다가 트리거되는 행동들을 수행합니다.\n\n업데이트를 추적하고, 2. 데이터를 fetch하고, 3. 변경점을 저장하고, 4. 변경점을 취소하는 등의 작업이 가능합니다.\n\nimport SwiftData\n\nlet context = container.mainContext\nlet context = ModelContext(container)  \n\n이것이 어떻게 가능하냐!? 하면, ModelContext는 일종의 Snapshot 처럼 작동합니다.\n변화가 일어날 때마다 Model의 Snapshot을 찍어 그 때의 상태를 저장해두는 것이죠.\n덕분에 삭제, 수정과 같은 변화가 이루어져도 어떤 인스턴스가 삭제됐고, 수정되었는지에 대한 정보 를 담고 있을 수 있습니다.\n그래서 주의할 점은 ModelContext의 변경점들은 context.save() 를 통해 저장하지 않으면 적용되지 않습니다.\nUndo with ModelContextModel Container 에는 기본적으로 undoManager가 포함되어 있습니다.\n세 손가락으로 스와이프, 흔들어서 입력 취소 등 시스템이 기본적으로 제공하는 제스처들을 자동으로 지원한다는 그런 얘기입니다..\nModelContext AutoSave.modelContainer(for: Trip.self, isAutosaveEnabled: false)\n\nUndo뿐만 아니라 자동 저장도 지원하고 있습니다.\n앱이 백그라운드 상태로 가거나 종료될 때, 혹은 앱이 사용됨에 따라 자동적으로 Context를 저장하는 기능입니다.\nFetch한 값들은 기존에 있던 SortDescriptor와 새로운 Predicate, FetchDescriptor를 사용해 정렬하거나 필터할 수 있습니다.\nPredicatelet tripPredicate = #Predicate&lt;Trip> &#123; $0.destination == \"New York\" &#125;\n\nlet tripPredicate = #Predicate&lt;Trip> &#123;\n  $0.destination == \"New York\" &amp;&amp;\n  $0.name.contains(\"birthday\")\n&#125;\n\n#Predicate 매크로를 사용해 수행할 수 있으며 기존의 filter와 비슷한 역할을 수행합니다.\n기존의 filter는 .filter &#123; &#125;.filter &#123; &#125;와 같이 줄줄이 조건을 추가해줘야 했던 반면, 하나의 클로저 내부에서 모든 조건들을 검사 할 수 있는 점이 특징입니다.\nFetch Descriptorlet descriptor = FetchDescriptor&lt;Trip>(predicate: tripPredicate)\n\nlet trips = try context.fetch(descriptor)          \n\nFetchDescriptor는 위에서 살펴본 Predicate를 context에 적용시켜주는 역할을 합니다.\nlet descriptor = FetchDescriptor&lt;Trip>(\n  sortBy: SortDescriptor(\\Trip.name),\n  predicate: tripPredicate\n)      \n\nlet trips = try context.fetch(descriptor)           \n\n이렇게 SortDescriptor와 조합해서 사용할 수도 있습니다.\ncontext.enumerate(descriptor\n                  batchSize: 10000\n                  allowEscapingMutations: true) &#123; trip in\n  // operate on trip\n&#125;\n\n이외에도 enumerate라는 함수도 있습니다.\nbatchSize는 한 번에 5000개의 오브젝트들을 처리하도록 제한되어 있지만, 이를 10000개로 늘리면 메모리의 할당량을 늘리고, I&#x2F;O 시간은 줄일 수 있습니다.  (메모리 연산을 디스크 처리보다 우선시)\n반면 사진, 영화와 같은 데이터들은 batchSize를 줄이는 것이 좋습니다. 메모리 사용량을 줄이면서 I&#x2F;O 처리량을 늘릴 수 있기 때문이죠. (디스크 처리를 메모리 연산보다 우선시)\nModifying your DataSwiftData는 CRUD 작업도 너무 간단합니다!\nvar myTrip = Trip(name: \"Birthday Trip\", destination: \"New York\")\n\n// Create\ncontext.insert(myTrip)\n\n// Delete\ncontext.delete(myTrip)\n\ntry context.save()  \n\n\n\n\n\n\n\n\n\n\n참고 문서\nWWDC23 - Meet SwiftData\nWWDC23 - Model your Schema with SwiftData\nWWDC23 - Dive deeper into SwiftData\n","slug":"WWDC23/2023-06-12-WWDC23-03","date":"2023-06-11T15:00:00.000Z","categories_index":"WWDC23","tags_index":"Swift,iOS,WWDC23","author_index":"nomatterjun"},{"id":"2418b614534c5af29c48238ca23e6673","title":"02)🎊 WWDC23 - What's new in Swift","content":"WWDC23 - What’s new in SwiftSwift의 새로운 feature, 매크로가 너무 궁금해서 해당 세션부터 찾아보게 되었습니다.\n바로 시작해보죠..!\nExpressive CodeUsing if&#x2F;else and switch Statements as Expressions와우..시작부터 큰 소식이네요..if-else구문과 switch 구문을 표현식 으로서 사용할 수 있다는 소식입니다.\nlet bullet =\n  isRoot &amp;&amp; (count == 0 || !willExpand) ? \"\"\n    : count == 0    ? \"- \"\n    : maxDepth &lt;= 0 ? \"▹ \" : \"▿ \"\n\n다소 과장되긴 했지만 복잡한 조건에 의해 다양한 값을 let 변수에 넣어주고 싶을 때는 위와 같이 삼항연산자를 겹겹이 쌓아가며 사용해야 했습니다.하지만 이제 if-else 구문으로 읽기 쉽게 가능합니다.\nlet bullet = \n  if isRoot &amp;&amp; (count == 0 || !willExpand) &#123; \"\" &#125;\n  else if count == 0 &#123; \"- \" &#125;\n  else if maxDepth &lt;= 0 &#123; \"▹ \" &#125;\n  else &#123; \"▿ \" &#125;\n\n이 방식이 특히나 효과를 보는 곳은 전역 변수나 저장 프로퍼티를 사용할 때입니다.\nlet attributedName = &#123;\n  if let displayName, !displayName.isEmpty &#123;\n    AttributedString(markdown: displayName)\n  &#125; else &#123;\n    \"Untitled\"\n  &#125;\n&#125;()      \n\n전역 변수나 저장 프로퍼티에 조건에 따라 다른 값을 넣어주기 위해서는 이렇게 바로 호출되는 클로저를 통해야만 했습니다.\nlet attributedName =\n    if let displayName, !displayName.isEmpty &#123;\n    AttributedString(markdown: displayName)\n  &#125; else &#123;\n    \"Untitled\"\n  &#125;\n\n하지만 이제 if-else 구문을 표현식으로 사용할 수 있기 때문에 클로저가 필요 없습니다.\nResult BuildersResult Builder가 뭐냐면요..\n저도 이번에 처음 알아보게 되었는데요.. WWDC21에서 발표되었던 내용이더라구요..!?\nimage.constraints &#123; view in\n  view.centerXAnchor == container.centerXAnchor\n  view.topAnchor == container.topAnchor + 20\n  view.widthAnchor == container.widthAnchor -- 20\n  view.heightAnchor == view.widthAnchor * 0.6      \n&#125;\n\n마치 이렇게 SwiftUI의 형태처럼 선언형으로 값을 설정해줄 수 있는 문법입니다.\nDSL(Domain Specific Language) 라고 불리는데요..\n제가 잘 모르기 때문에… 😅\n아무튼 타입 체킹이 빨라지고 에러가 좀 더 정확한 지점에 표시된다고 합니다.\nType Parameter Packs이 부분은 Generic과 관련된 내용입니다.\nSwift의 모든 곳은 Generic이라고도 할 수 있습니다.\n배열만봐도 사실은 Array&lt;Element&gt;라는 Generic을 활용한 타입이죠!?\nstruct Request&lt;Result> &#123; ... &#125;\n\nstruct RequestEvaluator &#123;\n  func evaluate&lt;Result>(_ request: Request&lt;Result>) -> Result\n&#125;\n\nfunc evaluate(_ request: Request&lt;Bool>) -> Bool &#123;\n  return RequestEvaluator().evaluate(request)\n&#125;\n\n여기 Bool 타입의 값을 하나만 받는 함수 evaluate가 있습니다.\n하지만 여러개의 값을 파라미터로 받고 싶을 때도 있겠죠?\nlet value = RequestEvaluator().evaluate(request)\nlet (x, y) = RequestEvaluator().evaluate(r1, r2)\nlet (x, y, z) = RequestEvaluator().evaluate(r1, r2, r3)\n\n문제는 이렇게 함수를 사용하려면..\nfunc evaluate&lt;Result>(_:) -> (Result)\nfunc evaluate&lt;R1, R2>(_:_:) -> (R1, R2)\nfunc evaluate&lt;R1, R2, R3>(_:_:_:) -> (R1, R2, R3)\nfunc evaluate&lt;R1, R2, R3, R4>(_:_:_:_:)-> (R1, R2, R3, R4)\nfunc evaluate&lt;R1, R2, R3, R4, R5>(_:_:_:_:_:) -> (R1, R2, R3, R4, R5)\nfunc evaluate&lt;R1, R2, R3, R4, R5, R6>(_:_:_:_:_:_:) -> (R1, R2, R3, R4, R5, R6)\n\n이렇게 끔찍하게 각 파라미터의 개수에 맞는 함수들을 여러번 오버로드하며 정의해주어야 합니다.\n\n이걸 보자마자 RxSwift의 combineLatest가 생각나더군요…\n딱 이럴때의 경우입니다.\n이 방법은 보기에도 안좋을 뿐더러, 제공하는 파라미터의 개수를 사용하는 쪽에서 뛰어넘으면 당연하게도 컴파일러 에러를 발생시킵니다.\n이 문제를 해결하기 위해 Swift의 Generic에 제공된 인자의 개수보다 많은 수의 값을 받아낼 수 있는 새로운 문법이 도입되었습니다.\n새로운 each 키워드는 Generic 타입을 충족하는 다양한 개수의 인자들을 “packed”된 상태 로 받을 수 있도록 합니다.\nfunc evaluate&lt;each Result>(_: repeat Request&lt;each Result>) -> (repeat each Result)   \n\n하나의 파라미터 Request&lt;Result&gt; 대신 여러개의 파라미터를 반복해서 받는다는 의미로 repeat Request&lt;each Result&gt; 를 사용합니다.\n반환하는 값은 인자가 하나일 경우 하나의 값을, 여러 개일 경우 여러 개의 값은 Tuple (repeat each Result) 로 반환합니다.\n그렇다면 사용하는 쪽에서는 어떨까요?\nlet results = RequestEvaluator.evaluate(r1, r2, r3)\n\nType Parameter Packs API를 사용했는지 조차 알 수 없을 정도로 자연스럽습니다..!\nSwift Macros대망의 매크로입니다..\nassert에서부터 시작하고 있네요.\nassert는 조건문이 false일 때, 프로그램을 자동으로 종료시키죠.\nassert(max(a, b) == c)\n\n\n문제는 위와 같은 방식은 프로그램을 그냥 종료시켜버리고, 종료된 라인만을 로그에 남긴다는 것입니다.\n그래서 애플은 다른 여러가지 assert 방식들을 추가해줬습니다.\nXCAssertEqual(max(a, b), c)\n\n\nXCAssertEqual은 좀 더 나은 로그를 남겨줍니다. 아까보다는 훨씬 낫긴 하지만 여전히 a, b, 혹은 max(a, b) 중에서 어떤 값이 에러를 발생시키는지는 여전히 알 수가 없죠.\n하지만 이제는 Macro를 사용해서 이를 해결할 수 있습니다.\n#assert(max(a, b) == c)\n\n\n매크로는 다른 API들과 비슷하게 패키지의 형태로 import하여 사용할 수 있습니다.\n여기서 사용한 #assert 매크로는 PowerAssert라는 라이브러리를 설치해서 사용할 수 있네요.\n📎 PowerAssert\nMacro Declarations이름이 매크로라면 내가 직접 원하는 형태의 매크로를 사용할 수도 있어야겠죠?\nmacro 키워드를 사용함으로써 매크로를 정의해줄 수 있습니다.\npublic macro assert(_ condition: Bool)    \n\n함수와 상당히 비슷하게 생겼죠..?\n함수와 동일하게 정의해줄 수 있고, 함수와 마찬가지로 타입 체크도 이루어집니다.\n그래서 이 assert 매크로를\n#assert(max(a, b))\n\n이렇게 잘 못 사용하면?\n\n어김 없이 에러를 마주할 수 있죠.\npublic macro assert(_ condition: Bool) = #externalMacro(\n  module: \"PowerAssertPlugin\",\n  type: \"PowerAssertMacro\"\n)     \n\n대부분의 매크로는** “External Macros”** 라고 합니다.\n컴파일러는 매크로를 String으로 제공되는 module 정보와 type 정보를 통해 식별한다고 하네요..\n\n매크로는 컴파일러 플러그인으로 작동하며 앱과는 별도의 프로그램 으로써 실행된다고 합니다.\n컴파일러는 플러그인에게 매크로를 전달하고, 플러그인이 매크로에 대응되는 소스코드를 컴파일러에게 제공하고 있네요.\n매크로에게 필요한 마지막 정보는 그들의 역할(role) 입니다.\nFreestanding Macros@freestanding(expression)\npublic macro assert(_ condition: Bool) = #externalMacro(\n  module: \"PowerAssertPlugin\",\n  type: \"PowerAssertMacro\"\n)        \n\n#assert 매크로는 @freestanding(expression) 매크로인데요..\nfreestanding 은 “#”로 사용할 수 있고, 대응되는 코드를 직접적으로 삽입하기 때문에 사용되었습니다.\nexpression 은 결과값이 있는 그 어느곳에서도 사용할 수 있기 때문에 사용되었다고 하네요.\n@freestanding(exrpession)\npublic macro Predicate&lt;each Input>(\n  _ body: (repeat each Input) -> Bool\n) -> Predicate&lt;repeat each Input>\n\nlet pred = #Predicate&lt;Person> &#123;\n  #0.favoriteColor == .blue\n&#125;\nlet blueLovers = people.filter(pred)    \n\nexpression 매크로에는 #Predicate 라는 매크로도 있습니다.\n#Predicate 매크로는 클로저 안에서 type-safe하게 Predicate를 작성할 수 있도록 해준다고 하네요.\nAttached Macros또 형태의 매크로도 있습니다.\n예시로 사용할 enum을 사용할 경우인데요.\nenum Path &#123;\n  case relative(String)\n  case absolute(String)\n&#125;\n\nextension Path &#123;\n  var isAbsolute: Bool &#123;\n    if case .absolute = self &#123; true &#125;\n    else &#123; false &#125;\n  &#125;\n&#125;\n\nextension Path &#123;\n  var isRelative: Bool &#123;\n    if case .relative = self &#123; true &#125;\n    else &#123; false &#125;\n  &#125;\n&#125;\n\nlet absPaths = paths.filter &#123; $0.isAbsolute &#125;        \n\nenum의 case를 검사할 때 보통 이렇게 많이 사용했습니다.\n이런 방식은 문제가 있습니다. case가 늘어날수록 점점 더 길어지는 방식의 코드라는 것이죠.\n@CaseDetection\nenum Path &#123;\n  case relative(String)\n  case absolute(String)\n&#125;\n\nlet absPaths = paths.filter &#123; $0.isAbsolute &#125;        \n\n@CaseDetction은 “Attached Macros” 입니다.\nProperty Wrapper와 동일하게 “@“ 를 사용하고 있네요!\n이 @CaseDetection 매크로는 이전의 isAbsolute와 isRelative 프로퍼티를 자동으로 생성해줍니다.\n\nAttached Macros 는 다섯 가지 종류로 나눌 수 있고, 각각의 역할은 위와 같습니다.\nmember: type &#x2F; extension으로 새로운 정의를 추가\n\nex) @CaseDetection\n\npeer: 정의된 표현과 함께 다른 표현으로써 정의를 추가     \n\nex) async 메서드와 같은 로직을 수행하는 completion handler 버전의 메서드 추가\n\naccessor: 프로퍼티에 접근하는 방식을 추가 (Property Wrapper와 유사)\n\nex) 저장 프로퍼티를 연산 프로퍼티로 변경\n\nmemberAttribute: type &#x2F; extension으로 속성(attribute)를 추가\nconformance: type &#x2F; extension으로 프로토콜을 충족시키기 위한 요소 추가\n일반적인 API와 다르게 매크로가 좋은 점은, 코드에서 바로 어떤 코드 가 실행되고 있는 지 확인할 수 있고, 디버그 과정에서 진입 할 수 있으며, 매크로 영역 바깥으로 복붙하는 것으로 쉽게 수정 할 수도 있다는 것입니다.\nAttached Macros 들은 동시에 여러개가 사용될수도 있습니다.\n예시로 SwiftUI의 코드를 들고 있는데요.. 무슨 의미인지는 알 것 같아서 한 번 살펴보겠습니다.\n// Observation in SwiftUI\nfinal class Person: ObservableObject &#123;\n  @Published var name: String\n  @Published var age: Int\n  @Published var isFavorite: Bool\n&#125;\n\nstruct ContentView: View &#123;\n  @ObservedObject var person: Person\n    \n  var body: some View &#123;\n    Text(\"Hello, \\(person.name)\")\n  &#125;\n&#125;\n\n이런 형태의 클래스가 있는데요, Person의 각 프로퍼티들의 변화를 받아 ContentView의 내용을 업데이트해주는 코드 같습니다.\n문제는 반복되는 @Published, ObservableObject 프로토콜 등 필요한 부가작업들이 너무 많다는 것이죠.\n매크로를 사용하면 이 과정들을 하나로 축소시킬 수 있습니다.\n// Observation in SwiftUI\n@Observable final class Person &#123;\n  var name: String\n  var age: Int\n  var isFavorite: Bool\n&#125;\n\nstruct ContentView: View &#123;\n  var person: Person\n    \n  var body: some View &#123;\n    Text(\"Hello, \\(person.name)\")\n  &#125;\n&#125;\n\n@Observable 하나면 모든 작업이 수행됩니다.\n내부를 한 번 살펴볼까요?\n@attached(member, names: ...)\n@attached(memberAttribute)\n@attached(conformance)\npublic macro Observable() = #externalMacro(...).\n\n\nmember role을 통해 새로운 프로퍼티들과 메서드들을 추가합니다.\nmemberAttribute role을 통해 @ObservationTracked 매크로를 각 저장 프로퍼티에 추가하고 getter와 setter를 추가합니다. \nObservable 프로토콜을 채택합니다.\n\n매크로를 펼친 형태의 코드는 이렇습니다.\n@Observable final class Person: Observable &#123;\n  @ObservationTracked var name: String &#123; get &#123; … &#125; set &#123; … &#125; &#125;\n  @ObservationTracked var age: Int &#123; get &#123; … &#125; set &#123; … &#125; &#125;\n  @ObservationTracked var isFavorite: Bool &#123; get &#123; … &#125; set &#123; … &#125; &#125;\n  \n  internal let _$observationRegistrar = ObservationRegistrar&lt;Person>()\n  internal func access&lt;Member>(\n    keyPath: KeyPath&lt;Person, Member>\n  ) &#123;\n    _$observationRegistrar.access(self, keyPath: keyPath)\n  &#125;\n  internal func withMutation&lt;Member, T>(\n    keyPath: KeyPath&lt;Person, Member>,\n    _ mutation: () throws -> T\n  ) rethrows -> T &#123;\n    try _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)\n  &#125;\n&#125;\n\n매크로에 대해서는 한 번 관련 세션을 살펴보면서 공부해봐야겠네요.\n새로운 패러다임의 시작일 듯한 느낌..!\nSwift Foundation최근 애플이 Foundation 코드들을 Swift로 다시 쓰는 프로젝트를 시작했다고 합니다.\n기존의 C, Obj-C 코드들을 Swift로 교체하고 있다고 하네요..\n이번 버전에는 Date, Calendar, Locale,  AttributedString, JSON encode &#x2F; decode가 Swift로 다시 쓰여졌다고 합니다.\n\n네.. 그렇다고 합니다..\n넘어가죠!\nOwnership어떤 값을 어떤 코드가 소유하고 있는 지에 대한 추적이 가능해졌다고 합니다.\n저는 코드 작성자가 누군지 시그니처 같은 걸 남겨두는 건 줄 알았는데, 전혀 다른 기능이였네요.\nstruct FileDescriptor &#123;\n  private var fd: CInt\n  \n  init(descriptor: CInt) &#123; self.fd = descriptor &#125;\n\n  func write(buffer: [UInt8]) throws &#123;\n    let written = buffer.withUnsafeBufferPointer &#123;\n      Darwin.write(fd, $0.baseAddress, $0.count)\n    &#125;\n    // ...\n  &#125;\n\n  func close() &#123;\n    Darwin.close(fd)\n  &#125;\n&#125;\n\n이 코드는 위험성이 있습니다.\n파일 수정을 마친 후에 close()를 호출하지 않을 가능성이 농후하죠.\nFileDescriptor를 클래스로 바꾸고 deinit 시점에 close()를 호출해줘도 되지만, 클래스는 reference 타입이기 때문에 하나의 파일을 관리하는 측면에서는 위험성이 큽니다.\nstruct FileDescriptor: ~Copyable &#123;\n  private var fd: CInt\n  \n  init(descriptor: CInt) &#123; self.fd = descriptor &#125;\n\n  func write(buffer: [UInt8]) throws &#123;\n    let written = buffer.withUnsafeBufferPointer &#123;\n      Darwin.write(fd, $0.baseAddress, $0.count)\n    &#125;\n    // ...\n  &#125;\n  \n  consuming func close() &#123;\n    Darwin.close(fd)\n  &#125;\n  \n  deinit &#123;\n    Darwin.close(fd)\n  &#125;\n&#125;\n\n그래서 등장한 것이 Non-Copyable struct 입니다.\n~Copyable 을 붙여주면, 클래스와 마찬가지로 deinit을 사용할 수 있게 됩니다.\n추가적으로 consuming 이라는 키워드도 등장했는데요, 해당 키워드가 달린 함수를 호출함으로써 구조체에 대한 소유권을 포기할 수 있습니다.\nNon-Copyable 구조체는 복사될 수 없으니, 소유권을 포기하게 되면 접근할 수 없는 값이 되겠죠?\n그래서 consuming 함수는 클래스를 메모리에서 해제하는 것처럼 구조체를 메모리에서 해제 시킵니다.\nWhat’s new in Swift ConcurrencyCustom Actor Executors 라는 녀석이 새롭게 나왔습니다.\n 기존의 Actor라는 놈은 자유롭게 사용할 수 있는 녀석은 아니였죠?\n이제 Actor를 특정 DispatchQueue 에 할당시킬 수 있다고 합니다.\nactor MyConnection &#123;\n  private var database: UnsafeMutablePointer&lt;sqlite3>\n  private let queue: DispatchSerialQueue\n\n  nonisolated var unownedExecutor: UnownedSerialExecutor &#123; queue.asUnownedSerialExecutor() &#125;\n\n  init(filename: String, queue: DispatchSerialQueue) throws &#123; … &#125;\n  \n  func pruneOldEntries() &#123; … &#125;\n  func fetchEntry&lt;Entry>(named: String, type: Entry.Type) -> Entry? &#123; … &#125;\n&#125;\n\nawait connection.pruneOldEntries()\n\nunownedExecutor를 이렇게 지정해주면, 모든 Synchronization이 해당 queue에서만 이루어진다고 하네요.\n단순히 await connection.pruneOldEntries()를 호출해주는 것 만으로도 지정된 queue에서 async하게 동작한다는 것이죠!\n이제 Realm을 다루기 좀 더 쉬워지는 걸까요.. 최근에 이걸로 고민을 많이 했는데 말이죠..\n// Executor protocols\n\nprotocol Executor: AnyObject, Sendable &#123;\n  func enqueue(_ job: consuming ExecutorJob)\n&#125;\n\nprotocol SerialExecutor: Executor &#123;\n  func asUnownedSerialExecutor() -> UnownedSerialExecutor\n  func isSameExclusiveExecutionContext(other executor: Self) -> Bool\n&#125;\n\nextension DispatchSerialQueue: SerialExecutor &#123; … &#125;\n\n아무튼 이 새로운 동작은 DispatchQueue가 새로운 SerialExecutor 프로토콜을 따르기 때문에 가능했다고 합니다.\nisSameExclusiveExecutionContext(other executor:) -&gt; Bool을 통해 이미 해당 코드가 실행되고 있는 지를 검사하고, asUnownedSerialExecutor() -&gt; UnownedSerialExecutor를 통해 Executor의 unowned 참조를 가져온다고 합니다.\n그리고 가장 중요한 enqueue(_ job:) 를 통해 Executor의 Job 들을 관리한다고 하네요.\n여기서 Job 이란 Executor에서 비동기적으로 실행되어야 할 동기 Task라고 합니다.\n솔직히 무슨 말인지 너무 헷갈리네요… 😅\n결론은 이제 “Actor 에서 DispatchQueue 를 지정해서 사용할 수 있고, 이는 DispatchQueue가 새로운 SerialExecutor 프로토콜을 따르기 때문이다. SerialExecutor 프로토콜은 dispatch async를 포함한 여러 Job 들을 순차적으로 queue 를 통해 수행해나가는 작업을 한다.” 라고 이해하고 넘어가려고 합니다.\n—\n와우..\n뒤로 갈수록 정신이 아득해질 뻔 했지만.. 한 번 쭉 훑어보긴 했습니다..\n당장 저에게 제일 중요했던 내용들은\n\nMacros\nType Parameter Packs\nDispatchQueue in Actor\n\n이렇게인 것 같아요!\n특히나 매크로는 제대로 한 번 살펴봐야 할 것 같습니다..\n","slug":"WWDC23/2023-06-08-WWDC23-02","date":"2023-06-06T15:00:00.000Z","categories_index":"WWDC23","tags_index":"Swift,iOS,WWDC23","author_index":"nomatterjun"},{"id":"96d1cc8a79035ed04ee1a5935c77af8d","title":"30)🍎 Swift - WidgetKit","content":"Swift - WidgetKit.01WWDC의 iOS 파트에서 꽤 크게 소개된 WidgetKit이 있었죠..\nWidget이 이제 애니메이션을 갖게 되었습니다.\n다른 플랫폼으로의 확장은 덤이구요.\n그런데 전 그 전의 내용도 아직 못봤거든요..\n그래서 지금 시작합니다.\nWidgetKit!\n하지만 시작하자마자 큰 장벽을 만났습니다.\nWidget은 오직 SwiftUI 로만 만들 수 있습니다…\n그래도 작은 화면이니까… 한 번 해봐야겠어요..\nHow WidgetKit Works애플은 위젯에 대해서 굉장히 제한적인 요소라는 생각을 가지고 있는 것 같습니다.\n사용자는 홈 화면을 하루에 90회 정도 방문하지만, 그 시간은 굉장히 적다는 것을 강조하고 있네요.\n그래서 Widget에는 로딩 인디케이터가 돌고 있는 상황이 없어야 한다 고 합니다.\n\nWidgetKit은 백그라운드 익스텐션 입니다.\n시간에 따라 화면들을 패키징하여 홈으로 전달해준다고 하는데요.. 이렇게 함으로써 앱을 실행하고, 데이터를 불러오고, 화면에 띄우는 일련의 과정들을 스킵합니다.\n정말 위젯으로 표시될 화면을 뭉텅이로 가져오기만 하는 것이죠..\n그래서 위젯을 개발하는데 있어 핵심적인 키워드는 “타임라인” 입니다.\n위젯은 타임라인에 따라 동작합니다.\n위젯은 타임라인에 미리 스케줄링된 대로 업데이트 될 수도 있고, 앱에서 요청하여 업데이트 될 수도 있습니다.\n\n여기 달력 앱의 위젯이 있는데요, 이 경우에는 달력에 등록된 일정들에 따라 스케줄링을 할 수 있습니다.\n각 일정이 다가오거나 끝난 시점에 위젯을 업데이트할 수 있는 것이죠.\n\n그런데 사용자가 앱을 열고, 일정을 수정했다면요?\n이럴 때는 앱에서 직접 요청하여 위젯을 업데이트 시킬 수 있는 것이죠.(정확히는 타임라인을 업데이트하는 것입니다.)\nWidget Definition실제로 위젯을 만들기 전에, 위젯을 정의해야합니다.\n위젯은 네 가지로 정의할 수 있습니다: kind , configuration , supportedFamilies , placeholder 로요!\nKind우선 kind 입니다.\n\n위젯은 하나의 종류만 있지 않습니다.\n\n같은 사이즈라도 여러개의 정보를 요약하여 보여주거나, 하나의 정보를 조금 더 자세하게 보여줄 수도 있죠.\nConfiguration이렇게 분류된 각 종류(kind)의 위젯들은 어떤 Configuration 을 지원하는 지에 대한 정보도 담고 있습니다.\nStaticConfiguration 과 IntentConfiguration , 이렇게 두 가지 Configuration이 있는데요, 아주 간단한 개념입니다!\nStaticConfiguration 은 사실 Configuration이 없는 겁니다.\n하나의 Configuration만을 사용하기 위해 이렇게 이름이 붙은 것 같아요.\n별도의 설정이 필요 없는, 오직 하나의 고정된 종류의 데이터만을 보여줄 때 사용됩니다.\n\n반대로 IntentConfiguration 은 설정을 통해 위젯이 보여주는 화면이 달라질 때 사용됩니다.\n예시로는 “여러 종류의 리스트 중에서 어떤 종류를 위젯으로 보여줄 지 선택이 필요할 때” 가 있겠죠?\nSupported Families\nSupportedFamilies 는 지원하는 위젯의 크기 입니다.\n기본으로는 세 종류의 크기를 모두 지원하는 것으로 되어있지만, 개발자가 선택할 수 있습니다.\nPlaceholder\nPlaceholder 도 간단합니다.\n어떤 데이터도 들어가지 않은, 위젯이 어떤 형태인지만 표현하는 비어있는 View를 제공해주면 됩니다.\nStatelessUI\n위젯은 다음의 네 가지 원칙을 지켜야합니다.\n사실 애플이 제한해두고 있기 때문에 어길 수도 없지만요?\n\n위젯은 작은 별도의 앱이 아니다. 앱에 진입시키기 위한 단편적인 정보를 제공할 뿐이다.\n위젯은 스크롤을 지원하지 않는다.\n위젯에는 움직이는 사진이나 비디오가 들어갈 수 없다.\n위젯에는 오직 탭 제스처만이 유효하다.\n\n\n위젯은 오직 앱의 특정 지점에 도달하기 위한 숏컷을 제공할 뿐이고, 이것은 URL API 를 활용해 구현된다고 하네요!\nViews위젯에는 세 가지 View가 필요합니다.\n첫 번째는 placeholder 로 이미 다룬 내용이구요..\n\n두 번째로 snapshot 이라는 화면이 필요합니다.\nWidget Gallery와 같은 곳에서 빠르게 데이터를 불러와 사용할 수 있는 단일성의 화면입니다.\n마지막으로는 timeline 입니다.\n실제로 위젯을 홈 화면에 띄울 때 사용되는 화면입니다.\n보통 snapshot과 timeline의 첫 화면은 동일한 화면으로 구성되는게 좋다고 하네요.\n타임라인은 Light Mode와 Dark Mode일 때의 화면을 동시에 제공하여 시스템이 알아서 조정할 수 있도록 되어 있고, 한 번에 며칠동안의 View를 제공한는 것이 좋다고 합니다.\nReload하지만 위젯도 좀 더 자주 업데이트 되어야 할 때가 있겠죠?\n이럴 때는 reload 라는 개념을 사용합니다.\n\nReload가 실행되면 화면에 배치된 모든 위젯 에 대해서 시스템이 새로운 timeline을 제공 하도록 요청합니다.\n자 코드로 한 번 살펴봅시다.\npublic protocol TimelineProvider &#123;\n  associatedType Entry: TimelineEntry\n\n  typealias Context = TimelineProviderContext\n\n  func snapshot(with context: Self.Context,\n                completion: @escaping (Self.Entry) -> ())\n  func timeline(with context: Self.Context,\n                completion: @escaping (Timeline&lt;Self.Entry>) -> ())\n&#125;    \n\n코드로 봐도 잘 모르겠긴 한데요.. 🤔\nEntry는 보통 Date 데이터가 들어간다고 하구요..\nContext에는 environment 정보와 Entry를 요청한 시스템에 대한 정보가 들어온다고 합니다.\nsnapshot과 timeline은 말 그대로 이전에 살펴보았던 snapshot과 timeline 데이터를 제공받기 위한 함수입니다.\nsnapshot에는 단일 데이터가, timeline에는 여러 개의 데이터가 들어가겠죠?\npublic struct Provider: TimelineProvider &#123;\n  public func snapshot(with context: Context, \n                       completion: @escaping (SimpleEntry) -> ()) &#123;\n    let entry = SimpleEntry(date: Date())\n    completion(entry)\n  &#125;\n  public func timeline(with context: Context, \n                       completion: @escaping (Timeline&lt;Entry>) -> ()) &#123;\n    let entry = SimpleEntry(date: Date())\n    let timeline = Timeline(entries: [entry, entry], policy: .atEnd)\n    completion(timeline)\n  &#125;\n&#125;\n\nTimelineProvider를 채택하면 이런 형태의 모습일겁니다.\n여기서 주목할 점은 policy: .atEnd 부분입니다.\n여기서 policy란 reload가 되는 시점을 정하는 policy라고 볼 수 있는데요,\natEnd 로 제공한 timeline이 끝날 때 reload를 할 수 있고, after(date: Date) 로 일정 시간이 됐을 때 reload하거나 never 로 요청하지 않을 수 있습니다.\n그래서 reload는 대체 언제 되느냐?\n자연적으로 발생하는 reload는 아래의 규칙에 따라 이루어집니다.\n\nReloadPolicy를 따라 되거나\n더 자주 화면에 등장하는 위젯에 더 많은 reload를 제공하거나\n기기 환경이 바뀔 때 시스템이 강제로 reload합니다.\n\n앱이 요청하는 reload는 Background Notification 이 있거나, 사용자가 데이터를 변경 했을 때 이루어집니다.\n두 경우 모두 WidgetCenter의 reloadTimelines(ofKind:)를 사용하면 된다고 하네요.\n\nreloadTimelines(ofKind:)\nreloadAllTimelines\ngetCurrentConfigurations(completion:)\n\nWidgetKit은 이렇게 세가지 API를 제공하고 있는 것을 알아두고 넘어갑시다!\n그런데 위젯을 사용할 때, 네트워크 통신을 통해 새로운 데이터를 받아와야할 때도 있겠죠?\n그럴 때는 background URLSessions를 사용합니다.\n하지만! 위젯은 절대절대 실시간 데이터를 반영하기 위한 기능이 아니기 때문에 그 빈도를 잘 설정해달라고 합니다.\n\n그래서 정리해보면.. 위젯의 Reload는 Background Networking 을 통해 이루어지거나, Timeline 에 의해 이루어지거나 앱의 요청 에 따라 이루어질 수 있겠습니다.\nPersonalization &amp; Intelligence앞에서 위젯은 여러 설정에 따라 데이터를 다르게 보여줄 수 있다고 했었습니다.\nPersonalization이 기능을 사용하려면 App Intent 라는 것을 사용해야 합니다.\nIntent Framework는 여러개의 파라미터로 이루어져 있습니다.\n각 파라미터는 유저에게 묻는 일종의 질문이라고 생각하면 됩니다.\n\n예를 들어 주식 앱의 경우 유저가 위젯을 터치하여 어떤 주식을 표시할 것인지를 선택할 수 있겠죠.\n이 때, App Intent를 사용해 유저가 앱에서 지정해둔 주식의 리스트를 위젯으로 받아올 수 있습니다.\n만약 유저가 원하는 옵션이 리스트에 없다면?\n\nIntents는 dynamic options capability 기능을 제공합니다.\n유저가 종목을 검색하면, 시스템이 주식 Intents Extension을 실행하여 리스트를 새롭게 받아올 수 있습니다.\n이 부분은 따로 더 공부가 필요해보이네요…\nSiriKit과 관련된 내용이라고 합니다..\nIntent를 사용하면 이전의 코드도 다음과 같이 바꿔주어야 합니다.\n@main\npublic struct SampleWidget: Widget &#123;\n  private let kind: String = \"SampleWidget\"\n\n  public var body: some WidgetConfiguration &#123;\n    IntentConfiguration(kind: kind,\n                        intent: ConfigurationIntent.self\n                        provider: Provider(),\n                        placeholder: PlaceholderView()) &#123; entry in\n                          SampleWidgetEntryView(entry: entry)\n                        &#125;\n    .configurationDisplayName(\"My Widget\")\n    .description(\"This is an example widget.\")\n  &#125;\n&#125;  \n\nStaticConfiguration 대신 IntentConfiguration 을 사용해주고 (아.. 이래서 이름이 IntentCongiruation이였구나…)\npublic struct Provider: IntentTimelineProvider &#123;\n  public func timeline(for configuration: ConfigurationIntent, with context: Context, \n                       completion: @escaping (Timeline&lt;Entry>) -> ()) &#123;\n    let entry = SimpleEntry(date: Date(), configuration: configuration)\n\n    // generate a timeline based on the values of the Intent\n\n    completion(timeline)\n  &#125;\n&#125;\n\nTimelineProvider도 IntentTimelineProvider로 업데이트해서 제공해주어야 합니다.\n\n\n\n\n\n\n\n\n\nIntentHandler를 사용할 때의 주의점!\nDynamicIntent를 구성하고, IntentHandler를 구현할 때 헤맨 곳이 있었는데요..\nDynamicSummonerSelectionIntentHandler 프로토콜을 준수하려 했을 때입니다.\n해당 프로토콜을 채택하고, stub를 추가하면 XCode가 두 가지 메서드를 추가해줍니다.\nfunc provideSummonerOptionsCollection(for intent: DynamicSummonerSelectionIntent, with completion: @escaping (INObjectCollection&lt;Summoner&gt;?, Error?) -&gt; Void) &#123;\n\t\t&#x2F;&#x2F;\n&#125;\n\nfunc provideSummonerOptionsCollection(for intent: DynamicSummonerSelectionIntent) async throws -&gt; INObjectCollection&lt;Summoner&gt; &#123;\n\t\t&#x2F;&#x2F;\n&#125;\n\n저는 처음에 “@escaping 클로저 방식과 async/await의 두 가지 방식을 모두 제공해줘야하는구나!” 라고 생각하고 작업을 했습니다.\n그러면 이런 에러가 뜰겁니다..\n\n\n\n\n\n\n\n\n\nMethod with Objective-C selector conflicts with method with the same Objective-C selector.\n대체 어디서 Conflict가 나는거지? 라는 의문이 들었지만.. 원인은 간단했습니다.\nHandler에 들어가서 내용을 잘 살펴보면.. 두 프로토콜이 대응되는 Obj-C 함수가 같습니다..\n그래서 같은 함수라는 에러를 내고 있는 것이죠..\n그렇다면 해결법은…?\n두 함수 중 하나만 골라서 사용해주시면 됩니다… 🥲\nIntelligence자 그런데 애플이 제공하는 기본 위젯 중 “스마트 스택” 이라는 놈이 있죠?\niOS가 유저의 패턴과 환경을 분석하여 상황에 가장 맞는 위젯을 선택하여 보여주는 기능입니다.\n어떻게 내 위젯이 스마트 스택에 뜰 수 있게 하느냐? 하면 두가지 방법이 있습니다.\n1. Shortcuts Donate유저가 앱 내에서 활동을 해서 Shortcuts로 donate를 하게 되면, 같은 INIntent를 사용하는 위젯이 스마트 스택의 위로 올 수 있게 됩니다.\n2. TimelineEntryRelevance API어떤 시간이 다가오고, 내 앱의 entry가 가장 중요한 시점이라고 생각되면, 시스템에게 score와 duration을 제공하여 스마트 스택의 위로 위치하게 유도할 수 있습니다.\nRelevance는 TimelineEntryRelevance(score:)로 사용할 수 있습니다.\n여기서 score라는 파라미터가 중요한데, 저희가 원하는 어떤 상수를 넣어주면 됩니다.\n이 상수의 범위는 정해져있지 않으며, 저희가 전달한 각 상수들과의 상대적인 차이에 따라서 알아서 우선순위가 정해집니다.\n","slug":"Swift/2023-06-08-Swift30","date":"2023-06-07T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"4932fe99e31aa6c7113fa36649ad4bc9","title":"01)🎊 WWDC23 - What's new in UIKit","content":"WWDC23 - What’s new in UIKit드디어 WWDC23의 막이 열렸습니다!\n\n다들 VisionOS 와 Vision Pro 보셨나요??\n너무너무 놀라워서 당장이라도 공부하고 싶은 마음이 컸지만..\n스유와 ARKit을 모른다면 쉽게 접근할 수 없을 것 같더군요..! 😭\n그래서 여유가 좀 생긴다면 천천히 하나씩 공부해보려고 합니다!\n일단은 하던 UIKit에 집중해야죠!\n그래서 올해 덥덥디씨 공부의 시작을 “What’s new in UIKit” 으로 시작해보려 합니다.\nArchitectural Enhancements우선 Architectural Enhancements 입니다! (이거 한국어로 뭐라고 번역해야하나요..)\n총 5가지의 파트로 나누어 설명되고 있습니다.\nXcode Previews드디어 Preview를 UIKit 순정으로 사용할 수 있게 되었습니다! 👏👏\n원래는 UIKit에서 앱의 프리뷰를 앱 빌드 없이 보려면 SwiftUI의 feature를 빌려와서 사용해야 했죠.. 😭\n이제는 import SwiftUI 없이 순수 UIKit에서도 가능합니다!\n바로 새롭게 등장한 Swift의 macro 기능을 사용하는데요..!\n\n오오… #Preview까지만 입력을 했는데도 옆에 Preview 화면이 바로 뜨네요… 😮\n#Preview(\"Home\") &#123;\n  let vc = HomeViewController()\n  vc.isBold = false\n  return vc\n&#125;\n\n이렇게 새로운 macro를 사용해서 SwiftUI와 같이 Preview를 사용할 수 있게 되었습니다.\nvc.type = .edit과 같이 vc의 프로퍼티나 메서드를 바꿔가면서 작업할 수도 있어요!\n\n이렇게요..!\n근데요.. 문제가 하나 있습니다.\n\niOS 17부터거든요! 🥲 🥲 🥲\n아무래도 실제로 사용하기엔 시간이 조금 걸릴 것 같죠..?\n\n저는 일단은 Debug 타겟을 17.0으로 설정하니까 빌드는 되더라구요..\n나중에 Release할 때는 별도의 작업을 해주어야겠지만 우선은 이렇게 진행해보겠습니다.\n#Preview가 정말 편리한 점은 ViewController 뿐만 아니라 UIView 에서도 사용할 수 있다는 점입니다.\n\n이렇게 다양한 크기의 컴포넌트로 시각화해주어서 혹시 모를 버그를 방지하는데도 큰 도움이 될 것 같네요.\nViewController Life Cycle다음으로는 ViewController의 Life Cycle에 변경점이 있습니다.\n새로운 콜백 함수가 추가되었는데요.. viewIsAppearing이라는 이름을 가지고 있습니다.\n이 viewIsAppearing은 viewWillAppear와 viewDidAppear 사이에 호출된다고 하는데요..!\n그냥 viewWillAppear를 사용하면 되는거 아니냐! 했지만..\nviewIsAppearing이 호출되는 시점은 UI의 trait collection이 구성 되었고, 각 컴포넌트들이 UI 계층(hierarchy)에 추가되고 확정된 시점 이라고 합니다.\noverride func viewDidLoad() &#123;\n  super.viewDidLoad()\n  self.view.addSubview(self.label)\n  self.label.snp.makeConstraints &#123; make in\n    make.center.equalToSuperview()\n  &#125;\n&#125;\n\noverride func viewWillAppear(_ animated: Bool) &#123;\n  super.viewWillAppear(animated)\n  print(\"View will Appear: \\(self.label.frame)\")\n&#125;\n\noverride func viewIsAppearing(_ animated: Bool) &#123;\n  super.viewIsAppearing(animated)\n  print(\"View is Appearing: \\(self.label.frame)\")\n&#125;\n\noverride func viewDidAppear(_ animated: Bool) &#123;\n  super.viewDidAppear(animated)\n  print(\"View did Appear: \\(self.label.frame)\")\n&#125;\n\n자 그럼 이렇게 해두면 어떻게 출력되나 한 번 볼까요?\n\n🤔 🤔 🤔 레이아웃이 안잡혀있는데요..?\n뭥미..\n\n라고 삽질을 하던 중 다음 화면에서 해답을 찾을 수 있었습니다.\nviewIsAppearing은 LayoutSubviews들 보다는 앞에 콜백되거든요! 🫣\nviewIsAppearing이 등장한 배경은 다음과 같습니다.\n\nviewWillAppear는 컴포넌트들이 계층에 추가되기 이전에 콜백되기 때문에 trait collection을 사용하거나 view의 사이즈와 위치에 따른 로직을 추가하기에는 너무 이릅니다.\n\nviewDidAppear는  모든 애니메이션이 끝난 후에 콜백되기 때문에 업데이트할 요소들이 너무 늦게 업데이트 되고, 유저들은 이를 직접 보게 된다.\n\nlayoutSubviews들과 같은 시기에 콜백되는 함수가 필요하다…!\n\n\n그러면 그냥 layoutSubviews에서 작업하면 되는거 아닌가요? 라는 질문이 생기던 찰나 바로 또 설명해주십니다.\nlayoutSubviews들은 transition이 있을 때, 혹은 view가 visible한 동안 몇 번이고 호출 될 수 있지만, viewIsAppearing은 transition당 딱 한 번 만 호출됩니다.\n또한 레이아웃을 잡는 동작이 필요가 없을 때도 호출되기 때문에 유용한 상황도 있겠죠!\nTrait System Enhancements위 내용과 이어지는 내용인 것 같네요!\n이건 근데 아직 제가 학습하지 못한 내용이라…\n\n이런 내용이 있다는 것만 알아두고 넘어가겠습니다..\n마침 세션 중에 관련 세션이 있는 것 같아 거기서부터 시작해볼 것 같네요!\n원래는 프레임워크에서 제공하는 형태의 trait만 사용할 수 있었지만, 이제는 커스텀하여 만들 수 있다! 라는 것이 핵심인 것 같습니다.\nAnimated Symbol Images애플은 아이콘을 SF Symbols를 통해 제공하고 있죠?\n이 아이콘들을 사용하면 추가적인 노력 없이 앱 전반적으로 통일된 질감을 낼 수 있는 것이 큰 장점입니다.\n이제 이 SF Symbols에 애니메이션이 추가된다고 하네요.\n심지어 기본으로 제공되는 Symbol 외에도 커스텀 Symbol에도 적용할 수 있다고 합니다.\n그래서 어떻게 하냐?.. 기본은 짱 쉽습니다.\nself.imageView.addSymbolEffect(.bounce)\n\n이렇게 .bounce 이펙트를 추가해주면 한 번 bounce 됩니다.\n\nㅋㅋㅋㅋㅋ 귀엽지 않나요..\nself.imageView.addSymbolEffect(.variableColor.dimInactiveLayers)\n\nself.imageView.removeSymbolEffect(ofType: .variableColor)\n\n.bounce와는 다르게 .variableColor는 이펙트를 제거해줄 때까지 반복됩니다.\n\n이렇게요!\n이 외에도 여러가지 이펙트들이 있습니다.\n\n이 내용 또한 별도의 세션으로 준비되어 있다고 하네요.\n거기서 더 자세히 살펴보도록 합시다!\nEmpty States생각치도 못한 기능이 UIKit에 추가되었습니다.\n바로 비어있는 화면 Configuration!\n근데 그 전에 이것 좀 봐주세요..\n\n😆 😆 😆 너무 귀여우셔…\n그래서 이렇게 귀엽게 소개하신 내용이 뭐냐면요..\n\n이렇게 컨텐츠가 없는 비어있는 화면 입니다.\n정말 순수하게 컨텐츠가 없거나 네트워크 오류로 인해 불러올 수 없는 등 화면에 아무것도 표시할 수 없는 경우 들이 있죠?\n\nvar config = UIContentUnavailableConfiguration.empty()\n\nconfig.image = UIImage(systemName: \"star.fill\")\nconfig.text = \"No Favorites\"\nconfig.secondaryText = \"Your favorite translations will appear here.\"\n\nviewController.contentUnavailableConfiguration = config\n\n그럴 때 이렇게 간단하게 비어있는 화면에 대한 핸들링을 해줄 수가 있게 되었습니다.\nViewController 내부에서 사용할 수 있는 방법은요?\nupdateContentUnavailableConfiguration(using state:) 메서드를 override해서 사용해주면 됩니다.\noverride func updateContentUnavailableConfiguration(\n  using state: UIContentUnavailableConfigurationState\n) &#123;\n  var config: UIContentUnavailableConfiguration?\n  if self.searchResults.isEmpty &#123;\n    config = .search()\n  &#125;\n  self.contentUnavailableConfiguration = config\n&#125;      \n\n이렇게 contentUnavailableConfiguration을 교체해주는 로직들을 넣어주고, 변경이 필요한 곳에서\nself.setNeedsUpdateContentUnavailableConfiguration()\n\n를 호출해주면 됩니다.\n아주 간단하죠!\nInternationalization다음 파트는 국제화입니다.\n이 파트는 사실 접할 기회가 많진 않을 것 같아서 관심 있는 분야만 살펴볼게요..\nWrapping and Hyphenation전 파트가 사실 아랍 문자와 관련된 내용이라 흠.. 하면서 보고 있었는데요.\n이 파트로 넘어오며 한국어가 언급돼서 엇! 하면서 다시 집중해서 보게 되었습니다.\n중국어, 독일어, 일본어, 그리고 한국어의 line-breaking 에 향상이 있다고 하네요.\n대부분의 경우에는\nlet label = UILabel()\nlabel.text = \"안녕하세요!\"\nlabel.traitOverrides.typesettingLanguage = Locale.Language(identifier: \"ko\")     \n\n이렇게 typesettingLanguage trait을 설정해주는 것 만으로도 line-height와 hyphenation rule을 설정해줄 수 있다고 하네요.\nUIImage를 받아올 때도 Locale에 따라 다른 크기를 받아올 수 있다고 합니다.\nUIImage의 font 크기가 UILabel의 크기와 맞지 않는 경우에 직접 값을 비교해가며 넣느라 고생한 경험이 있는데, 그 문제가 해결된 것 같습니다.\nlet locale = Locale(languageCode: .korean)\n\nimageView.image = UIImage(\n  systemName: \"character.textbox\",\n  withConfiguration: UIImage.SymbolConfiguration(locale: locale)    \n)\n\n자동으로 되는 것은 아니고, 이렇게 locale을 configuration으로 제공해주는 것으로 적용이 가능합니다.\nGeneral Enhancements아이패드 부분은 우선 쭉 넘어가고…\n전반적인 향상 부분을 살펴보도록 하겠습니다.\nCollectionView ImprovementsCollectionView가 성능적으로 더! 향상되었다고 하네요..\n\n대략 10000개의 아이템이 있을 때, iOS 16에 대비해서 두배정도 빠르다고 합니다.\n10000개의 아이템까지 표현할 일이 있을까..? 싶긴 한데.. 아무튼 빨라서 안좋을 건 없으니까요?\n이 최적화는 Snapshot을 사용하는 방법, batchUpdate를 사용하는 방법 모두에게 통용된다네요!\n근데 어떻게 한 건지는 설명을 안해서.. 그냥 그렇다고 알고 넘어가라는 것 같습니다…\n다음으로는 CompositionalLayout 의 향상점입니다.\n제가 아주 사랑하는 CompositionalLayout.. 얼마나 발전했나 볼까요?\n\n적용 예시로 애플이 가져온 아이패드의 건강 앱입니다.\n두 Item 모두 .estimated 레이아웃 사이즈로 구현되었다고 하는데요.. 잘 보면 두 아이템의 높이가 다릅니다.\n그러니까 Item 자체의 사이즈가 다르지만, 하나의 그룹으로 묶여있기 때문에 하단 영역이 남아있는 모습인 것이죠.\n이를 해결하기 위해 새로운 layoutDimension이 소개되었습니다.\nuniformAcrossSiblings 이라는 이름으로 등장했네요.\nNSCollectionLayoutDimension.uniformAcrossSiblings(estimate:) \n\n하나의 그룹안에 있는 아이템들이 가장 큰 아이템의 크기에 맞춰지는 것 을 볼 수 있네요.\n\n이렇게 끝 지점이 달라서 불편했던 레이아웃을\n\n그룹 내의 가장 큰 아이템에 맞춰 높이를 통일 시킬 수 있게 되었습니다.\n편안… 😌\nSpring Animation ParametersSpring Animation의 파라미터를 두 가지로 줄이는 향상이 있다고 합니다.\nduration 과 bounce 이렇게 두 가지로요.\nduration은 애니메이션 전체에 걸리는 시간이 아니라 변환 위치에 다다르는 시간입니다. bounce와는 완벽하게 독립적으로 동작한다고 하네요.\nbounce는 말 그대로 튕기는 정도를 조절할 수 있는 파라미터 입니다.\n이 두 파라미터는 UIView.animate에 바로 적용할 수 있습니다.\nUIView.animate(springDuration: 0.5, bounce: 0.5) &#123;\n  self.circle.center.x += 100\n&#125;\n\n이 두 파라미터는 Optional 파라미터라서 \nUIView.animate &#123;\n  self.circle.center.x += 100\n&#125;\n\n이렇게 파라미터 없이 사용하게 되면 시스템이 정해둔 기본값으로 동작합니다.\nText Interactions텍스트 입력 커서와 테스트 선택에 새로운 API들이 제공됩니다.\n이제 UITextInteraction을 통째로 가져와 적용하는 대신, 선택한 텍스트에 대한 UI만 사용할 수 있다고 합니다.\n새로운 API들은 UITextViewDelegate를 채택하면서 사용할 수 있으며, link와 text attachments를 더 자유자재로 사용할 수 있도록 한다고 합니다.\n추가로 link가 아닌 텍스트에 대해서도 인터랙션 액션을 추가할 수 있는 API도 추가되었다고 하네요!\n다만 이 부분은 제가 적용해본 적이 없어서 제대로 이해한 것인지 모르겠네요..\nDefault StatusBar Style이런 경우 아주 많을 겁니다.\n\n이 경우 라이트 모드라서 검정색의 StatusBar가 사용되고 있습니다.\n하지만 컨텐츠를 위로 스크롤하면..?\n\n쨔잔.. 이렇게 컨텐츠와 StatusBar가 겹쳐보이면서 원래라면 검정색의 StatusBar가 안보이게 됐겠지만,\noverride var preferredStatusBarStyle: UIStatusBarStyle &#123;\n  return .default\n&#125;\n\n이렇게 .default로 설정해두면 알아서 뒤에 배치된 컨텐츠에 따라 색상을 바꾼 다고 하네요.\n\n심지어 이 변화는 양쪽이 별개로 작동합니다.\n아주 굿! 👍\nDrag and Drop Enhancements\n이 부분은 직접 보는게 빠를 것 같아요!\n이제 드래그 &amp; 드롭이 가능한 컨텐츠는 컨텐츠의 종류에 따라 앱 아이콘에 드롭하는 것 만으로도 특정 액션을 할 수 있습니다.\nInfo.plist 의 CFBundleDocumentTypes에 해당 파일의 형식이 지원하는 지를 설정해주면 바로 사용할 수 있습니다.\n이렇게 설정된 형식의 파일은 UIScene delegate 콜백에 의해 처리된다고 하네요!\nISO HDR Image SupportUIKit에서 이제 UIImageView나 UIGraphicsImageRenderer에서 ISO HDR 이미지를 쉽게 사용할 수 있습니다.\n이 부분도 관련 세션에서 자세하게 다룬다고 합니다..\nPageControlUIPageControl은 자동 전환되는 배너로 많이 쓰이고 있죠.\n그 쓰임새를 강화할 수 있도록 UIPageControl에 타이머 가 추가되었습니다.\n\n단순히 점만 있던 것을 넘어 이제 현재 페이지가 얼마나 진행되었는지 를 시각적으로 제공하네요.\nlet timerProgress = UIPageControlTimerProgress(preferredDuration: 10)\npageControl.progress = timerProgress\n\ntimerProgress.resumeTimer()\n\nUIPageControl의 새로운 progress 프로퍼티를 활용해서 쉽게 사용할 수 있습니다.\n그리고 무려… 빌트인 타이머 가 생겼다고 해요..\n타이머가 될 때마다 다음 페이지로 알아서 넘어가는 것은 물론이고,\nmyTimer.addPeriodicTimeObserver &#123; timer in\n  progress.currentProgress = Float(timer.seconds / timer.duration)\n  // ..\n&#125;\n\n이렇게 직접 progress를 설정해줄 수도 있어요!\n이제 자동 무한 스크롤 배너를 아주 쉽게 구현할 수 있겠네요.\nPalette Menus\n아니 진짜 이분 왜 이렇게 귀여우신 건데요..\n아무튼..\n\n이런 색상을 선택하는 메뉴가 지금도 이곳저곳에 있었죠..?\n이제 Palette 메뉴를 기본적으로 제공한다고 합니다.\nUIMenu(options: [ .displayInline, .displayAsPalette ], children: [ ... ])   \n\n이렇게 UIMenu에 넣어주는 것으로 간편하게 사용할 수 있습니다.\n색상 뿐만 아니라\n\nUIAction(image: UIImage(systemName: \"heart.fill\"), state: .on) &#123; ... &#125;\n\n이렇게 이미지도 넣어줄 수 있네요.\n이미지의 경우 .on 상태일 때 tintColor로 하이라이트 된다고 합니다.\n\n여기까지가 “What’s new in UIKit” 세션의 내용이였습니다.\nPreview와 StatusBar, Progress가 접목된 PageControl..\n마음에 드는 내용들이 잔뜩 있었네요. 👍\n다른 세션도 얼른 공부하러 출동!  \n\n\n\n\n\n\n\n\n\n참고 문서\nWWDC23 - What’s new in UIKit\n","slug":"WWDC23/2023-06-07-WWDC23-01","date":"2023-06-06T15:00:00.000Z","categories_index":"WWDC23","tags_index":"Swift,iOS,WWDC23","author_index":"nomatterjun"},{"id":"96468e592e7cdf6f399481c66d5c9acd","title":"29)🍎 Swift - 인스타그램 스토리로 공유하기","content":"인스타그램 스토리 공유오늘은 앱에서 얻어낸 사진을 인스타그램 스토리로 공유하는 법을 공부해보겠습니다.\nInstagram - Sharing to stories\n해당 문서를 따라가며 진행해보죠!\n앱 ID 휙득하기\n가장 먼저 눈에 띄는 경고문이 있네요!\n다른 SDK와 마찬가지로 앱 등록을 해야하나 봅니다. 그런데 1월부터면 그 전에는 그냥 됐던건가…?\nMeta 개발자 계정을 만들고 앱을 생성해주면 이렇게 앱 ID를 얻어낼 수 있습니다.\n\n어떤 이미지를 제공해야할지 확인해보기그러면 이제 인스타 스토리로 올릴 내용을 제공하려면 어떤 것이 필요한지를 알아야겠죠?\n\n이 항목을 살펴보면 스토리는  Background Layer와 Sticker Layer로 구분되어 있다는 걸 확인할 수 있습니다.\n스토리의 배경을 꽉 채운 상태로 고정시키는 이미지는 Background Layer로, 유저가 변형하거나 이동시켜 배치시킬 수 있는 이미지는 Sticker Layer로 구성해주면 되겠죠?\n그러면 어떻게 인스타그램 앱으로 이미지를 전달해줄 수 있을까요?\n스키마 적용앱의 콘텐츠를 인스타그램으로 전송하기 위해서는 세 가지 스텝을 거쳐야 합니다.\n\n앱이 인스타그램의 맞춤 URL 스키마를 찾을 수 있는지 확인합니다.\n페이스트보드에 공유하고자 하는 콘텐츠를 할당합니다.\n앱에서 가능한 경우 맞춤 URL 스키마를 찾습니다.\n\n그러면 역시 시작은 다른 SDK와 마찬가지로 앱에 URL 스키마를 등록해주는 것이겠죠?\n인스타그램은 Info.plist에 있는 LSApplicationQueriesSchemas키에 instagram-stories를 추가해달라고 합니다.\n\n주의할 점은 Array 타입으로 그 하위에 추가해주어야 합니다. 인스타그램 뿐만 아니라 다른 기능이나 앱들의 스키마들도 등록될 수 있기 때문이죠!\n코드 작성이제 인스타그램에 데이터를 전달해주는 코드를 작성해봅시다.\n문제는 인스타그램이 예제로 Swift 코드를 제공하는게 아니라 Obj-C 코드를 제공하고 있어요..\n상당히 당황스럽지만.. 알잘딱으로 Swift로 변환해서 작성해봅시다.. 😡\n우리에겐 이제 GPT라는 무기도 있으니까요!\n우선 전달해줄 수 있는 데이터와 타입, 설명은 아래와 같습니다.\n\n배경 자산 공유하기이름을 보아하니 Background Layer를 제공하는 것을 말하는 것이겠죠?\nChatGPT에게 Obj-C 언어를 Swift로 변환해달라고 하니 꽤 그럴듯 해보이는 코드가 나와서 그대로 코드를 적용해보았습니다.\n  private func shareToInstagram() &#123;\n    if\n      let backgroundImage = UIImage(named: \"GiftMock\"), // 테스트를 위한 임시 데이터\n      let imageData = backgroundImage.pngData() &#123; // 1️⃣\n      self.backgroundImage(backgroundImage: imageData, appID: URLSchemes.instagramStory.url)\n    &#125;\n  &#125;\n\n  private func backgroundImage(backgroundImage: Data, appID: String) &#123;\n    if let url = URL(string: appID) &#123;\n      if UIApplication.shared.canOpenURL(url) &#123; // 2️⃣\n        let pasteboardItems = [[\"com.instagram.backgroundImage\": backgroundImage]]\n        let pasteboardOptions: [UIPasteboard.OptionsKey: Any] = [\n          .expirationDate: Date(timeIntervalSinceNow: 60 * 5)\n        ]\n        UIPasteboard.general.setItems(pasteboardItems, options: pasteboardOptions) // 3️⃣\n        UIApplication.shared.open(url, options: [:]) // 4️⃣\n      &#125; else &#123;\n        // Error Handling\n      &#125;\n    &#125;\n  &#125;\n\n\n과정은 생각보다 간단합니다.\n\n인스타그램이 요구하는 데이터의 타입을 맞춰주기 위해 UIImage 파일을 Data 타입으로 변환해줍니다.\n스키마 URL이 유효한 지 확인합니다. 앱에 등록되지 않은 스키마거나 기기에 설치되어 있지 않은 앱으로 연결 시 에러를 던져냅니다.\n변환한 이미지 파일을 UIPasteboard를 활용하여 복사해 저장합니다. .expirationDate를 통해 저장 기간을 설정해주었네요.\nURL 스키마를 열고 인스타그램 앱의 스토리 추가 화면을 실행합니다.\n\n과연 결과는!\nInfo.plist URL 등록 에러\n😏.. 한 번에 될 리가 없죠…\n  \n문제는 이곳에 있었습니다.\n분명 LSApplicationQuriesSchemas를 등록하라고 했었단 말이죠?\n공식 문서를 다시 읽어보고 수 차례 시도해봤지만 진전이 없어 값을 다시 복사-붙여넣기 해보았습니다.\n그랬더니..\n  \n아니 글쎄 키 값이 자동으로 바뀌었습니다..전에는 대체 왜..\n수정을 빠르게 해주고 다시 실행해봅시다.과연 이번에는..?\n데이터가 넘어오지 않는 버그\n\n오! 뭔가 되는 것 같아요! 🥳\n그런데 문제는 이미지 데이터가 넘어오지 않은 것 같죠…?\n무엇이 문제일까 또 살펴보던 중.. 사소한 수정을 제가 저질렀다는 사실을 깨달았습니다.\nlet pasteboardItems = [[\"com.instagram.backgroundImage\": backgroundImage]]\n\n바로 이 부분이에요!\nkey 값으로 &quot;com.instagram.backgroundImage&quot;를 주고 있죠..\n하지만 예제를 보면 &quot;com.instagram.sharedSticker.backgroundImage&quot;로 되어 있습니다..\n인스타그램 앱의 입장에서 보면 데이터를 찾으려고 살펴본 key값에 아무것도 없으니 넘겨받을 수 있는 데이터가 없는 것이였죠..\n사실은 저 key값은 제 앱에서 클립보드에 저장하기 위한 일종의 ID값이라고 생각하여 수정을 했었습니다.\n하지만 “인스타그램이 어떻게 값을 받아오는걸까”를 생각하다보니 코드 상에 데이터를 직접 넘겨주는 로직은 어디에도 없고 데이터와 관련된 값은 저 pasteboardItems 밖에 없더군요..\n결국은 key-value로 찾아내는 방법밖에 없겠다 싶어 저 부분을 원래대로 수정해보았습니다.\n\n\n와! 성공이네요!\n배경으로 사진이 들어간 것을 확인할 수 있습니다.\n스티커 자산 공유하기여기까지 성공했다면 스티커 레이아웃까지 추가하는 것은 아주 쉽습니다.\n\nprivate func shareToInstagram(background: UIImage?, sticker: UIImage?) &#123;\n    if\n      let background, let sticker,\n      let imageData = background.pngData(),\n      let stickerData = sticker.pngData() &#123;\n      self.backgroundImage(\n        backgroundImage: imageData,\n        stickerImage: stickerData,\n        appID: URLSchemes.instagramStory.url\n      )\n    &#125;\n  &#125;\n\n  private func backgroundImage(backgroundImage: Data, stickerImage: Data, appID: String) &#123;\n    if let url = URL(string: appID) &#123;\n      if UIApplication.shared.canOpenURL(url) &#123;\n        let pasteboardItems = [\n          [\n            \"com.instagram.sharedSticker.backgroundImage\": backgroundImage,\n            \"com.instagram.sharedSticker.stickerImage\": stickerImage // ✨ 쨔잔\n          ]\n        ]\n\n        let pasteboardOptions: [UIPasteboard.OptionsKey: Any] = [\n          .expirationDate: Date(timeIntervalSinceNow: 60 * 5)\n        ]\n        UIPasteboard.general.setItems(pasteboardItems, options: pasteboardOptions)\n        UIApplication.shared.open(url, options: [:])\n      &#125; else &#123;\n        // Error Handling\n      &#125;\n    &#125;\n  &#125;\n\n이렇게 key-value를 하나만 더 추가해주면 되거든요!\n완성\n\n자 이렇게 인스타그램 스토리로 원하는 이미지를 공유하는 방법을 공부해보았습니다!\n생각보다 굉장히 간단했던 것 같아요!\n작업물을 바깥에 공유할 수 있어서 뭔가 뿌듯한 공부였습니다. 😏\n","slug":"Swift/2023-05-30-Swift29","date":"2023-05-29T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Favor","author_index":"nomatterjun"},{"id":"865af57bf1f8e18b3c920c89fcdfd418","title":"28)🍎 Swift - RxDataSources와 reloadData","content":"😵 DataSource를  reload 하는 과정에서 문제 발생\n\nMyPage를 편집하는 View를 구현하던 중 하나의 Section 값이 업데이트 되면 다른 Section의 값이 초기값으로 돌아가는 현상을 마주했습니다.\n해당 View는 하나의 UICollectionView로 구성되었으며 최상단의 프로필&#x2F;배경 이미지 변경 부분은 Header, 이름&#x2F;ID&#x2F;취향 부분은 Section으로 구성되어 있습니다.\n  private lazy var dataSource: EditMyPageDataSource &#x3D; EditMyPageDataSource(\n    configureCell: &#123; [weak self] _, collectionView, indexPath, item in\n      switch item &#123;\n      case let .name(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        return cell\n      case let .id(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        return cell\n      case let .favor(isSelected, favor):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as EditMyPagePreferenceCell\n        cell.isButtonSelected &#x3D; isSelected\n        cell.favor &#x3D; favor\n        return cell\n      &#125;\n    &#125;, configureSupplementaryView: &#123; dataSource, collectionView, kind, indexPath in\n      switch kind &#123;\n      case EditMyPageCollectionHeaderView.reuseIdentifier:\n        let header &#x3D; collectionView.dequeueReusableSupplementaryView(\n          ofKind: kind,\n          for: indexPath\n        ) as EditMyPageCollectionHeaderView\n        return header\n      case UICollectionView.elementKindSectionHeader:\n        let header &#x3D; collectionView.dequeueReusableSupplementaryView(\n          ofKind: kind,\n          for: indexPath\n        ) as FavorSectionHeaderView\n        let headerTitle &#x3D; dataSource[indexPath.section].header\n        header.updateTitle(headerTitle)\n        return header\n      case UICollectionView.elementKindSectionFooter:\n        let footer &#x3D; collectionView.dequeueReusableSupplementaryView(\n          ofKind: kind,\n          for: indexPath\n        ) as FavorSectionFooterView\n        footer.footerDescription &#x3D; dataSource[indexPath.section].footer\n        return footer\n      default:\n        return UICollectionReusableView()\n      &#125;\n    &#125;\n  )\n\nDataSource를 바인딩하는 과정은 Rx와의 호환성을 고려하여 RxDataSources 라이브러리를 사용하고 있습니다.추가적으로 cell을 dequeue하고 identifier를 정의하는 과정을 편리하게 구현하기 위해 Reusable 라이브러리를 사용하고 있습니다.\n❓ 원인 파악각 Cell에 rx를 사용하여 데이터를 바인딩하는 과정에서의 문제, Reactor의 transform에서 newState가 새롭게 생성되는 문제 등을 고려했지만 결국에는 모두 아니였습니다.\n원인은 dataSource에 print문을 넣은 후에 발견할 수 있었습니다.\n  private lazy var dataSource: EditMyPageDataSource &#x3D; EditMyPageDataSource(\n    configureCell: &#123; [weak self] _, collectionView, indexPath, item in\n      switch item &#123;\n      case let .name(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        print(cell) &#x2F;&#x2F; 🖐️ 여기\n        return cell\n      case let .id(name, placeholder):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as FavorTextFieldCell\n        cell.bind(placeholder: placeholder)\n        cell.bind(text: name)\n        print(cell) &#x2F;&#x2F; 🖐️ 여기\n        return cell\n      case let .favor(isSelected, favor):\n        let cell &#x3D; collectionView.dequeueReusableCell(for: indexPath) as EditMyPagePreferenceCell\n        cell.isButtonSelected &#x3D; isSelected\n        cell.favor &#x3D; favor\n        return cell\n      &#125;\n\n문제가 발생하는 Section의 cell에 print문을 걸어보았습니다.\n\n\n각 Section에 하나의 Item만 포함되어 있으므로 취향 Section이 변경될때마다 모든 Section의 dataSource가 다시 정의되고 있었던 것입니다.\n모든 Section의 데이터가 reload되고 있다는 의심을 품고 RxDataSources 내부 코드를 파악해보기로 했습니다.\n❗ 원인 발견문제는 RxDataSources가 맞았습니다.\n일단 저희가 사용하고 있던 RxCollectionViewSectionedReloadDataSource의 경우는 다음과 같이 구성되어 있습니다.\nopen class RxCollectionViewSectionedReloadDataSource&lt;Section: SectionModelType&gt;\n    : CollectionViewSectionedDataSource&lt;Section&gt;\n    , RxCollectionViewDataSourceType &#123;\n    public typealias Element &#x3D; [Section]\n\n    open func collectionView(_ collectionView: UICollectionView, observedEvent: Event&lt;Element&gt;) &#123;\n        Binder(self) &#123; dataSource, element in\n            #if DEBUG\n                dataSource._dataSourceBound &#x3D; true\n            #endif\n            dataSource.setSections(element)\n            collectionView.reloadData() &#x2F;&#x2F; 👈 여기!\n                    collectionView.collectionViewLayout.invalidateLayout()\n        &#125;.on(observedEvent)\n    &#125;\n&#125;\n\nUIKit은 UICollectionView의 값을 reload하는 방법으로 크게\n\n모든 값을 reload하는 reloadData()\n특정 Section만을 reload하는 reloadSections()\n마지막으로 특정 Item만을 reload하는 reloadItem(at:)의 세가지 종류 API를 제공하고 있습니다.\n\n하지만 RxDataSources의 경우, 무조건 reloadData()를 호출하여 모든 값을 reload하고 있는 점을 볼 수 있습니다.\nChatGPT에게 물어보니 RxDataSources는 규모가 작은 데이터를 다룰 때 사용되는 것을 고려하여 설계되었고, 모든 값을 reload하는 것이 다른 trade-off와 비교했을 때 효율적으로 판단했다고 합니다.\n\n정확한 정보인지 개인적으로 출처를 찾아보려 했지만 찾아볼 수는 없었습니다..제보 받습니다.. 😅\n.name과 .id 섹션의 경우에는 View가 로드됐을 때 단 한 번만 데이터가 로드되기 때문에 모든 Section이 reload되는 경우 초기값으로 돌아가는 것입니다.\n혹시나 RxCollectionViewSectionedAnimatedDataSource는 변경되는 Section을 골라내서 부분적으로 reload가 되나 싶었지만..마찬가지로 애니메이션 처리만 부분적으로 처리되고 reload는 전체적으로 되고 있었습니다..\n‼️ 해결이를 해결하기 위해서는 두 가지 해결법이 있습니다.\n\nCustom DataSource 타입을 만들어 사용한다.\nRxDataSources를 사용하지 않는다.\n\nCustom DataSource 사용class FavorDataSource&lt;Section: SectionModelType&gt;: RxCollectionViewSectionedReloadDataSource&lt;Section&gt; &#123;\n  override func collectionView(_ collectionView: UICollectionView, observedEvent: Event&lt;[Section]&gt;) &#123;\n    Binder(self) &#123; dataSource, element in\n      dataSource.setSections(element)\n      collectionView.reloadSections([2], animationStyle: .none) &#x2F;&#x2F; 👈 테스트를 위해 고정적으로 2번째 섹션만 reload되도록\n      collectionView.collectionViewLayout.invalidateLayout()\n    &#125;.on(observedEvent)\n  &#125;\n&#125;\n\n첫 번째 방법입니다.\n위와 같이 Custom DataSource를 만들어 사용하는 방법입니다.\nreloadData() 대신 reloadSections나 reloadItem(at:)을 사용하는 Data Source를 따로 만들어 사용하는 방법입니다.\n테스트를 위해 우선 2번째 Section의 값들만 reload 되도록 구현해보았습니다.\n\n\nSection이 깜빡이긴 하지만 일단 원하는대로 동작은 하는군요..\n단점은 Section의 형태에 따라 DataSource를 View에 맞게 각각 만들어서 사용해야 할 가능성이 있다는 점이였습니다.\n“언제 어떤 Section을 reload해야하는가?”를 Generic하게 계산해주어야 한다는 점은 일반적인 경우에서도 꽤나 복잡한 로직을 필요로 하고, 추후 과정에서 스파게티 코드가 될 것이라는 생각이 들어 부적절하다고 판단하였습니다.\nRxDataSources 대신 DiffableDataSources 사용사실 가장 좋은 방법은 Native 기능을 사용하는 것이겠죠?\n저는 DiffableDataSources에 대한 충분한 공부를 한 뒤 저희 프로젝트의 RxData Source를 DiffableDataSources로 대체해도 문제가 없겠다는 판단을 하고 RxDataSources를 걷어내기로 결정하였습니다.\nRx를 사용하면서도 DiffableDataSources를 사용하는 데에는 아무 문제가 없을 것 같더라고요..\n\n\n\n\n\n\n\n\n\nbind(to:)를 사용하여 간편하게 데이터를 바인딩할 수 있다라는 장점만 포기한다면 RxDataSources를 걷어내는 데에는 아무 문제가 없었습니다.\n심지어 API를 사용하는 형태도 상당히 유사해서 러닝 허들도 낮은 편에 속했습니다.\n하지만 제 상황에서의 DiffableDataSources를 사용하는 가장 큰 이점은 제가 원하는 시점에 제가 원하는 Section이나 Item만을 업데이트 해줄 수 있다는 점이였습니다.\n자 이제 리팩토링을 해봅시다..! 🔥\n1. Section 정의우선 두 가지 프로토콜을 정의해주었습니다.\npublic protocol SectionModelType: Hashable &#123; &#125;\npublic protocol SectionModelItem: Hashable &#123; &#125;\n\nSectionIdentifier로 사용될 SectionModelType과 ItemIdentifier로 사용될 SectionModelItem 프로토콜입니다.\n이 두가지 프로토콜은 아무 기능도 하지 않고 오직 Hashable을 채택해주기만 했습니다. (DiffableDataSources에서 사용되려면 Hashable해야합니다!)\n추후에 필요하다면 기능을 추가해주겠지만 아직은 Generic에서의 타입 제한 용도로만 사용하고 있습니다.\nenum ProfileSectionItem: SectionModelItem &#123;\n  case profileSetupHelper(ProfileSetupHelperCellReactor)\n  case preferences(ProfilePreferenceCellReactor)\n  case anniversaries(ProfileAnniversaryCellReactor)\n  case memo\n  case friends(ProfileFriendCellReactor)\n&#125;\n\nenum ProfileSection: SectionModelType &#123;\n  case profileSetupHelper\n  case preferences\n  case anniversaries\n  case memo\n  case friends\n&#125;\n\n그리고 그 두가지 프로토콜을 채택한 예시입니다.\nSectionModelType을 채택한 Section들과 SectionModelItem을 채택한 Item을 정의해줍니다.\n2. Reactor State 변경var sections: [ProfileSection] &#x3D; []\nvar items: [[ProfileSectionItem]] &#x3D; []\n\nvar profileSetupHelperItems: [ProfileSectionItem] &#x3D; []\nvar preferencesItems: [ProfileSectionItem] &#x3D; []\nvar anniversaryItems: [ProfileSectionItem] &#x3D; []\nvar friendItems: [ProfileSectionItem] &#x3D; []\n\n저는 각 Section에 대응되는 Item들을 따로 관리해주고 있습니다.\n이렇게 하는 편이 데이터들을 수정해주는 로직을 짤 떄 편하더라구요..\nfunc transform(state: Observable&lt;State&gt;) -&gt; Observable&lt;State&gt; &#123;\n  return state.map &#123; state in\n    var newState &#x3D; state\n    var newSections: [ProfileSection] &#x3D; []\n    var newItems: [[ProfileSectionItem]] &#x3D; []\n    var profileSetupHelperItems: [ProfileSectionItem] &#x3D; []\n\n    &#x2F;&#x2F; 취향\n    if !state.preferencesItems.isEmpty &#123;\n\t  newSections.append(.preferences)\n\t  newItems.append(state.preferencesItems)\n    &#125; else &#123;\n    profileSetupHelperItems.append(.profileSetupHelper(ProfileSetupHelperCellReactor(.preference)))\n    &#125;\n    &#x2F;&#x2F; 기념일\n    if !state.anniversaryItems.isEmpty &#123;\n\t  newSections.append(.anniversaries)\n\t  newItems.append(state.anniversaryItems)\n    &#125; else &#123;\n    profileSetupHelperItems.append(.profileSetupHelper(ProfileSetupHelperCellReactor(.anniversary)))\n    &#125;\n    &#x2F;&#x2F; 친구\n    newSections.append(.friends)\n    newItems.append(state.friendItems)\n    &#x2F;&#x2F; 새 프로필\n    if !profileSetupHelperItems.isEmpty &#123;\n\t  newSections.insert(.profileSetupHelper, at: .zero)\n\t  newItems.insert(profileSetupHelperItems, at: .zero)\n    &#125;\n  \n    newState.sections &#x3D; newSections\n    newState.items &#x3D; newItems\n    return newState\n  &#125;\n&#125;\n\n각 Item들에 대한 데이터들은 transform(state:)에서 통합해주는 방식으로 처리해주고 있습니다.\n3. DataSource에 바인딩reactor.state.map &#123; (sections: $0.sections, items: $0.items) &#125;\n  .asDriver(onErrorRecover: &#123; _ in return .empty()&#125;)\n  .drive(with: self, onNext: &#123; owner, sectionData in\n\tvar snapshot: NSDiffableDataSourceSnapshot&lt;ProfileSection, ProfileSectionItem&gt; &#x3D; .init()\n\tsnapshot.appendSections(sectionData.sections)\n\tsectionData.items.enumerated().forEach &#123; idx, items in\n\t  snapshot.appendItems(items, toSection: sectionData.sections[idx])\n\t&#125;\n\towner.dataSource.apply(snapshot, animatingDifferences: false)\n  &#125;)\n  .disposed(by: self.disposeBag)\n\nsections와 items 모두 Hashable하기 때문에 위와 같이 appendSections, appendItems 등의 DiffableDataSources의 API를 사용하여 dataSource에 바인딩해주면 끝입니다!\n","slug":"Swift/2023-05-07-Swift28","date":"2023-05-06T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Favor","author_index":"nomatterjun"},{"id":"c1d9a7680cb448c25291810a696ba7e7","title":"27)🍎 Swift - CollectionView의 Cell/View에서의 subscribe 문제","content":"❓ CollectionView의 HeaderView를 구독하는 과정에서 문제 발생\nHeaderView의 버튼을 tap하면 바인딩된 Action이 여러번 발생하는 문제 발생\n\n\n\n\nconfigureSupplementaryView: &#123; dataSource, collectionView, kind, indexPath in\n\n  let sectionItem = dataSource[indexPath.section]\n\n  let header = collectionView.dequeueReusableSupplementaryView(\n\n    ofKind: kind,\n\n    for: indexPath) as HeaderView\n\n  header.reactor = HeaderViewReactor(section: sectionItem.model)\n\n  header.rx.rightButtonDidTap\n\n    .map &#123; Reactor.Action.rightButtonDidTap(sectionItem.model) &#125;\n\n    .bind(to: self.reactor!.action)\n\n    .disposed(by: self.disposeBag)\n\n  return header\n\n&#125;\n\n\n해당 HeaderView는 위와 같이 할당되어 있습니다.\n의심 1. DashboardFlow의 복제?해당 문제가 발생한 시점이 DashboardFlow를 건드릴 때였고, 확신을 갖지 못한 상태에서 작업을 하고 있었기 때문에 우선적으로 의심하였습니다.\n실제로 다른 Flow로 이동 후에 다시 돌아와 같은 작업을 수행하면 횟수가 증가하는 현상을 발견하였기에 의심을 키워가고 있었지만…\n\n메모리 스냅샷을 살펴본 결과 DashboardFlow는 단 한 개만 생성되어있다..\n추가적으로 의심되던 부분인 .contribute(withNext: self.rootViewController) 부분을 주석처리하고 앱을 실행해도 같은 문제가 발생하는 것을 보아 이 부분은 문제가 아닌 것으로 보임..!\n의심 2. 모든 HeaderView의 Action이 트리거되었다..?HomeViewReactor의 해당 Action을 받는 부분에서 로깅을 해보았다.\n\ncase .rightButtonDidTap(let sectionType):\n\n  let type = \"\\(sectionType)\"\n\n  os_log(.debug, \"\\(type)\")\n\n  switch sectionType &#123;\n\n  case .upcoming:\n\n    self.steps.accept(AppStep.reminderIsRequired)\n\n  case .timeline:\n\n    self.steps.accept(AppStep.filterIsRequired(self.currentSortType.value))\n\n  &#125;\n\n  return .empty()\n\n&#125;\n\n\n\n그랬더니 두 개의 섹션(timeline, upcoming)에서 각 두 번씩 로깅이 되고 있는 것을 발견하였다.\n아니 그런데.. \n\nconfigureSupplementaryView: &#123; dataSource, collectionView, kind, indexPath in\n\n  let sectionItem = dataSource[indexPath.section]\n\n  let header = collectionView.dequeueReusableSupplementaryView(\n\n    ofKind: kind,\n\n    for: indexPath) as HeaderView\n\n  header.reactor = HeaderViewReactor(section: sectionItem.model)\n\n  header.rx.rightButtonDidTap\n\n    .map &#123; Reactor.Action.rightButtonDidTap(sectionItem.model) &#125;\n\n    .bind(to: self.reactor!.action)\n\n    .disposed(by: self.disposeBag)\n\n  return header\n\n&#125;\n\n\ndrive로 구독하고 있는 것도 아니고 bind로 구독하고 있어서 스트림이 공유되는 것도 아닌데 왜 모든 헤더에서 Action이 트리거 되는거지..?\n❗ 실마리 발견\n그러던 중 헬프를 요청한 팀원에게 받은 댓글…!\n애초에 구독이 여러번 되고 있다는 제보…!\n바로 테스트 돌입..\n\nself.collectionView.rx.didEndDisplayingSupplementaryView\n\n  .asDriver(onErrorRecover: &#123; _ in return .empty()&#125;)\n\n  .drive(with: self, onNext: &#123; _, endDisplayingView in\n\n    print(endDisplayingView)\n\n.disposed(by: self.disposeBag)\n\n\n위 처럼 HeaderView가 화면에서 사라질 때마다 로깅을 하고 실행을 해보았다.\n\n\n우선 HomeVC가 로드 되며 두 번씩 출력이 되고..\n\n\n\n\n\n\n\n\n\n\n\n\n기본 2회 + endDisplaying 1회 → 3회\n\n\n\n\n\n\n\n\n\n\n\n기본 2회 + endDisplaying 3회 → 5회  \nHeaderView를 didEndDisplaying 시킬 때마다 해당 현상의 횟수가 증가하는 것을 확인했다..\n어떻게 찾았대…\n그래서 원인은 알았는데 어떻게 해결하지..?\n해결\n혹시나 싶어서 HeaderView 자체는 몇개인지 확인해보았습니다.\n여러번 endDisplaying 시켜준 뒤 확인해보았지만 정상적으로 두 개만 메모리에 올라가있는 상황이네요…\nView 자체는 문제가 없지만 subscribe만 여러번 되고 있고, 그것들이 유지되고 있다는 상황입니다..\n해결 시도 #1결국 문제는 HeaderView는 재사용되기 때문에 didEndDisplaying 된 후 다시 willDisplay 될 때마다 configureSupplementaryView가 실행되어서 새로운 구독이 늘어나고 있는 것이다.\n그러면 didEndDisplaying이나 willDisplay가 될 때마다 구독을 해제해주면 되는 것이 아닌가..?\n\nself.collectionView.rx.didEndDisplayingSupplementaryView\n\n  .asDriver(onErrorRecover: &#123; _ in return .empty()&#125;)\n\n  .drive(with: self, onNext: &#123; _, endDisplayingView in\n\n    let (view, _, _) = endDisplayingView\n\n    guard let view = view as? HeaderView else &#123; return &#125;\n\n    print(view)\n\n    view.disposeBag = DisposeBag()\n\n  &#125;)\n\n  .disposed(by: self.disposeBag)\n\n\n그래서 위와 같이 고쳐보았다.\n\n\n하지만 어림도 없지..\n새로운 DisposeBag으로 갈아 끼워주는 것 만으로는 구독이 해제되지 않고 있다.\n해결시도 #2해결 시도 #2 이긴 하지만 도중에 해결 방법을 찾아버렸습니다.\n\nheader.rx.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didEndDisplayingSupplementaryView:forElementOfKind:at:)))\n\n  .subscribe(onNext: &#123;\n\n  \n\n  &#125;)\n\n  .disposed(by: &lt;#T##DisposeBag#>)\n\n\n여기까지 작성을 했는데요.. diseposed(by:)를 작성하는 도중에 갑자기 의문이 들었습니다.\n손이 가는대로 disposed(by: self.disposeBag)를 치던 찰나…\n머릿속 잠재의식이 저를 한 대 쳤습니다..\n\nheader.rx.rightButtonDidTap\n\n  .map &#123; Reactor.Action.rightButtonDidTap(sectionItem.model) &#125;\n\n  .subscribe(onNext: &#123;\n\n    self.reactor!.action.onNext($0)\n\n  &#125;)\n\n  .disposed(by: self.disposeBag)\n\n\n다시 subscribe를 하던 코드로 돌아가봅시다.\n여기서 self는 HeaderView가 아니라 HomeViewController입니다.\nHeaderView의 구독은 HeaderView의 dequeueReusable에 따라 동작해야하는데 말이죠…\n그래서 해결 방법은 아주 간단합니다.\n\nheader.rx.rightButtonDidTap\n\n  .map &#123; Reactor.Action.rightButtonDidTap(sectionItem.model) &#125;\n\n  .subscribe(onNext: &#123;\n\n    self.reactor!.action.onNext($0)\n\n  &#125;)\n\n  .disposed(by: header.disposeBag) // 👊 이 부분\n\n\nself.dispseBag을 header.disposeBag으로 바꿔주기만 하면 됩니다..\n오늘도 또 한 번 생각없이 하는 코딩은 위험하다는 것을 느끼고 지나갑니다..\n🎉 해결!\n\n얏호..!\n휴.. 반성해라 나 자신..\n","slug":"Swift/2023-04-12-Swift27","date":"2023-04-11T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Favor","author_index":"nomatterjun"},{"id":"d77fc5a0b46ee953e78fea8c5bdb21ac","title":"26)🍎 Swift - Concurrency","content":"ConcurrencyWWDC21의 주요 주제는 Concurrency라고 생각합니다.\n21년에 처음 공개된 후 관련된 포스트도 많아졌고 서드파티 라이브러리에서도 대응 업데이트가 많이 이루어진 상황입니다.\n이제 슬슬 실무에 사용되는 모습들도 보이기 시작하는 것 같습니다.\n어렴풋이 “async와 await를 사용하는 문법이다.” 정도로만 알아두고 나중에 공부해야겠다 생각했지만 프로젝트에서 callback 지옥을 본 순간.. 학구열이 올라 한 번 학습해봤습니다.\nWWDC21의 세션들을 살펴보았더니 관련 세션만 거의 10개에 달하고 하나하나의 내용들도 꽉 찬 20~30분 정도를 이루고 있더군요..\n그래서 내용이 무지무지 많습니다.. 🫠\n비동기 프로그래밍비동기 코드는 “나중에 언젠가 호출되어 실행될 코드” 입니다.\n그 시기는 보장되지 않으며 순서 또한 보장되지 않을 때도 있습니다.\nSwift에서는 우리가 흔히 GCD라고 부르는 DispatchQueue를 통해 지원하는 개념이였죠.\nprint(&quot;1&quot;)\nDispatchQueue.main.async &#123;\n  print(&quot;2&quot;)\n&#125;\nprint(&quot;3&quot;)\n\n위 코드의 print(&quot;2&quot;) 구문은 비동기 코드입니다.\n따라서 순서와 호출 시기가 불확실합니다.\n바로 호출될수도 있고 아닐수도 있죠.\n\n\n\n\n\n\n\n\n\n1 2 3\n\n\n\n\n\n\n\n\n\n1 3 2\n그래서 위와 같이 실행마다 결과가 다를수도 있습니다.\n비동기코드는 1. 해당 라인에 도달되도 바로 실행되지 않고, 2. 이후에 있는 코드의 실행을 Blocking하지도 않습니다.\n비동기 코드가 언제 실행되는지 모른다면, 비동기적으로 산출된 어떤 값을 언제 사용해야 할까요?\n다행히도 비동기 코드가 종료되는 시점은 우리가 알 수 있습니다.\n@escaping 클로저를 통해서요.\nfunc foo() &#123;\n  print(&quot;1&quot;)\n  asyncFoo(completion: &#123; value in\n    print(value)\n  &#125;)\n  print(&quot;3&quot;)\n&#125;\n\nfunc asyncFoo(completion: @escaping (String) -&gt; Void) &#123;\n  DispatchQueue.main.async &#123;\n    let a &#x3D; &quot;2&quot;\n    completion(a)\n  &#125;\n&#125;\n\nasyncFoo 메서드에서 completion 클로저는 async 함수가 종료되는 시점에 호출되어 콜러인 foo 메서드에 String 타입 파라미터 value를 제공합니다.\n이런 방식의 문법은 어떤 함수가 끝났을 때의 동작들의 묶음을 명시적으로 모아둘 수 있다는 장점이 있지만 (장점인가..?) callback 지옥과 코드 가독성이 떨어진다는 문제점을 가집니다.\nGCD의 진짜 문제점코드의 가독성과 개발자에게 주는 불쾌한 경험도 중요하지만 GCD에는 더욱 크리티컬한 단점이 존재합니다.\n바로 CPU의 불필요한 추가 동작과 과도한 리소스의 사용을 유발할 수 있다는 점입니다.\n이게 무슨 말인지 살펴볼까요?\nDispatchQueue에 동작이 enqueue되면, 시스템은 해당 작업이 수행될 쓰레드를 불러오고 수행시킵니다.\n만약 무수히 많은 동작들이 enqueue되면, 시스템은 해당 동작들을 동시에 수행하기 위해 쓰레드를 계속해서 불러옵니다. CPU의 코어가 더 이상의 쓰레드 작업을 추가할 수 없을 때까지요.\n\n\n\n\n\n\n\n\n\n\n코어가 2개인 환경에서 쓰레드를 추가적으로 불러오는 상황\n하나의 코어가 여러개의 쓰레드를 가지고 있는 이유는 여러가지입니다.\n\n하나의 쓰레드가 Block되더라도 코어가 쉬지않고 다른 쓰레드의 작업을 할 수 있도록 하기 위해\n쓰레드간의 Race Condition을 해결하기 위해 (Semaphore 참고)\n\n그런데 과연 Blocking된 쓰레드가 많아진다고 쓰레드를 무수히 많이 불러오는 것이 항상 좋을까요?\n\n당연히 아니겠죠..\n쓰레드들이 Blocking된 상태에서 추가적으로 쓰레드를 계속 불러온다면, 더 이상 코어가 쓰레드를 불러올 수 없는 상태가 됩니다.\n해당 현상을 Thread Explosion이라고 부릅니다.\n\n\n\n\n\n\n\n\n\nSwift는 이를 해결하기 위해 DispatchSemaphore와 같은 기능을 제공하고 있기는 합니다. 문제는 너무 복잡하다는 것이죠..!\nThread Explosion 현상이 발생하면 OS는 여러 문제를 마주칩니다.\n\n\n메모리 오버헤드: Block된 쓰레드는 각자 메모리와 리소스를 점거하고 있습니다. 다른 쓰레드의 unlock을 위해 필요한 리소스를 점거하고 있을 수도 있죠.\n\n\n\n스케줄링 오버헤드: CPU의 코어는 쓰레드간의 전환을 위해 컨텍스트 스위칭(Context Switching) 이라는 작업을 수행해야 합니다. 쓰레드가 폭발적으로 많아지면 컨텍스트 스위칭도 빈번히 일어나 불필요한 작업이 늘어납니다.\n\n자 그래서 Swift는 이런 현상을 어떻게 해결했느냐?\nasync &#x2F; await새로운 Swift의 asynchronous 개념 async / await와 concurrency를 통해서죠.\n실은 멀티 쓰레딩의 이러한 오버헤드들은 이전부터 다양한 언어와 운영체제 전문가들에게 문제시 되어왔습니다.\n이들이 제시한 방법은 바로 Coroutine 방식이였습니다.\n오래전 멀티쓰레딩 방식이 제시되고 통용되기 시작하며 자연스럽게 버려졌던 Coroutine 방식이 현대에 와서 다시 연구되고 발전하고 있죠.\n실제로 Python, Kotlin과 같은 언어들이 적극적으로 Coroutine 방식을 사용하고 있습니다.\n그래서 Coroutine 방식은 어떤 방식이냐?\n코루틴(Coroutine) 은 CPU의 코어 개수만큼만 쓰레드를 만들고 쓰레드를 차단하는 대신 작업을 막아둠으로써 컨텍스트 스위칭을 차단합니다.\n\nSwift 용어로 바꾸어볼까요?\nSwift Concurrency는 쓰레드의 차단(Blocking)을 없애고 작업의 재실행(Resumption of Work)를 추적하는 continuation이라는 객체를 통해 Context Switching 대신 같은 쓰레드 내에서 Continuation Switching을 수행하여 동시성 프로그래밍을 지원합니다.\n자 Concurrency가 (모순적이게도) 현대적이고 좋다는 건 알았어요.\n그래서 async / await은 어떻게 사용할까요? 😒\nWWDC에서도 사용한 기존의 @escaping 클로저를 사용하는 예시를 가져와봤어요.\n\n시스템적인 단점 말고 코드 작성의 측면에서 @escaping 클로저 방식은 세가지 단점을 가지고 있습니다.\n\ncompletion 클로저 호출을 까먹기 쉽습니다. (여러군데에 필요)\ncallback이 중첩해서 발생하는 경우가 많습니다.\n코드 가독성이 떨어집니다.\n\n자 그런데 async / await를 사용한 코드로 바꿔보면요?\n\n엄청 짧아지고 수많았던 중괄호들이 사라졌어요! 👏\nasync함수의 파라미터와 반환타입 중간에 async 를 붙여줌으로써 해당 함수가 비동기성이다 라는 것을 나타내줍니다!\nthrows를 통해 해당 함수가 에러를 방출할 수 있다라는 것도 함께 명시해줄 수 있습니다.\nawaitasync로 정의된 함수를 호출하기 위해서는 Concurrent Context 내부에서 await 키워드를 붙여주어야 합니다.\nlet (data, response) &#x3D; try await URLSession.shared.data(for: request)\n\n주의할 점은 정의할때는 순서가 async throws지만, 사용할때는 try await 순서라는 것을 알아두어야합니다.\nawait 키워드는 해당 라인이 Suspension Point라는 것을 명시하는 역할을 합니다.\nSuspendawait 포인트를 만나면 된다는 Suspend는 또 뭘까요?\nSuspend는 “해당 스레드가 다른 동작을 수행할 수 있도록 스레드의 통제권을 시스템에게 넘겨준다” 라는 것을 의미합니다.\n\n일반적인 synchronous한 코드의 경우에는 위와 같이 동작합니다.\nfetchThumbnail 함수에서 thumbnailURLRequest 함수를 호출하고 있습니다.\n이 때 두 함수 모두 sync 함수이기 때문에 fetchThumbnail 함수는 thumbnailURLRequest 함수에게 쓰레드 제어권을 넘겨줍니다.\nthumbnailURLRequest 함수는 수행에 얼마나 많은 시간이 걸리던 쓰레드를 점유하고 작업이 완료되면 제어권을 다시 Caller인 fetchThumbnail 함수에게 돌려줍니다.\n이 경우 쓰레드는 이 두 작업 외의 다른 작업들을 수행할 수 없습니다.\n\nasynchronous한 경우에는 어떨까요?\nfetchThumbnail 함수가 data(for: request) 함수에게 쓰레드 제어권을 넘겨주는 것까지는 동일합니다.\n하지만 await로 명시된 data(for: request) 함수는 async 함수이기 때문에 중간에 suspend 될 수 있습니다.\nasync 함수가 suspend되면, 쓰레드 제어권은 다름아닌 시스템에게 넘겨집니다.\n그러면 시스템은 다른 작업을 할 수 있게 되는 것이죠.\n시스템은 알아서 suspend 되거나 수행이 필요한 다른 작업들의 우선순위들을 판단해가며 처리해나갑니다.\n시스템이 suspend 되었던 함수의 처리가 필요해졌다고 판단하는 순간, 쓰레드 제어권은 다시 async 함수였던 data(for: request) 함수에게 재개(resume)되고 이후의 작업들이 수행될 수 있게 됩니다.\n자 다시 돌아가서 Suspend가 이루어지는 과정을 자세히 살펴볼게요.\n\nSynchronous한 함수의 경우 메모리의 스택 영역에 함수들이 push 되며 쌓이게 됩니다.\n그러다가 함수의 실행이 끝나면 pop 되어 스택에서 제거되죠.\n아주 간단명료합니다.\n그러면 asynchronous한 경우에는 어떨까요?\n\nasync 함수라고 명시되어 있는 경우, scope 전체를 한 번 돌며 suspension point(await) 마다 어떤 변수가 여러 쓰레드에서 사용되는지를 파악합니다.\n예시의 경우, id와 particle은 쓰레드 사이를 오갈 필요가 없는 local 변수이죠?\n따라서 해당 변수들은 synchronous 함수의 경우와 마찬가지로 스택 영역에 저장됩니다.\n\n그렇다면 await에서 사용된 newArticles 변수(파라미터로 받았기 때문에 상수이지만 편의상 변수라고 하겠습니다.)의 경우는 어떨까요?\nsuspend되는 코드는 잠깐 멈춰있다가 다시 실행되야하기 때문에 필요한 변수들을 멈추기 이전과 이후 모든 시점에 사용할 수 있어야 합니다.\nSwift는 이를 위해 Heap 영역을 활용합니다.\n\nadd 함수를 힙 영역에 저장하고 나면 스택 영역에는 해당 프레임을 계속 붙잡고 있을 필요가 없기 때문에 실행이 필요한 save 함수로 대체됩니다.\n\n이 save 함수 안에 마찬가지로 await 코드가 담겨있다고 가정해보면, 해당 save 함수 또한 힙 영역으로 옮겨진 후 시스템에 쓰레드 제어권을 넘겨주게 됩니다.\n\n쓰레드는 다른 작업들(otherWork1, otherWork2)을 마찬가지로 힙 영역에 보관하며 수행합니다.\n따라서 힙 영역에는 async 함수들의 스택들이 모여있게 되는 것이죠.\nContinuation이라는 것이 이런 힙 영역의 async 스택을 대표한다고 합니다.\n\n\n\n\n\n\n\n\n\nContinuation이란 단순히 await 이후에 수행되는 작업들을 표현하는 말이라고 합니다. withCheckedThrowingContinuation(continuation:)과 같은 메서드에서 사용되니 참고해주세요!\n\n작업이 없는 쓰레드가 생기고 힙 영역에 저장된 async continuation이 다음 작업으로 선택되면, 힙 영역에 있던 작업 스택을 하나씩 다시 스택 영역으로 불러와 차근차근 작업을 수행합니다.\n\n\n\n\n\n\n\n\n\n이 때, 작업이 없는 쓰레드라는 것은 await 이전에 수행하던 쓰레드일수도 있고 아닐 수도 있습니다. 보장되지 않는다는 것이죠.\n자 그래서 이 async / await를 이용한 Concurrency는 어떻게 사용하면 될까요?\nTask\n위의 예시를 여러번 수행하는 또 다른 예시입니다.\n이 예시는 상당히 좋은 예시이고 아주 정상적으로 잘 동작하는 예시입니다.\n하지만 한 가지 개선이 필요한 부분이 있습니다.\nfor in을 통해서 여러번의 URLSession을 await하는 것인데요.. 이런 식의 구현은 한 번에 하나의 루프만을 수행할 수 있습니다.\nasync하게는 구현하였지만 concurrent하지는 못한 것입니다.\n또한 fetchThumbnails()이라는 함수 또한 결국에는 async 함수이기 때문에 프로젝트의 어딘가에서는 async 컨텍스트를 제공해줄 곳이 필요합니다.\n이 때 Task가 등장합니다.\nTask는 concurrent한 코드 수행을 위한 새로운 async 컨텍스트를 제공합니다.\n\n\n\n\n\n\n\n\n\nasync 함수를 단순히 call 하는 것은 Task를 생성하지 않습니다! (GCD 등을 사용하면 call 할 수는 있습니다.)\n하지만 어떤 Task들이 있나 보기 이전에 Task Tree라는 개념을 알아두어야 합니다.\nTask TreeTask Tree는 Task의 취소(cancellation), 우선순위(priority), 지역변수(task-local variables) 등의 속성들을 결정하는 아주 중요한 개념입니다.\n기본적으로는 어떤 async 함수가 다른 async 함수를 호출하면, 두 함수를 호출하는 데에는 같은 Task가 사용됩니다.\n\n아래 async-let에서 사용된 예시의 경우를 먼저 한 번 가져와봤습니다.\nfetchOne() 함수가 두 가지의 Task data와 metadata를 호출하는 경우입니다.\nfetchOneThumbnail() 함수는 두 가지 Task를 child로 갖고 있다고 했습니다.\n이처럼 한 Task가 다른 Task를 실행하면 실행된 Task들은 현재 함수가 실행되고 있는 Task의 Child Task가 됩니다.\n\n\n\n\n\n\n\n\n\nTask는 함수에 종속된 개념은 아니지만 함수의 생명주기에 영향을 받을 수는 있습니다.\n그리고 Parent Task는 종속된 모든 Child Task들이 종료되기 전에는 종료될 수 없습니다.\n만약 metadata Task가 에러를 throw하면서 종료되었다는 상황을 가정해봅시다.\n두 Task는 같은 guard 문 내에 있기 때문에 즉시 에러를 throw하고 함수를 종료할 수 있겠죠?\n하지만 Task에서는 그렇지 않습니다. 정확히 말하면 “즉시” 종료하지는 않습니다.\nmetadata Task가 실패했더라도 data Task는 여전히 동작중일 것입니다.\n따라서 해당 Task가 취소되었다는 정보를 제공해주고 Task가 종료되기를 기다렸다가 모든 Task가 종료된 시점에 함수가 종료됩니다.\n\n\n\n\n\n\n\n\n\n여기서 취소되었다(cancelled) 라는 것은 해당 Task를 종료시키는 것이 아니고 결과가 더 이상 필요없다는 것을 알려줄 뿐입니다.\n\n만약 취소된 Task가 Child Task를 가지고 있다면 모든 Child Task들 또한 취소됩니다.\n이러한 Task Tree 동작은 ARC와 같이 실수로 벌어지는 Task Leak를 방지하기 위함이라고 합니다.\n이런 Task Tree의 특성을 정리하면 다음과 같이 표현할 수 있습니다.\nTask의 취소는 협력적(cooperative) 으로 이루어집니다.\n\nTask는 취소되더라도 즉시 종료되지 않습니다.\nTask의 취소 여부는 어디에서도 가능합니다. (synchronous한 코드에서도)\n\n이는 개발자가 Task가 취소되었을 때의 동작을 구현할 수 있게 하기 위함이라고 하네요.\n\n\n\n\n\n\n\n\n\n이 말은 Task가 오래 걸리는 동작일수록 취소에 대응하는 코드가 꼭 필요하다라는 뜻 같습니다.\n설명만으로는 무슨 말인지 잘 모르겠으니 예시를 다시 가져와보죠!\n\n위와 같이 concurrent한 동작이 수행되기 전에 Task.checkCancellation()나 if Task.isCancelled &#123; break &#125;을 통해 불필요한 썸네일 생성의 동작을 방지하고 에러를 방출할 수 있습니다.\n\n\n\n\n\n\n\n\n\n위 예시의 경우 Task가 취소되었더라도 thumbnails에는 취소되기 이전에 성공한 데이터들이 담겨있고, 그 데이터들이 그대로 반환됩니다. 빈 데이터 등의 결과는 UI에 에러를 발생시킬 수 있기 때문에 염두에 두고 작업해야합니다.\n이제 우리는 Task가 언제 취소되거나 완료되는지를 알았습니다! 😎\n드디어 Swift가 제공하는 다양한 형태의 Task를 알아볼 때가 되었네요. 하나씩 살펴보죠!\nStructured Tasksasync-let Tasks\n지금까지의 URLSession.data() 함수는 위와 같이 사용되었습니다.\n화살표의 방향대로 단 한가지의 흐름(단방향)만이 존재합니다.\n하지만 우리는 URLSession은 시간이 걸리는 함수이기 때문에 수행 시간동안 다른 작업들이 수행되길 원합니다.\n\nasync-let을 사용하면 위처럼 흐름이 두 가지로 나뉘어집니다.\nChild Task가 생성되고, URLSession.data() 함수를 async하게 실행함과 동시에 result에는 임시 값(placeholder) 을 넘겨준채로 await 키워드가 등장할 때까지 수행합니다.\nawait에서 기다리던 작업은 async 함수가 끝이 나면 result 값을 대체하여 사용합니다.\n\n그렇다면 위 코드를 async-let을 사용하는 방식으로 바꾸려면 어떻게 해야할까요?\ntry await은 child task에게 작업을 넘겨줬기 떄문에 더 이상 해당 함수를 호출하는 지점에서는 필요가 없습니다.\nParent task에서 결과로 나온 변수를 사용할 때 필요하죠.\n따라서 다음과 같이 바꿔줄 수 있습니다.\n\n각각의 URLSession에서 try await을 제거하는 대신 맨 앞에 async를 붙여주고,\nParent task인 fetchOneThumbnail() 함수에서 data와 metadata가 필요한 순간에 try await 을 사용하고 있습니다!\nGroup Tasksasync-let은 수행해야하는 Task의 개수가 정해져있을 때 유용합니다.\n\n다시 한번 위 예시의 경우를 보면, 몇 개의 썸네일을 생성하던지 간에 fetchOne이라는 Task는 고정적으로 두 개의 Child Task를 가지고 있습니다.\n하지만 id의 개수에 따라서는 수행할 fetchOne() 함수가 실행될 Task의 개수는 달라지겠죠?\nTask Group은 이런 경우에 유용합니다.\nTask Group은 동적 개수의 Task의 수행이 동시에 필요할 때 사용되기 위해 고안되었습니다.\n\nwithThrowingTaskGroup(of:) 를 통해서 Task Group을 만들어줄 수 있습니다.\n이 함수는 Child Task를 생성하는 group 이라는 인스턴스를 사용하는 Context를 제공합니다.\n또한 for 루프의 각 루프들은 group.async를 통해 비동기적으로 수행되기 때문에 랜덤한 시기에 순서 상관 없이 수행될 수 있습니다.\ngroup 인스턴스가 루프를 전부 돌았더라도 Task Tree의 특성에 의해 모든 Task가 종료될 때까지 await된다는 것도 알 수 있겠죠!\n그런데.. 모든게 평화로워 보이는 위 코드는 놀랍게도 심각한 에러를 가집니다.. 😰\n심지어 빌드도 안되는 컴파일러 에러를 내뿜죠..\n\n바로 Data Race Issue가 발생하기 때문입니다..\n\n\n\n\n\n\n\n\n\nData Race Issue는 한 번에 여러 개의 Task에서 하나의 데이터에 접근할 때 발생하는 에러입니다. 하나의 변수는 한 번에 하나의 연산만 가능하지만, 여러 Task에서 동시에 값을 수정하려고 하면 크러쉬가 나거나 데이터가 손상되게 됩니다..\n이 경우에는 하나의 thumbnails 딕셔너리에 여러 Task들이 동시에 값을 넣어주고 있죠?\n이는 Concurrency 프로그래밍을 할 때 개발자들이 흔히 하는 실수 중에 하나입니다.\nData Race Issue의 해결은 개발자에게 달려있었습니다.\n하지만 업데이트된 Swift Concurrency는 이를 컴파일러에서 미리 발견하여 에러를 발생시켜주는 것이죠! 👏 (이렇게 들으니까 멋지죠?)\n그래서 에러를 잡아주긴 하는데 해결은 어떻게 해야할까요?\nTask는 사실 @Sendable 클로저라는 클로저에 의해 감싸져 있습니다.\n@Sendable 클로저의 캡처는 독특하게도 mutable 변수의 값을 캡처하지 못합니다.\n그러면 어떤 값들을 캡처할 수 있는가 하면?\n값 타입(Int, String, …) 변수, actors, 고유한 synchronization을 가진 class 를 캡처하거나 사용할 수 있습니다.\n다시 예시로 돌아가서 에러를 고쳐볼게요..\n\nthumbnails에 직접적으로 값을 대입하는 대신, String 타입과 UIImage 타입의 튜플을 반환하는 방식으로 변경합니다.\n그 후에 for await 루프를 통해 순차적으로 값들을 thumbnails에 대입해주고 있습니다.\nAsyncSequence 프로토콜을 채택한 값을 다루고 있다면 for await 루프를 사용해볼 것을 권장하고 있네요.\n자.. 여기까지 알아본 async-let 과 Grouped Tasks는 Structured Task라는 각자의 hierarchy가 정돈된 Task들을 처리하는 방식이였습니다.\n하지만 언제나 정돈된 방식을 사용할 수 있는 건 아니기 때문에 Swift는 Unstructured Tasks라는 API를 추가로 제공하고 있습니다.\nUnstructured TasksHierarchy가 정돈되지 않은 Task에는 어떤 Task들이 있을까요?\n먼저, Parent Task가 존재하지 않을 수 있습니다. async하지 않은 컨텍스트에서 async한 Task를 시작해야할 때가 이런 경우죠.\n또 Task가 하나의 scope를 넘어 여러 scope에서 이루어지도록 할 필요가 있을 때도 있을겁니다.\n보통 delegate 패턴을 사용할 때 흔히 일어나는 일이라고 하네요.\n\n위 예시를 봅시다..\ndelegate 함수인 collectionView(willDisplay:, forItemAt) 함수는 UI 레이어의 함수이기 때문에 async하지 않습니다.\n하지만 데이터를 받아오는 fetchThumbnails() 함수는 async 함수이죠.\n이럴 때가 바로 Unstructured Task를 사용할 때입니다.\n\n간단하게 async 처리가 필요한 곳은 Task로 감싸줍니다.\n런타임동안 이 Task를 생성하는 부분을 마주치게 되면, 수행하는 scope와 같은 actor에서 실행되도록 예약을 해둡니다.\n예시의 경우에는 MainActor에서 실행이 될 겁니다.\n이렇게 사용하기 간편하다면 단점도 당연히 있겠죠?\nTask의 생명주기가 scope에 종속되지 않고 synchronous한 코드 중간에서도 호출이 될 수 있기 때문에 Structured Task에서 자동으로 수행될 수 있었던 취소와 await를 개발자가 직접 해줘야 합니다.\n\n이 경우, Task를 생성한 뒤에 thumbnailTasks라는 딕셔너리에 저장하였습니다.\n그러면 나중에도 언제든지 접근해서 작업을 취소할 수 있겠죠?\ndefer문을 사용해 Task가 끝난 시점에 저장된 Task를 해제함으로써 이미 완료된 Task를 취소하는 일도 방지해둔 것을 볼 수 있네요.\n🙋 어라 그런데.. 같은 데이터에 여러 Task가 동시에 접근하면 안된다고 하지 않았나요?\n맞습니다.. 하지만 이 경우에는 @MainActor, 즉 메인쓰레드에서 이루어지기 때문에 절대로 동시에 일어날 일이 없습니다.\n셀이 화면에서 벗어나면 작업을 취소해도 되겠죠.\n\n다음과 같이 task.cancel() 로 Task를 취소해줄 수 있습니다.\nDetached Tasks어라 뭐가 하나 또 있죠…?\nUnstructured Tasks는 어떤 스코프에서도 수행될 수 있는 Task였습니다. 하지만 \b어떤 컨텍스트에서 시작되었는지는 중요한 요소였습니다.\n해당 scope의 변수도 사용해야 하고, \nDetached Tasks는 그 어떤 것도 상관이 없을 떄 사용하는 Task입니다.\nDetached Tasks는 컨텍스트로부터 독립적입니다.\n시작된 scope에서 아무 값도 가져오지 않습니다.\n심지어 같은 actor에서 실행되도록 되어있지도 않아서 같은 우선순위를 갖지도 않습니다.\n\n위 예시는 썸네일을 생성한 후에 로컬 디스크에 캐싱을 하는 작업을 Detached Task에서 작업하도록 하는 코드입니다.\n캐싱은 @MainActor에서 처리될 필요가 전혀 없죠.\n높은 우선순위를 가질 필요도 없습니다.\nTask.detached(priority:) 를 통해서 간단하게 컨텍스트에서 독립된 Detached Task를 만들어줄 수 있습니다.\n\nDetached Task에 Task Group을 사용해서 hierarchy를 만들어줄 수도 있습니다.\n여러가지 백그라운드 작업이 필요하지만 연결된 작업이 필요할 때 아주 유용하겠죠!\n정리\nActor끝난 줄 알았죠..?\n하지만 아직 많이 남았습니다. 🤯\n위에서 Actor라는 키워드가 사용되었었죠..?\n이게 뭔지도 알아봐야죠..\nActor가 뭔지 알아보려면 마찬가지로 이미 한 번 살펴본 Data Race Issue와 관련되어 있다는 것을 알고 시작해야합니다.\nData Race는 여러 개의 Task에서 동시에 하나의 mutable 값에 접근하려고 하면 발생하는 문제였습니다.\n그렇다면 문제를 어떻게 해결할까요?\n변하지 않는 데이터를 사용하거나 여러 Task에 걸쳐 사용되지 않도록 하면 해결되겠죠?\n\n그러면 이렇게 하면 되겠네요!\nlet으로 값이 고정된 값을 각 Task에서 mutable한 값으로 복사한 뒤 작업을 해주면 되겠죠.\n아뇨 안됐습니다. 🙅‍♂️\n에러는 발생하지 않지만 Task마다 복사된 값은 서로의 값에 영향을 주지 못하거든요.\n그러면 이렇게 정리할 수 있습니다: 각 Task들이 공유할 수 있는 mutable Task가 필요하다!\nSwift는 이미 그런 feature들을 갖고 있습니다.\n이런 문제는 오래된 문제거든요..\nmutable state를 동기화하는 작업은 로우레벨 단계에서 사용할 수 있는 Atomics, Locks, 더 높은 레벨에서 사용할 수 있는 Serial DIspatch Queues가 있습니다.\n이들은 모두 같은 역할을 하고 같은 문제를 갖고 있습니다.\nShared mutable state에 Data Race 없이 접근할 수 있지만, 사용법이 조금이라도 어긋나면 바로 앱이 크러쉬된다는 것이죠.\nActors는 이런 문제를 해결하고 shared mutable state의 동기화를 좀 더 쉽게 이룰 수 있도록 등장했습니다.\nActors는 state를 다른 모든 프로그램에서 분리하여 관리합니다.\n그리고 해당 state에 접근하려면 무조건 actor 내부에 들어가야만 하죠.\nActor는 조금 특이하게 사용됩니다.\n새로운 타입이거든요\n\n마치 struct, enum, class와 같이 프로퍼티, 메서드, 생성자 등을 가집니다.\nprotocol 과 extension 또한 사용할 수 있습니다.\n또, actor는 shared mutable state에 접근하기 위해 만들어진 만큼 class와 같은 참조 타입입니다.\n사용법은 class와 동일합니다.\n한 가지 주의할 점이 있다면 class와는 다르게 상속을 지원하지는 않습니다!\n그리고 가장 중요한 점은 actor에서 정의된 값들은 동시에 접근되지 않도록 보장되어 있다~라는 점입니다.\n\n위의 예시에 적용해보면 이렇게 됩니다.\n같은 값에 접근하지만, 절대 동시에 접근할 수는 없기 때문에 순서대로 2, 1이나 1, 2가 출력될겁니다.\n하지만 suspend된 작업이 actor 안에서 얌전히 차례를 기다릴 것이라는 보장은 되는 걸까요?\n우리는 이미 그런 역할을 하는 키워드를 알고 있습니다.\n\nactor의 외부에서는 await 키워드를 통해 해당 작업이 suspendable하다는 것을 명시해줄 수 있습니다.\n하지만 actor의 내부에서는 이와 같은 키워드는 필요가 없죠.\n모든 코드가 synchronous하게 실행되기 때문에 동시성 프로그래밍의 문제를 신경쓰지 않고 작업할 수 있습니다.\nActor Reentrancy\n위 코드는 이미지를 캐싱하는 작업을 수행하는 actor입니다.\n문제는 await에서 발생합니다.\n이미지를 다운로드하는 과정은 시간이 오래 소요되는 작업이니 await을 사용하는 것은 올바른 접근입니다.\n\n하지만 동시에 두 군데에서 같은 url의 이미지를 받아오길 원하고, 하나의 작업이 수행되는 동안 서버의 이미지가 교체되는 상황이 있다면 어떻게 될까요?\n두 작업은 동시에 요청됐음에도 불구하고 다른 이미지를 받아오게 될겁니다.\n\n이 경우에는, 이미 url에 해당하는 이미지가 있다면 그 이미지를 불러와 사용하고, 없다면 새로운 이미지를 넣는 것으로 해결하였습니다.\n이와 같이 actor 내부에서 await을 사용하는 것은 숨겨진 버그를 유발할 수 있기 때문에 주의가 필요합니다.\n이런 과정을 actor에 재진입하여 작업을 수행한다고 해서 Actor Reentrancy라고 부릅니다.\n다음 세 가지를 항상 생각해가며 코드를 짜봅시다.\n\n되도록 synchronous하게 데이터를 mutate 시킨다.\nawait에서 suspend된 동안 state가 바뀔 수 있음을 생각한다.\nawait 후에 조건문 등을 통해 state가 예상범위 안인지 체크한다.\n\nActor IsolationActor는 다른 프로그램들과 독립적으로 있는 존재라고 했었죠?\n따라서 외부에서 actor에 접근할 떄는 이런 독립성을 해치면서 접근할 수는 없습니다.\n\n\n\n\n\n\n\n\n\n여기서부터 조금 아득해집니다.. 주의하세요… 🫠\nProtocol\n이 경우 Equatable 메서드는 static 이고 파라미터로 받는 두 actor 타입 값의 외부에 있으니까 가능한 문법입니다.\n\n반면 이 경우에는 허용되지 않습니다.\nhash(into:) 함수는 actor 내부에 들어가 값을 변경하고, async하지도 않기 때문입니다.\n하지만 이상한 점이 있습니다. 😕\nactor 내부에 들어가는 것은 맞지만, 실제로 actor가 갖고있는 값을 변경하는 것은 아니거든요..\n\n그런 경우에는 nonisolated 키워드를 붙여 해결할 수 있습니다.\n하지만 끝이 아닙니다..\n이 경우에는 사용하는 actor의 프로퍼티 idNumber가 immutable한 값이거든요.\n하지만 mutable한 값을 사용하려고 하면…?\n\n어김없이 에러가 발생합니다.\n외부에서 mutable한 값에 접근하는 것은 Data Race를 유발할 수 있거든요.\nClosure이번에는 클로저 안에서 실행되는 함수의 경우를 살펴봅시다.\n\n위 예시는 아무 문제가 없습니다.\n독립된 공간에 있는 read() 함수 안에 있는 (마찬가지로 독립된 공간에 있는)readSome() 함수가 synchronous하기 때문에 순차적으로 실행되기 때문이죠!\n\n그렇다면 이 경우는 어떨까요..\nDetached Task에 read() 함수가 있기 때문에 이 경우에는 클로저 안의 작업들이 독립된 공간에 있지 않고 밖으로 나가게 됩니다.\n때문에 해당 클로저는 actor에 있지 않고, await 키워드를 붙여 비동기적으로 처리되어야 합니다.\n\n자 이 경우를 봅시다..\nBook이라는 인스턴스는 class 타입입니다. 참조 타입이니까 actor 안에 있지 못하고 외부에 위치해있죠.\nactor 안에 참조 타입의 값이 있는 것 자체는 아무 문제가 없습니다.\n문제는 해당 값에 접근을 할 때 발생하겠죠? (Data Race)\n여기서 익숙한 키워드가 등장합니다.\n\nSendable\n\nSendable 타입은 다른 여러 actor들 사이에서 함께 사용될 수 있는 타입입니다.\n어떤 값을 각자의 actor로 복사하고, 복사된 값을 독립적으로 처리할 수 있다면 해당 값은 Sendable하다고 할 수 있습니다.\n값 타입과 Actor 타입은 기본적으로 Sendable합니다.\n하지만 **클래스(참조 타입)**의 경우에는 고려해야할 사항이 있죠..\n\n클래스에 있는 **모든 값들이 immutable(let)**한 경우\n클래스 내부적으로 동기화(lock)를 구현한 경우\n\n하지만 대부분의 클래스는 그렇지 않기 때문에 Sendable이 아니라고 할 수 있습니다.\n함수는 기본적으로는 Sendable하지 않지만 @Sendable 함수와 같은 새로운 타입의 함수를 사용하면 Sendable합니다.\n\nSendable은.. 예상하셨겠지만 사실 프로토콜입니다.\nSwift에서 concurrent한 작업을 하기 위해서는 Sendable 프로토콜을 준수한 값들을 사용해야하는 것이죠..!\n자.. 다시 클로저로 돌아가봅시다.\n클로저가 Sendable하려면 어떤 경우여야 할까요?\n간단합니다. 클로저가 캡처하는 모든 값들이 Sendable해야하죠.\n또 캡처한 값들이 **mutable(var)**하면 안됩니다.\n그러면 Data Race가 발생할테니까요..\n마지막으로 클로저가 synchronous한 경우에 actor에서 독립된 형태이면 안됩니다.\n외부에서 접근이 가능해지니까요!\nMain Actor마지막으로 살펴볼 게 있습니다.\nMain Actor라는 특수한 actor인데요, 이미 전에 한 번 언급된 적이 있었죠?\n백그라운드에서 작업을 하다가 다시 메인쓰레드로 넘어와 UI를 업데이트해야 하는 상황..\n아주 익숙하죠?\nDispatchQueue.main.async &#123;\n  updateButton()\n&#125;\n\n보통 위와 같이 **DispatchQueue.main**을 사용해오곤 했습니다.\n\n**@MainActor**는 해당 작업이 메인쓰레드에서 이루어져야 한다는 것을 명시하는 키워드입니다.\nDispatchQueue.main 대신 사용하여 명시적으로 메인쓰레드에서 동작해야한다는 것을 컴파일러에게 알려줍시다..!\n\n\n\n\n\n\n\n\n\n참고 문서\nWWDC21 - Swift concurrency: Behind the Scenes\nWWDC21 - Explore structured concurrency in Swift\nWWDC21 - Protect mutable state with Swift actors\nnaljin - Swift async &#x2F; await &amp; concurrency\n","slug":"Swift/2023-03-28-Swift26","date":"2023-03-27T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"06d14767cdd4b129532d498df40afc71","title":"25)🍎 Swift - Package","content":"Package (패키지)\n패키지란 프로젝트 내에서 사용하는 코드&#x2F;리소스들을 재사용하기 쉽도록 묶어 정돈하거나 다른 개발자나 커뮤니티와 공유하기 위한 기능입니다.\nXcode는 이런 패키지 기능을 Swift Package Manager를 통해 쉽고 간편하게 사용할 수 있도록 지원하고 있습니다.\n네 맞아요..\n저희가 맨날 쓰던 그거요..\n그러면 멋있고 화려한 RxSwift와 같은 라이브러리를 만들기 위해 시작해보죠?\nSwift Package 만들기\n\n\n\n\n\n\n\n\n\n전반적인 패키지 생성 과정\n\n패키지 만들기 정말 쉽습니다.\nXcode의 메뉴에서 File ➡️ New ➡️ Package 를 눌러줍시다.\n\n그러면 이렇게 프로젝트나 파일을 만드는 것과 같이 패키지를 생성하는 창이 보입니다.\n저는 Favor 프로젝트에 패키지를 적용하기 위해 Add to와  Group도 설정해주었습니다.\n그러면 비어있는 패키지 만들기 끝입니다.\n\n패키지를 생성하면 이런 구조의 파일들이 프로젝트에 추가됩니다. 각각을 한 번 알아볼까요?\n\nREADME.md\n\n뭐 설명할 것도 없죠. 패키지에 대한 설명을 넣어주면 됩니다.\n\nPackage.swift\n\n흔히들 manifest라고 부르는 패키지에 대한 정보가 담긴 파일입니다. 이 파일 안에서 패키지의 name, products, targets, dependencies들을 설정해주게 됩니다.\n\nSources\n\n소스 파일들은 이 Sources 디렉토리 내부에 위치합니다. 그리고 Target이라는 하나의 이름 안에 관리됩니다.\n\nTests\n\n패키지에 대한 Unit Test 코드들이 여기에 해당됩니다.\nPackage.swift 작성Favor 프로젝트는 세가지 패키지를 만들어 사용하기로 했습니다.\n\nFavorCoreKit\n\nFoundation의 extension들, OS와 밀접하게 닿아있는 기능들 (PhotosUI, CoreGraphics 등)을 담아둡니다.보통 BaseViewController와 같은 Base 파일들도 여기에 담긴다고 하는데 아직 저희 프로젝트는 이런 파일들이 많지 않아서 (BaseVC 하나) 추가적인 회의를 통해 결정하기로  했습니다.\n\nFavorUIKit\n\nUIKit의 extension들과 커스텀 UI 컴포넌트들, 폰트와 아이콘 같은 Resources들과 UI에 사용되는 상수 파일들이 포합됩니다.\n\nFavorNetworkKit\n\nHTTP 통신과 같은 네트워크 작업에 필요한 파일들이 모두 포함됩니다. 저희 프로젝트는 Moya를 사용하기 때문에 BaseTargetType과 API 파일들을 여기에 넣어주었습니다.\n이 중에서 FavorUIKit을 한 번 살펴보겠습니다.\n&#x2F;&#x2F; swift-tools-version: 5.7\n&#x2F;&#x2F; The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package &#x3D; Package(\n  name: &quot;FavorUIKit&quot;,\n  platforms: [\n    .iOS(.v15)\n  ],\n  products: [\n    &#x2F;&#x2F; Products define the executables and libraries a package produces, and make them visible to other packages.\n    .library(\n      name: &quot;FavorUIKit&quot;,\n      targets: [&quot;FavorUIKit&quot;]),\n  ],\n  dependencies: [\n    &#x2F;&#x2F; Dependencies declare other packages that this package depends on.\n    &#x2F;&#x2F; .package(url: &#x2F;* package url *&#x2F;, from: &quot;1.0.0&quot;),\n    .package(url: &quot;https:&#x2F;&#x2F;github.com&#x2F;ReactiveX&#x2F;RxSwift.git&quot;, .upToNextMajor(from: &quot;6.5.0&quot;)),\n    .package(url: &quot;https:&#x2F;&#x2F;github.com&#x2F;SnapKit&#x2F;SnapKit.git&quot;, .upToNextMajor(from: &quot;5.6.0&quot;)),\n    .package(path: &quot;..&#x2F;FavorCoreKit&quot;)\n  ],\n  targets: [\n    &#x2F;&#x2F; Targets are the basic building blocks of a package. A target can define a module or a test suite.\n    &#x2F;&#x2F; Targets can depend on other targets in this package, and on products in packages this package depends on.\n    .target(\n      name: &quot;FavorUIKit&quot;,\n      dependencies: [\n        &quot;RxSwift&quot;,\n        .product(name: &quot;RxCocoa&quot;, package: &quot;RxSwift&quot;),\n        &quot;SnapKit&quot;,\n        &quot;FavorCoreKit&quot;\n      ],\n      resources: [\n        .process(&quot;Resources&quot;)\n      ]\n    ),\n    .testTarget(\n      name: &quot;FavorUIKitTests&quot;,\n      dependencies: [&quot;FavorUIKit&quot;]),\n  ]\n)\n\nnamename은 말 그대로 패키지의 이름입니다.\nplatformsplatforms는 패키지가 사용될 수 있는 플랫폼을 명시해둡니다. .iOS, .macOS와 같은 플랫폼 case와 .v15와 같은 버전 case를 넣어 적용할 수 있습니다.\nproductsproducts는 패키지가 제공하는 프로덕츠들을 명시하는 곳입니다. .library 외에도 .executable, .plugin과 같은 case도 있습니다.\n하나의 라이브러리에 여러개의 targets를 만들 수도 있습니다. 대표적으로 RxSwift의 경우 RxSwift 하나의 라이브러리에 RxRelay, RxCocoa 등의 여러 타겟들을 제공하고 있죠.\ndependencies패키지가 사용하는 다른 패키지들을 명시합니다. 여기에 적힐 내용은 보통 라이브러리 리드미 파일에 적어두는 경우가 많으니 참고하여 적어주면 됩니다.\n깃허브에 올라와있는 패키지의 경우 .package(url:)을 사용해주면 되고, 로컬 패키지의 경우 .package(path:)를 사용해줍니다.\n뒤에 붙는 버전의 경우\n\nfrom\n\n해당 버전 이상부터 사용합니다.\n\nuptoNextMajor\n\n메이저 버전이 바뀌기 전까지 업데이트하며 사용합니다.ex) 5.0.0 ~ 6.0.0\n\nuptoNextMinor\n\n마이너 버전이 바뀌기 전까지 업데이트하며 사용합니다.ex) 5.0.0 ~ 5.1.0\n\nexact해당 버전으로 고정하여 사용합니다.\n\ntargets패키지에 사용된 타겟들을 각각 명시합니다. \ndependencies에는 보통 위의 dependencies에 적힌 패키지들이 적히고, 하나의 패키지에 타겟이 여러개인 경우 .product(name: &quot;RxCocoa&quot;, package: &quot;RxSwift&quot;)와 같이 각각 적어줍니다.\nresources에는 타겟에서 사용되는 리소스 파일들을  명시합니다.\n\n단 .xcassets, .storyboard, .xib, .nib 파일등과 같은 리소스 파일들은 Xcode가 그 사용처가 분명하다고 판단하여 자동으로 패키징이 이루어집니다.\n\n하지만 저희 프로젝트의 경우 폰트와 같은 자동으로 패키징되지 않는 타입의 리소스가 있기 떄문에 .process(&quot;Resources&quot;)와 같이 명시해주었습니다.\n리소스 명시는 두가지 방법을 지원합니다.\n\nprocess\n\n해당 디렉토리에 있는 모든 리소스를 하나의 depth로 평준화합니다.\n플랫폼에 따라 Xcode가 최적화를 진행할 수 있다면 최적화를 진행해서 리소스 번들의 최상위 디렉토리에 복사합니다.\n\ncopy\n\n디렉토리 구조 그대로 복사하여 사용합니다.\n디렉토리 구조를 굳이 유지해야하는게 아니라면 최적화도 진행되는 process가 사용된다고 합니다.\n접근제어자패키지화를 한 이상 접근제어자에 더욱 신경을 써주어야 합니다.\nSwift에는 다섯가지 접근 제어자가 있습니다.\nopen, public프로젝트 내의 모든 곳에서 접근할 수 있습니다.\nopen과 public의 차이가 패키징을 사용하면서 중요해집니다.\nopen을 사용하면 다른 모듈에서 overclass를 허용합니다. 하지만 public은 이를 허용하지 않습니다.\n따라서 BaseViewController와 같이 상속이 필요한 클래스의 경우 open으로 접근을 열어주어야 합니다.\ninternal아무 접근제어자도 작성하지 않으면 기본적으로 적용되는 접근제어자입니다. 작성된 모듈 안에서만 접근 가능합니다.\nfileprivate작성된 소스 파일 내부에서만 접근 가능합니다.\nprivate가장 제한적인 접근제어자입니다. 작성된 객체 내부에서만 접근 가능합니다.\n패키지 적용하기\n프로젝트의 앱 타겟에서 라이브러리 추가를 눌러줍니다.\n\nWorkspace 내부에 만들어두었기 때문에 패키지를 바로 선택할 수 있습니다.\n\nimport까지 해보면서 정상적으로 추가되었는지 확인해봅시다!\n\n\n\n\n\n\n\n\n\n참고 문서\nApple - Creating a standalone Swift package with Xcode\nApple - Bundling resources with a Swift package\nKakaoTech - Swift Package Manager 적용기\nZeddiOS - Copy와 Process의 차이점\n","slug":"Swift/2023-03-10-Swift25","date":"2023-03-09T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Favor","author_index":"nomatterjun"},{"id":"3792db1f46c6369b4473f92f8ea4160f","title":"24)🍎 Swift - Moya","content":"Moya\n\n\n\n\n\n\n\n\n모야가 대체 모야?\n(아마 한국인이 작성한 모야 게시물 80%는 이걸로 시작할듯…)\n그래서 모야는 뭘까요?\nMoya는 enum 타입을 적극적으로 활용하여 네트워크 요청 레이어를 type-safe하게 래핑한 네트워킹 라이브러리입니다.\n컴파일 타임에 엔드포인트 접근 관련 에러를 띄워주기 때문에 더욱 안전하고 간편하게 앱을 빌드할 수 있다는 장점이 있다고 해요!\nAlamofire와의 관계?Swift 언어를 처음 학습할 때 URLSession을 공부한 뒤에 네트워크 관련된 유용한 라이브러리가 많다는 사실을 알고 어떤 것이 있나 살펴보던 때가 있었습니다.\n모두가 알고 있는 Alamofire, Kingfisher, Moya 등이 있었죠..\n그 중에서 Kingfisher는 이미지 관련 라이브러리니 남는 건 Alamofire와 Moya였습니다.\n아무것도 모르던 저는 Moya의 귀여운 이름에 끌려 무작정 공부를 시작했더랩죠..\n무슨 말인지 하나도 이해하지 못하고 Alamofire로 후퇴했었는데요.. 당연한거였습니다.\nMoya의 네트워킹은 사실 Alamofire이기 때문이죠…!\n\nDependency에 떡하니 박혀있는게 보이시죠..\n\n사실 깃허브 설명란의 이미지에도 Alamofire가 하나의 계층을 떡하니 잡고 있는 걸 볼 수 있습니다..\n개념모야를 이해하려면 세 가지 핵심 요소를 먼저 알아야합니다.\nProviderMoyaProvider 객체로 접근할 수 있는 메인 객체입니다.\n네트워크 관련 기능을 사용하기 위해서는 무조건 이 MoyaProvider 객체를 생성하거나 주입받아야 합니다.\nTargetAPI를 제공하는 서비스를 부르는 명칭입니다.\n공개된 오픈 API일 수도 있고, 프로젝트 내부에서 사용되는 서버의 API일 수도 있겠죠.\n이 Target은 TargetType protocol을 사용해서 정의해줄 수 있습니다.\nEndpointEndpoint는 네트워킹 요청을 위해 필요한 정보들을 담는 객체입니다.\nHTTP 메서드, request body &#x2F; header 등의 정보들을 담고 있고, Target 또한 MoyaProvider에 의해 이 Endpoint로 변환되어 사용됩니다.\n이 Endpoint를 커스텀하면 모든 종류의 네트워킹에 필요한 데이터 맵핑을 수행할 수 있다고 하네요.\n기초공식 문서보다는 코데코의 예제가 쉬워보이니까 코데코의 예제로 진행해보겠습니다.\npublic enum Marvel &#123;\n  static private let publicKey &#x3D; &quot;PUBLIC_KEY&quot;\n  static private let privateKey &#x3D; &quot;PRIVATE_KEY&quot;\n\n  case comics\n&#125;\n\n이렇게 enum 타입으로 API 서비스에 대한 정보를 넣어줄 수 있습니다.\ncase에는 필요한 API 엔드포인트마다 정의해주면 됩니다.\nenum MyService &#123;\n    case zen\n    case showUser(id: Int)\n    case createUser(firstName: String, lastName: String)\n    case updateUser(id: Int, firstName: String, lastName: String)\n    case showAccounts\n&#125;\n\n이렇게요..!\n연관값으로 넣어준 파라미터들은 리퀘스트시에 파라미터가 필요할 경우 넣어주는 것으로 편하게 사용할 수 있습니다.\nTarget으로 사용될 enum은 반드시 TargetType 프로토콜을 채택해야 한다고 했었죠?\nextension Marvel: TargetType &#123;\n  public var baseURL: URL &#123;\n\t&#x2F;&#x2F;\n  &#125;\n\n  public var path: String &#123;\n\t&#x2F;&#x2F;\n  &#125;\n\n  public var method: Moya.Method &#123;\n\t&#x2F;&#x2F;\n  &#125;\n\n  public var sampleData: Data &#123;\n\t&#x2F;&#x2F;\n  &#125;\n\n  public var task: Moya.Task &#123;\n\t&#x2F;&#x2F;\n  &#125;\n\n  public var headers: [String : String]? &#123;\n\t&#x2F;&#x2F;\n  &#125;\n&#125;\n\n프로토콜을 채택하고 필요한 프로퍼티들을 자동으로 넣어주면 위와 같은 형태가 됩니다.\nextension Marvel: TargetType &#123;\n  public var baseURL: URL &#123;\n    return URL(string: &quot;https:&#x2F;&#x2F;gateway.marvel.com&#x2F;v1&#x2F;public&quot;)!\n  &#125;\n\n  public var path: String &#123;\n    switch self &#123;\n    case .comics: return &quot;&#x2F;comics&quot;\n    &#125;\n  &#125;\n\n  public var method: Moya.Method &#123;\n    switch self &#123;\n    case .comics: return .get\n    &#125;\n  &#125;\n\n  public var sampleData: Data &#123;\n    return Data()\n  &#125;\n\n  public var task: Moya.Task &#123; &#x2F;&#x2F; TODO: 알맞는 옵션으로 변경\n    return .requestPlain\n  &#125;\n\n  public var headers: [String : String]? &#123;\n    return [&quot;Content-Type&quot;: &quot;application&#x2F;json&quot;]\n  &#125;\n\n  public var validationType: ValidationType &#123;\n    return .successCodes\n  &#125;\n&#125;\n\n\nbaseURLAPI 서비스의 baseURL을 입력해줍니다.\npathbaseURL 뒤에 붙는 요청 API의 path 주소를 입력해줍니다.\n예시의 경우 전체 API 요청 주소는 https://gateway.marvel.com/v1/public/comics 가 되겠죠!\nmethodpath에 맞는 HTTPS 통신 메서드를 반환해줍니다.\nex) .get, .delete, .patch 등\nsampleData유닛 테스트를 할 때나 실제로 서버가 없을 경우, 이 sampleData로 가상의 데이터를 담아주면 해당 데이터를 반환값으로 받아옵니다.\n필요하지 않을 경우  Data()를 반환하여 비어있는 데이터를 전달해줍니다!\ntask요청에 파라미터를 포함하거나, 데이터를 포함하여 요청을 하는 등의 옵션들을 추가적으로 제공하여 HTTP 요청을 전송합니다.\nAPI가 요구하는 양식이나 서버의 상태등에 따라 너무나 다양한 경우가 있으므로 우선 아무런 옵션을 넣지 않는 .requestPlain을 선택해주었습니다.\nheadersHTTP 헤더를 넣어줍니다.\n예시에서는 가장 자주 쓰이는 Content-Type: application/json을 넣어주었습니다. (JSON 형식의 컨텐트)\nvalidationType필수적으로 필요한 항목은 아니지만, 자주 쓰이는 항목입니다.\n.successCodes는 200..&lt;299 사이의 응답 코드를 받으면 통신을 성공했다고 처리하는 case입니다.\n이 Target만 봐도 Moya가 대충 어떤 느낌으로 쓰이는 지 알 수 있을 것 같네요.\n통신에 필요한 데이터들을 한 군데 모아두고 switch-case를 통해서 쉽게 요청 항목을 선택할 수 있을 것 같습니다.\nhttps://developer.marvel.com/documentation/authorization\n이번에 사용하는 마블 API의 문서를 살펴보고, task 부분을 채워줍시다.\nClient-Side 앱은 사전에 인증이 되어 있어야 한다는군요.\nServer-Side 방식으로 진행해줍니다.\npublic var task: Task &#123;\n  let ts &#x3D; &quot;\\(Date().timeIntervalSince1970)&quot;\n  let hash &#x3D; (ts + Marvel.privateKey + Marvel.publicKey).md5\n  let authParams &#x3D; [&quot;apikey&quot;: Marvel.publicKey, &quot;ts&quot;: ts, &quot;hash&quot;: hash]\n  \n  switch self &#123;\n  case .comics:\n\treturn .requestParameters(\n\t  parameters: [\n\t\t&quot;format&quot;: &quot;comic&quot;,\n\t\t&quot;formatType&quot;: &quot;comic&quot;,\n\t\t&quot;orderBy&quot;: &quot;-onsaleDate&quot;,\n\t\t&quot;dateDescriptor&quot;: &quot;lastWeek&quot;,\n\t\t&quot;limit&quot;: 50] + authParams,\n\t  encoding: URLEncoding.default)\n  &#125;\n&#125;\n\n이제 실제로 API request를 보내봅시다.\nlet provider &#x3D; MoyaProvider&lt;Marvel&gt;()\n\nprovider.request(.comics) &#123; result in\n  switch result &#123;\n  case .success(let response):\n\tdo &#123;\n\t  print(try response.mapJSON())\n\t&#125; catch &#123;\n\t  &#x2F;&#x2F; error handling\n\t&#125;\n  case .failure:\n\t&#x2F;&#x2F; error handling\n  &#125;\n&#125;\n\n위와 같이 짧고 간결하게 통신 요청을 보낼 수 있습니다.\n\n엄청나게 많은 데이터들이 들어오는군요..\n이 데이터들을 감싸고 View에 적용하는 내용은 다른 HTTP 통신들과 같습니다.\nMoya는 RxSwift와도 아주 잘 어울립니다.\nprovider.rx.requestWithProgress(.zen).subscribe &#123; event in\n    switch event &#123;\n    case .next(let progressResponse):\n        if let response &#x3D; progressResponse.response &#123;\n            &#x2F;&#x2F; do something with response\n        &#125; else &#123;\n            print(&quot;Progress: \\(progressResponse.progress)&quot;)\n        &#125;\n    case .error(let error):\n        &#x2F;&#x2F; handle the error\n    default:\n        break\n    &#125;\n&#125;\n\n이런식으로 기본적으로 Rx화도 되어있거든요. (패키지를 설치할 때 Moya/RxSwift도 함께 설치해주어야 합니다.)\n대략적인 사용 방법을 알았으니 실전에 적용해보기 위해 떠나보도록 하겠습니다.\n\n\n\n\n\n\n\n\n\n참고 문서\nKodeco - # Moya Tutorial for iOS: Getting Started\nMoya - Basic Usage\n","slug":"Swift/2023-02-26-Swift24","date":"2023-02-25T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Moya","author_index":"nomatterjun"},{"id":"2f437dcacf2ab858ae6b89a9091808ec","title":"23)🍎 Swift - RxSwift Traits","content":"TraitsTraits는 Observable의 한 종류라고 볼 수 있습니다.\nTraits는 UI 영역에서 복잡하고 다양한 기능이 있는 Observable 대신 사용되기 위해 만들어졌습니다.\n따라서 RxCocoa와 아주 밀접한 관련이 있지만, 몇몇 기능들은 RxSwift 전반적으로 사용될 수 있기 때문에 RxSwift와 RxCocoa에 나누어 구현되었다고 합니다.\n등장 이유Traits를 왜 사용해야하는지부터 알아보도록 하겠습니다.\nTraits는 Observable 시퀀스가 안전하게 통신될 수 있도록 돕습니다.\n모든 방면에서 사용될 수 있는 Observable을 대신하여 UI 처리에 특화된 기능과 문법을 제공합니다.\n따라서 Traits는 Observable이 제공하는 기능의 일부를 떼어낸 것과 다름없기 때문에 사용할지 말지의 여부는 사용자에게 달려있다고 합니다!\n기본 개념Traits는 단순히 하나의 read-only한 Observable을 감싸고 있는 struct입니다.\nstruct Single&lt;Element&gt; &#123;\n\tlet source: Observable&lt;Element&gt;\n&#125;\n\nstruct Driver&lt;Element&gt; &#123;\n\tlet source: Observable&lt;Element&gt;\n&#125;\n\nTraits를 Observable로 돌려놓고 싶을 때는 .asObservable()로 간단하게 처리할 수 있습니다.\nRxSwift TraitsSingleSingle은 무조건 하나의 값 또는 에러를 방출합니다.\n지속적인 값이 아니라 딱 한 번의 결과값이 필요할 떄 사용됩니다.\n한 번의 값만을 방출하기 떄문에 .completed가 없습니다.\n사용되기 가장 좋은 곳은 HTTP 통신을 할 때이며, request에 하나의 응답만이 돌아올 때 사용하면 유용합니다.\nfunc getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; &#123;\n\treturn Single&lt;[String: Any]&gt;.create &#123; single in\n\t\tlet task &#x3D; URLSession.dataTask(with: URL(string: &quot;https:&#x2F;&#x2F;api.github.com&#x2F;\\(repo)&quot;)! &#123; data, _, error in\n\t\t\tif let error &#123;\n\t\t\t\tsingle(.failure(error))\n\t\t\t\treturn\n\t\t\t&#125;\n\n\t\t\tguard let data,\n\t\t\t\tlet json &#x3D; try? JSONSerialization.jsonObject(with: data, option: .mutableLeaves),\n\t\t\t\tlet result &#x3D; json as? [String: Any] else &#123;\n\t\t\t\t\tsingle(.failure(DataError.cantParseJSON))\n\t\t\t\t\treturn\t  \n\t\t\t&#125;\n\n\t\t\tsingle(.success(result))\n\t\t&#125;\n\t\ttask.resume()\n\n\t\treturn Disposables.create &#123; task.cancel() &#125;\n\t&#125;\n&#125;\n\ngetRepo(&quot;ReactiveX&#x2F;RxSwift&quot;)\n\t.subscribe(onSuccess: &#123; json in\n\t\t\tprint(&quot;JSON: &quot;, json)\n\t\t&#125;,\n\t\tonError: &#123; error in\n\t\t\tprint(&quot;Error: &quot;, error)\n\t\t&#125;)\n\t.disposed(by: self.disposeBag)\n\nCompletableCompletable은 .completed나 .error만을 방출합니다.\n한마디로 값(element)을 방출하지 않습니다.\n작업의 내용은 중요하지 않고, 성공&#x2F;실패 여부만 중요한 경우에 사용됩니다.\nfunc cacheLocally() -&gt; Completable &#123;\n\treturn Completable.create &#123; completable in\n\t\tguard success else &#123;\n\t\t\tcompletable(.error(CacheError.failedCaching))\n\t\t\treturn Disposables.create &#123; &#125;\n\t\t&#125;\n\n\t\tcompletable(.completed)\n\t\treturn Disposables.create &#123; &#125;\n\t&#125;\n&#125;\n\ncacheLocally()\n\t.subscribe(onCompleted: &#123;\n\t\tprint(&quot;Completed with no error.&quot;)\n\t&#125;,\n\tonError: &#123; error in\n\t\tprint(&quot;Completed with an error: \\(error.localizedDescription)&quot;)\n\t&#125;)\n\t.disposed(by: self.disposebag)\n\nMaybeMaybe는 Single과 Completable의 중간에 있는 Trait입니다.\n하나의 값을 방출하거나 방출 없이 .complete되거나 .error를 방출할 수 있습니다.\nfunc generateString() -&gt; Maybe&lt;String&gt; &#123;\n\treturn Maybe&lt;String&gt;.create &#123; maybe in\n\t\tmaybe(.success(&quot;RxSwift&quot;))\n\t\t&#x2F;&#x2F; or\n\t\tmaybe(.completed)\n\t\t&#x2F;&#x2F; or\n\t\tmaybe(.error(error))\n\n\t\treturn Disposables.create &#123; &#125;\n\t&#125;\n&#125;\n\ngenerateString()\n\t.subscribe(onSuccess: &#123; element in\n\t\tprint(&quot;Completed with element \\(element)&quot;)\n\t&#125;,\n\t.onError &#123; error in\n\t\tprint(&quot;Completed with an error \\(error.localizedDescription)&quot;)\n\t&#125;,\n\tonCompleted: &#123;\n\t\tprint(&quot;Completed with no element&quot;)\n\t&#125;)\n\t.disposed(by: self.disposeBag)\n\nRxCocoa TraitsDriver가장 많이 사용되는 Trait입니다.\nUI 레이어만을 위해 특별하게 개발된 기능입니다.\n특징을 정리해보면 아래와 같습니다.\n\n에러가 방출하지 않습니다\nobserve가 Main Scheduler에서 이루어집니다.\nside effect를 공유합니다.\n\nlet results &#x3D; query.rx.text\n\t.throttle(.milliseconds(300), scheduler: MainScheduler.instance)\n\t.flatMapLatest &#123; query in\n\t\tfetchAutoCompleteItems(query)\n\t&#125;\n\nresults\n\t.map &#123; &quot;\\($0.count)&quot; &#125;\n\t.bind(to: resultCount.rx.text)\n\t.disposed(by: self.disposeBag)\n\nresults\n\t.bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; _, result, cell in\n\t\tcell.textLabel?.text &#x3D; &quot;\\(result)&quot;\n\t&#125;\n\t.disposed(by: self.disposeBag)\n\n위 예시는 세가지 문제점들을 가지고 있습니다.\n\nfetchAutoCompleteItems가 에러를 방출할 경우, UI에 바인딩되어 있던 것들이 모두 unbind되면서 이후의 쿼리들에 더 이상 UI가 변화하지 않을 것입니다.\nfetchAutoCompleteItems가 메인쓰레드가 아닌 백그라운드 쓰레드에 결과를 반환할 경우, UI에 결과값을 바인딩하는 작업이 백그라운드 쓰레드에서 일어날 수 있고, 이는 예기치 않은 크래시를 발생시킬 수 있습니다.\n결과값이 두 개의 UI 컴포넌트(TableView, UILabel)에 바인딩되어 있기 때문에 각각이 따로 HTTP request를 요청해 불필요한 중복 요청이 발생합니다.\n\n이를 해결한 코드는 아래와 같습니다.\nlet results &#x3D; query.rx.text\n\t.throttle(.milliseconds(300), scheduler: MainScheduler.instance)\n\t.flatMapLatest &#123; query in\n\t\tfetchAutoCompleteItems(query)\n\t\t\t.observeOn(MainScheduler.instance)\n\t\t\t.catchErrorJustReturn([])\n\t&#125;\n\t.share(replay: 1)\n\n예시에서는 이런 과정이 쉬울 수 있으나, 실전에서 프로젝트가 커짐에 따라 이런 사소한 문제점들을 발견하는 것은 어려울 수 있습니다.\n따라서 RxCocoa는 이런 문제들을 해결한 UI 레이어 전용의 Trait을 제공하는데, 그것이 바로 Driver인 것 입니다.\nlet results &#x3D; query.rx.text.asDriver()\n\t.throttle(.milliseconds(300), scheduler: MainScheduler.instance)\n\t.flatMapLatest &#123; query in\n\t\tfetchAutoCompleteItems(query)\n\t\t\t.asDriver(onErrorJustReturn: [])\n\t&#125;\n\nresults\n\t.map &#123; &quot;\\($0.count)&quot; &#125;\n\t.drive(resultCount.rx.text)\n\t.disposed(by: self.disposeBag)\n\nresults\n\t.drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; _, result, cell in\n\t\tcell.textLabel?.text &#x3D; &quot;\\(result)&quot;\n\t&#125;\n\t.disposed(by: self.disposeBag)\n\n총 세 군데만 주목하면 됩니다!\n\n\n\n\n\n\n\n\n\nquery.rx.text.asDriver()  \nasDriver 메서드는 ControlProperty를 Driver로 변환합니다.\nDriver는 ControlProperty의 모든 프로퍼티를 갖기 때문에 따로 신경쓸 부분은 없이 변환만 하면 그대로 사용할 수 있습니다.\n\n\n\n\n\n\n\n\n\n.asDriver(onErrorJustReturn: [])\n이전에 살펴봤던 다음 세 가지 조건만 만족한다면, 어떤 Observable이던 Driver로 변환할 수 있습니다.\n\n에러가 방출하지 않습니다\nobserve가 Main Scheduler에서 이루어집니다.\nside effect를 공유합니다. (.share(replay:, scope:))\n\nlet safeSequence &#x3D; xs\n\t.observeOn(MainScheduler.instance)\n\t.catchErrorJustReturn(onErrorJustReturn)\n\t.share(replay: 1, scope: .whileConnected)\nreturn Driver(raw: safeSequence)\n\n정리해보면 위 과정과 asDriver(onErrorJustReturn: [])은 동일합니다.\n\n\n\n\n\n\n\n\n\n.drive()\n마지막으로 bind(to:) 대신 drive()를 사용합니다.\ndrive()를 사용함으로서 UI에 데이터를 안전하게 바인딩할 수 있습니다.\nSignal구독과 동시에 가장 마지막 이벤트를 replay하지 않는다는 점 외에는 Driver와 동일합니다. \n하지만 sequence를 공유한다는 점은 변하지 않기 때문에 share 메서드를 통해 원할 때는 값을 공유받을 수 있습니다.\nControlProperty &#x2F; ControlEventControlPropertyUI 컴포넌트의 프로퍼티를 내용으로 갖는 Observable&#x2F;ObservableType 입니다.\n\n실패하지 않습니다.\nshare(replay: 1)\nStateful 합니다. (구독과 동시에 마지막 값을 한 번 방출합니다.)\n\n\n에러를 발생시키지 않습니다.\n메인 쓰레드에서 동작합니다.\n\nextension Reactive where Base: UISearchBar &#123;\n\tpublic var value: ControlProperty&lt;String?&gt; &#123;\n\t\tlet source: Observable&lt;String?&gt; &#x3D; Observable.deferred &#123; [weak searchBar &#x3D; self.base as UISearchBar] () -&gt; Observable&lt;String?&gt; in\n\t\t\tlet text &#x3D; searchBar?.text\n\t\t\treturn (searchBar?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) ?? Observable.empty())\n\t\t\t\t.map &#123; a in\n\t\t\t\t\treturn a[1] as? String\n\t\t\t\t&#125;\n\t\t\t\t.startWith(text)\n\t\t&#125;\n\n\t\tlet bindingObserver &#x3D; Binder(self.base) &#123; (searchBar, text: String?) in\n\t\t\tsearchBar.text &#x3D; text\n\t\t&#125;\n\n\t\treturn ControlProperty(values: source, valueSink: bindingObserver)\n\t&#125;\n&#125;\n\nControlEventUI 컴포넌트의 이벤트를 내용으로 갖는 Observable&#x2F;ObservableType 입니다.\n\n실패하지 않습니다.\n구독이 이루어졌을 때 초기값을 방출하지 않습니다.\n에러를 방출하지 않습니다.\n메인 쓰레드에서 동작합니다.\n\nextension Reactive where Base: UICollectionView &#123;\n\tpublic var itemSelected: ControlEvent&lt;IndexPath&gt; &#123;\n\t\tlet source &#x3D; delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:)))\n\t\t\t.map &#123; a in\n\t\t\t\treturn a[1] as! IndexPath\n\t\t\t&#125;\n\n\t\treturn ControlEvent(events: source)\n\t&#125;\n&#125;\n\n참고 링크RxSwift Traits\n","slug":"Swift/2023-02-23-Swift23","date":"2023-02-22T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,RxSwift","author_index":"nomatterjun"},{"id":"98a6caad455ce327628ef8de6d0451a0","title":"22)🍎 Swift - Compositional Layout.02","content":"Supplementary ItemCollectionView를 사용하다보면 자주 사용하게 되는 요소들이 있습니다.\nBadges, Headers, Footers라고 불리는 이것들은 리스트의 앞이나 뒤에 붙어 전체적인 리스트에 대한 정보를 제공해줍니다.\nBadgesCompositionalLayout에서는 이런 SupplementaryItem들을 사용하기 더욱 쉽게 Anchor 개념을 도입했습니다.\n\n\nSupplementaryItem과 CollectionView의 시각적인 관계로서 이들의 위치를 정해준다는 개념입니다.\n개념 자체도 굉장히 쉽죠?\n적용도 동일하게 매우 쉽게 구현되었습니다.\nlet badgeAnchor &#x3D; NSCollectionLayoutAnchor(\n\tedges: [.top, .trailing],\n\tfractionalOffset: CGPoint(x: 0.3, y: -0.3)\n)\nlet badgeSize &#x3D; NSCollectionLayoutSize(\n\twidthDimension: .absolute(20),\n\theightDimension: .absolute(20)\n)\nlet badge &#x3D; NSCollectionLayoutSupplementaryItem(\n\tlayoutSize: badgeSize,\n\telementKind: &quot;badge&quot;,\n\tcontainerAnchor: badgeAnchor\n)\nlet item &#x3D; NSCollectionLayoutItem(\n\tlayoutSize: itemSize,\n\tsupplementaryItems: [badge]\n)\n\n여기서 적용된 badge라는 Item은 우측 상단에 위치하고 20x20의 사이즈를 갖는다는 것을 쉽게 알 수 있죠.\nHeader &amp; FooterHeader와 Footer는 Badges와는 다른 점이 있습니다.\nBadges는 Item의 특정 위치에 겹쳐보이는 요소지만, Header와 Footer는 Item을 밀어내고 공간을 차지하면서 위치하는 요소라는 점입니다.\n따라서 Header와 Footer는 Boundary라는 추가적인 기능을 갖고 있습니다.\nlet header &#x3D; NSCollectionLayoutBoundarySupplementaryItem(\n\tcontentSize: headerSize,\n\telementKind: &quot;header&quot;,\n\talignment: .top\n)\nlet footer &#x3D; NSCollectionLayoutBoundarySupplementaryItem(\n\tlayoutSize: footerSize,\n\telementKind: &quot;footer&quot;,\n\talignment: .bottom\n)\n\nheader.pinToVisibleBounds &#x3D; true\nsection.boundarySupplementaryItems &#x3D; [header, footer]\n\npinToVisibleBounds 프로퍼티를 사용해 흔히 말하는 Sticky Header 또한 만들기 쉬워졌습니다.\nDecoration ViewScrollView들의 배경을 꾸며주는 DecorationView 또한 아래처럼 사용할 수 있습니다.\nlet background &#x3D; NSCollectionLayoutDecorationItem.backgorund(elementKind: &quot;background&quot;)\nsection.backgroundItems &#x3D; [background]\n\nlayout.register(\n\tMyCoolDecorationView.self,\n\tforDecorationViewOfKind: &quot;background&quot;\n)\t\n\nEstimated Self-SizingItem들의 요소들의 크기가 정해지지 않고 변화하는 경우가 있습니다.\n컨텐츠가 있거나 없는 경우가 있을수도 있고, OS의 텍스트 크기를 변경함에 따라 size에 변화가 생길수도 있죠.\nsize를 설정해줄 때 .estimated을 활용하면 이에 대해 유연한 대응이 가능해집니다.\nlet headerSize &#x3D; NSCollectionLayoutSize(\n\twidthDimension: .fractionalWidth(1.0),\n\theightDimension: .estimated(44.0)\n)\nlet header &#x3D; NSCollectionLayoutBoundarySupplementaryitem(\n\tlayoutSize: headerSize,\n\telementKind: &quot;header&quot;,\n\talignment: .top\n)\nheader.pinToVisibleBounds &#x3D; true\nsection.boundarySupplementaryItems &#x3D; [header, footer]\n\n위 예시의 경우 Item의 높이를 컨텐츠의 크기 변화에 대응시킬 수 있는 것이죠.\nGroup 안에 Group 넣기CollectionView가 복잡해지면서 Group 안에 다른 Group을 넣을 일이 생길 수도 있겠죠.\n사실 NSCollectionLayoutGroup은 NSCollectionLayoutItem을 상속받은 하위타입입니다.\n다른 말로, Group을 모아서 다른 Group을 만들수도 있다는 의미죠.\n이런 Nesting에는 제한이 없기 때문에 상당히 다양한 형태의 디자인들을 만들 수 있게 되었습니다.\n\n\n이런 형태를 만드려면 어떻게 만들면 될까요?\nlet leadingItem &#x3D; NSCollectionLayoutItem(\n\tlayoutSize: leadingItemSize\n)\nlet trailingItem &#x3D; NSCollectionLayoutItem(\n\tlayoutSize: trailingItemSize\n)\nlet trailingGroup &#x3D; NSCollectionLayoutGroup.vertical(\n\tlayoutSize: trailingGroupSize,\n\tsubitem: trailingItem,\n\tcount: 2\n)\nlet containerGroup &#x3D; NSCollectionLayoutGroup.horizontal(\n\tlayoutSize: containerGroupSize,\n\tsubitems: [leadingItem, trailingGroup]\n)\n\n사실 굉장히 직관적으로 구성할 수 있습니다.\nleadingItem과 trailingItem 둘이 묶인 trailingGroup을 containerGroup으로 묶은 형태입니다.\nCollectionView를 CollectionView에 넣기CollectionView 안에 또 다른 CollectionView가 있을 경우, 스크롤하는 방향이 바뀌기 때문에 부자연스러운 동작을 보일 수 있습니다.\n이런 경우를 해결하기 위해서는\nsection.orthogonalScrollingBehavior &#x3D; .continuous\n\n이 한 줄의 코드를 추가해주면 해결됩니다.\nenum UICollectionLayoutSectionOrthogonalScrollingBehavior: Int &#123;\n\tcase none\n\tcase continuous\n\tcase continuousGroupLeadingBoundary\n\tcase paging\n\tcase groupPaging\n\tcase groupPagingCentered\n&#125;\n\n이렇게 두개의 continuous 옵션과 3개의 paging 옵션이 있으니 원하는 값을 찾아 넣어봅시다.\n","slug":"Swift/2023-01-31-Swift22","date":"2023-01-30T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"8bbfe0d3b3501508bfc41548ddec18f1","title":"21)🍎 Swift - Compositional Layout.01","content":"Compositional Layout\n\n\n\n\n\n\n\n\n높은 반응성을 갖고 유연한 UI 조정이 가능한 item들을 조합하여 사용하는 레이아웃입니다.\n애플이 Compositional Layout을 소개하면서 대표적으로 예시를 든 앱이 App Store와 사진 앱입니다.\n\n\n여러가지 형태의 레이아웃들이 줄지어 있지만, 이 화면은 단 하나의 CollectionView로 이루어져있다고 합니다.\n기존의 FlowLayout을 사용했다면 각기 다른 레이아웃에 따라 여러개의 CollectionView를 사용했어야 했지만 CompositionalLayout을 사용하면 하나의 CollectionView로 처리할 수 있다는 것이죠.\n그러면서도 이전보다 쉬운 API로 구현이 가능하고, 빠르고 메모리 최적화에 더 우수하다고 합니다.\n기본 개념CompositionalLayout은 세 가지의 핵심 요소에 집중하면 됩니다. \n가장 작은 단위인 Item이 모여서 Group 이 되고, 하나의 줄(row)를 형성합니다. \n이 Group들은 다시 한번 모여서 Section 을 이룹니다. 이렇게 만들어진 모든 Section을 Layout이 담고 있는 것이죠.\n\n\nSizeCompositionalLayout이 갖고 있는 이 모든 요소들은 각각의 size를 갖고 있습니다.\n그리고 size는 모두가 알고있듯이 width와 height, 두 가지 속성으로 이루어져 있습니다.\nclass NSCollectionLayoutSize &#123;\n\tinit(\n\t\twidthDimension: NSCollectionLayoutDimension,\n\t\theightDimension: NSCollectionLayoutDimension\n\t)\n&#125;\n\n하지만 주의할 점은 이 width와 height는 스칼라 값이 아닙니다. \n그래서 Float와 같은 타입이 아니라 NSCollectionLayoutDimension 타입의 값을 파라미터로 취합니다.\nclass NSCollectionLayoutDimension &#123;\n\tclass func fractionalWidth(_ fractionalWidth: CGFloat) -&gt; Self\n\tclass func fractionalHeight(_ fractionalHeight: CGFloat) -&gt; Self\n\tclass func absolute(_ absoluteDimension: CGFloat) -&gt; Self\n\tclass func estimated(_ estimatedDimension: CGFloat) -&gt; Self\n&#125;\n\n총 네 가지 타입으로 구분할 수 있고, 각각을 쉽게 설명하면 다음과 같습니다.\n\nfractional: 상위 컴포넌트(컨테이너)의 크기에 비례하여 크기를 가질 때 사용됩니다.\n\n.fractionalWidth(0.5), .fractionalHeight(0.3)\n\n\nabsolute: 고정된 값의 크기를 가질 때 사용됩니다.\n\n.absolute(200)\n\n\nestimated: 고정된 값으로 시작되지만 크기가 변동될 때 사용됩니다.\n\n.estimated(200)\n\n\n\nItemItem은 화면에 렌더링되는 요소입니다. \ncell이나 supplementary가 여기에 해당됩니다.\nclass NSCollectionLayoutItem &#123;\n\tconvenience init(layoutSize: NSCollectionLayoutSize)\n\tvar contentInsets: NSDirectionalEdgeInsets\n&#125;\n\n초기화할 때 size를 정해줘야하고, contentInsets를 통해 inset도 정해줄 수가 있네요.\nGroupGroup은 레이아웃으로서의 가장 기본적인 단위가 되는 요소입니다.\nGroup은 .horizontal, .vertical, .custom의 세가지 형태로 정의해줄 수 있습니다.\nGroup을 하나의 작은 FlowLayout이라고 생각해보면 이해가 쉽습니다.\n가로 혹은 세로 한쪽 방향으로 쭉 이어지는 레이아웃이니까요.\n한 쪽 방향으로만 진행되는 Group이 싫다면 .custom을 사용해 직접 구현해줄 수도 있습니다.\nclass NSCollectionLayoutGroup: NSCollectionLayoutItem &#123;\n\tclass func horizontal(\n\t\tlayoutSize: NSCollectionLayoutSize,\n\t\tsubitems: [NSCollectionLayoutItem]) -&gt; Self\n\tclass func vertical(\n\t\tlayoutSize: NSCollectionLayoutSize,\n\t\tsubitems: [NSCollectionLayoutItem]) -&gt; Self\n\tclass func custom(\n\t\tlayoutSize: NSCollectionLayoutSize,\n\t\titemProvider: NSCollectionLayoutGroupCustomItemProvider) -&gt; Self\n&#125;\n\nSectionSection은 말 그대로 Section을 기준으로 나열되는 CollectionView의 Section입니다.\n기존에 사용하던 Layout들의 Section과 동일한 개념입니다.\ndataSource로부터 Item의 개수를 받아와 Section을 구성합니다.\nclass NSCollectionLayoutSection &#123;\n\tconvenience init(layoutGroup: NSCollectionLayoutGroup)\n\tvar contentInsets: NSDirectionalEdgeInsets\n&#125;\n\nLayout그렇다면 레이아웃을 초기화해줄때는 어떻게 하면 될까요?\n애플은 두 가지 방법을 제공하고 있습니다.\nclass UICollectionViewCompositionalLayout: UICollectionViewLayout &#123;\n\tinit(section: NSCollectionLayoutSection)\n\tinit(sectionProvider: @escaping SectionProvider)\n&#125;\n\ninit(section: NSCollectionLayoutSection)레이아웃의 섹션을 직접 지정해주는 방식입니다. \n쉽고 간단하지만 현재 사용되는 레이아웃 방식과 차별성이 거의 없습니다.\ninit(sectionProvider: @escaping SectionProvider)Compositional하게 Section들을 구성해주려면 이 방식을 사용해야 합니다.\n@escaping 클로저가 보이시죠?\n이 클로저 안에서 각 Section마다의 독립적인 설정을 해줄 수 있습니다.\n정확히 해당 과정이 어떻게 이루어지는가는 활용 예시에서 다시 한번 보도록 하겠습니다.\n활용 예시간단한 테이블 리스트private func configureLayout() -&gt; UICollectionViewLayout &#123;\n\tlet itemSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(1.0),\n\t\theightDimension: .fractionalHeight(1.0)\n\t)\n\tlet item &#x3D; NSCollectionLayoutItem(layoutSize: itemSize)\n\n\tlet groupSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(1.0),\n\t\theightDimension: .absolute(44)\n\t)\n\tlet group &#x3D; NSCollectionLayoutGroup.horizontal(\n\t\tlayoutSize: groupSize,\n\t\tsubItems: [item]\n\t)\n\n\tlet section &#x3D; NSCollectionLayoutSection(group: group)\n\n\tlet layout &#x3D; UICollectionViewCompositionalLayout(section: section)\n\treturn layout\n&#125;\n\n\n\n가장 간단한 형태의 Layout이라고 볼 수 있습니다.\n한가지 주목할 점은 이 경우에 각 cell의 size를 Item이 아니라 Group을 활용해서 정해주었다는 점입니다.\n.horizontal 방향의 Group에는 각각 하나의 Item만을 갖고 있는 형태이기 때문에 활용할 수 있는 방법입니다.\n그래서 itemSize의 크기는 width, height 모두 .fractional(1.0)으로 그룹을 꽉 채워주었죠.\n대신 groupSize의 크기를 width는 .fractional(1.0), height를 .absolute(44)로 지정해주어 가로를 꽉 채우지만 높이는 44로 고정시켜주었습니다.\n한 줄의 개수가 5개로 고정된 그리드\n\n\n\n이번에는 무조건 한 줄에 무조건 5개의 cell이 들어가고, 정사각형의 형태를 가져야 하는 그리드 형식의 컬렉션뷰입니다.\n이 경우는 위에서 사용했던 코드에서 size 값만 변경해주는 것 만으로도 쉽게 구현할 수 있습니다.\nprivate func configureLayout() -&gt; UICollectionViewLayout &#123;\n\tlet itemSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(0.2),\n\t\theightDimension: .fractionalHeight(1.0)\n\t)\n\tlet item &#x3D; NSCollectionLayoutItem(layoutSize: itemSize)\n\n\tlet groupSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(1.0),\n\t\theightDimension: .fractionalWidth(0.2)\n\t)\n\tlet group &#x3D; NSCollectionLayoutGroup.horizontal(\n\t\tlayoutSize: groupSize,\n\t\tsubItems: [item]\n\t)\n\n\tlet section &#x3D; NSCollectionLayoutSection(group: group)\n\n\tlet layout &#x3D; UICollectionViewCompositionalLayout(section: section)\n\treturn layout\n&#125;\n\n각 아이템들의 width는 그룹 넓이의 20%(.fractionalWidth(0.2))로, 각 그룹들의 height는 섹션 넓이의 20%(.fractionalWidth(0.2))로 지정해주어 정사각형의 형태를 만들어주었습니다.\n\n\n그러면 위와 같이 inset을 주고 싶을땐 어떻게 줄 수 있을까요?\nprivate func configureLayout() -&gt; UICollectionViewLayout &#123;\n\tlet itemSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(0.2),\n\t\theightDimension: .fractionalHeight(1.0)\n\t)\n\tlet item &#x3D; NSCollectionLayoutItem(layoutSize: itemSize)\n\titem.contentInsets &#x3D; NSDirectionalEdgeInsets(top: 5, leading: 5, bottom: 5, trailing: 5)\n\n\tlet groupSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(1.0),\n\t\theightDimension: .fractionalWidth(0.2)\n\t)\n\tlet group &#x3D; NSCollectionLayoutGroup.horizontal(\n\t\tlayoutSize: groupSize,\n\t\tsubItems: [item]\n\t)\n\n\tlet section &#x3D; NSCollectionLayoutSection(group: group)\n\n\tlet layout &#x3D; UICollectionViewCompositionalLayout(section: section)\n\treturn layout\n&#125;\n\nitem.contentInsets = NSDirectionalEdgeInsets(top: 5, leading: 5, bottom: 5, trailing: 5) 이 부분만 추가해주면 됩니다!\ninset의 장점은 Layout의 변화 없이도 실제로 보여지는 각 cell의 크기를 변경해줄 수 있다는 점입니다.\n\n\n이번에는 비슷하지만 그리드 형태지만 다른 방식으로 구현해봅시다.\nprivate func configureLayout() -&gt; UICollectionViewLayout &#123;\n\tlet itemSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(1.0),\n\t\theightDimension: .fractionalHeight(1.0)\n\t)\n\tlet item &#x3D; NSCollectionLayoutItem(layoutSize: itemSize)\n\n\tlet groupSize &#x3D; NSCollectionLayoutSize(\n\t\twidthDimension: .fractionalWidth(1.0),\n\t\theightDimension: .absolute(44)\n\t)\n\tlet group &#x3D; NSCollectionLayoutGroup.horizontal(\n\t\tlayoutSize: groupSize,\n\t\trepeatingSubItem: item,\n\t\tcount: 2\n\t)\n\tlet spacing: CGFloat &#x3D; 10.0\n\tgroup.interItemSpacing &#x3D; .fixed(spacing)\n\n\tlet section &#x3D; NSCollectionLayoutSection(group: group)\n\tsection.interGroupSpacing &#x3D; spacing\n\tsection.contentInsets &#x3D; NSDirectionalEdgeInsets(top: 0, leading: 10, bottom: 0, trailing: 10)\n\n\tlet layout &#x3D; UICollectionViewCompositionalLayout(section: section)\n\treturn layout\n&#125;\n\n이 경우에 itemSize의 width와 height를 모두 .fractional(1.0)으로 주었지만, 이 값은 아래의 Group 설정에서 override됩니다.\nlet group &#x3D; NSCollectionLayoutGroup.horizontal(\n\tlayoutSize: groupSize,\n\tsubItem: item,\n\tcount: 2\n)\n\n이렇게 Item의 개수를 그룹별로 지정해주면, CompositionalLayout이 알아서 Item의 크기를 결정해줍니다.\n여러개의 Section을 갖는 경우지금까지는 Section이 하나인 경우, 즉 FlowLayout으로도 별 어려움 없이 구현할 수 있었던 경우들이였습니다.\nCompositionalLayout이 이걸 위해서 등장한 건 아니였죠.\n여러개의 Section을 갖고, 각각을 관리할 수 있는 경우를 살펴봅시다.\n\n\nfunc createLayout() -&gt; UICollectionViewLayout &#123;\n\tlet layout &#x3D; UICOllectionViewCompositionalLayout &#123; sectionIndex: Int, layoutEnvironment: NSCollectionLayoutEnvironment -&gt; NSCollectionLayoutSection? in\n\t\tguard let sectionLayoutKind &#x3D; SectionLayoutKind(rawValue: sectionIndex) else &#123; return nil &#125;\n\t\tlet columns &#x3D; sectionLayoutKind.columnCount\n\n\t\t&#x2F;&#x2F; 위 경우와 마찬가지로 아래 group 설정에서 override됨\n\t\tlet itemSize &#x3D; NSCollectionLayoutSize(\n\t\t\twidthDimension: .fractionalWidth(1.0),\n\t\t\theightDimension: .fractionalHeight(1.0)\n\t\t)\n\t\tlet item &#x3D; NSCollectionLayoutItem(layoutSize: itemSize)\n\t\titem.contentInsets &#x3D; NSDirectionalEdgeInsets(top: 2, leading: 2, bottom: 2, trailing: 2)\n\n\t\tlet groupHeight &#x3D; columns &#x3D;&#x3D; 1 ?\n\t\t\tNSCollectionLayoutDimension.absolute(44) :\n\t\t\tNSCollectionLayoutDimension.fractionalWidth(0.2)\n\t\tlet groupSize &#x3D; NSCollectionLayoutSize(\n\t\t\twidthDimension: .fractionalWidth(1.0),\n\t\t\theightDimension: groupHeight\n\t\t)\n\t\tlet group &#x3D; NSCollectionLayoutGroup.horizontal(\n\t\t\tlayoutSize: groupSize,\n\t\t\tsubitem: item,\n\t\t\tcount: columns\n\t\t)\n\t&#125;\n&#125;\n\n굉장히 굉장히 길어 보이지만 핵심은 하나입니다.\nlet layout &#x3D; UICollectionViewCompositionalLayout &#123; sectionIndex: Int, layoutEnvironment: NSCollectionLayoutEnvironment -&gt; NSCollectionLayoutSection? in\n\t&#x2F;&#x2F; \n&#125;\n\n이 부분이죠.\n이 모든 설정들은 SectionProvider 클로저 안에 있습니다.\n그리고 두 개의 파라미터를 제공합니다.\nsectionIndex는 말 그대로 Section의 index고, layoutEnvironment는 \bsize나 display scale과 같은 container의 프로퍼티들을 제공해주는 프로토콜입니다.\nSectionLayoutKind는 sectionIndex 값을 파라미터로 받아 Section의 종류를 결정해주고, 하나의 column에 몇개의 Item이 들어가는지를 정해주는 enum 타입입니다.\nenum SectionLayoutKind: Int, CaseIterable &#123;\n\tcase list, grid5, grid3\n\n\tvar columnCount: Int &#123;\n\t\tswitch self &#123;\n\t\tcase .grid3:\n\t\t\treturn 3\n\t\tcase .grid5:\n\t\t\treturn 5\n\t\tcase .list:\n\t\t\treturn 1\n\t\t&#125;\n\t&#125;\n&#125;\n\n이렇게 Section의 index에 따라서 여러 종류의 Layout을 지정해줄 수 있습니다.\n","slug":"Swift/2023-01-29-Swift21","date":"2023-01-28T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"a4bb605dd85632e4da94987ee3e7cc44","title":"20)🍎 Swift - RxFlow.02","content":"RxFlow험난한 길이 예상되지만 가봅시다..\n깃허브와 같은 순서대로 해봅시다.\nStep 정의import RxFlow\n\nenum FavorStep: Step &#123;\n\tcase signInIsRequired\n&#125;\n\n우선 로그인 Step만 만들어주었습니다.\nFlow 정의import UIKit\n\nimport RxFlow\n\nfinal class AppFlow: Flow &#123;\n\n\tvar root: Presentable &#123; self.rootViewController &#125;\n\n\tprivate lazy var rootViewController: UINavigationController &#x3D; &#123;\n\t\tlet navigationController &#x3D; UINavigationController()\n\t\treturn navigationController\n\t&#125;()\n\n\tinit() &#123; &#125;\n\n\tfunc navigate(to step: Step) -&gt; FlowContributors &#123;\n\t\tguard let step &#x3D; step as? FavorStep else &#123; return .none &#125;\n\n\t\tswitch step &#123;\n\t\t\tcase .signInIsRequired:\n\t\t\t\treturn self.navigateToAuth()\n\t\t&#125;\n\t&#125;\n&#125;\n\nprivate extension AppFlow &#123;\n\n\tfunc navigateToAuth() -&gt; FlowContributors &#123;\n\t\tlet selectSignInVC &#x3D; SelectSignInViewController()\n\t\treturn .one(\n\t\t\tflowContributor: .contribute(\n\t\t\t\twithNextPresentable: selectSignInVC, \n\t\t\t\twithNextStepper: OneStepper(withSingleStep: FavorStep.signInIsRequired)\n\t\t\t)\n\t\t)\n\t&#125;\n\n&#125;\n\n\n학습 중… 🚜\n\n","slug":"Swift/2023-01-28-Swift20","date":"2023-01-27T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Favor","author_index":"nomatterjun"},{"id":"908b0e0d798be07b2105b3cfcc4b1431","title":"19)🍎 Swift - RxFlow.01","content":"RxFlowFavor 프로젝트는 ReactorKit을 사용하여 MVVM-C패턴에 RxSwift를 적극적으로 활용하고 있습니다.\n하지만 저희 프로젝트에서 Reactive하지 못한 부분이 하나 있었습니다.\n바로 Coordinator 부분인데요..\n하위 Coordinator를 종료하기 위해서는 상위 Coordinator에 접근해야만 하는 현상을 발견헀습니다.\n바로 아래 코드처럼요..\nself.coordinator.parentCoordinator?.finish(childCoordinator: self.coordinator)\n\n한눈에 봐도 굉장히 깔끔해보이지 않습니다. 😵\n현재 코디네이터 ➡️ 상위 코디네이터에 접근을 한 뒤 다시 현재 코디네이터를 종료하는 메서드를 실행하는 것은 굉장히 좋지 않은 접근이라고 생각했습니다.\n때문에 두 가지 방법을 고안해보았는데요.\n\ndelegate 패턴을 사용하여 하위 코디네이터에서 직접적으로 상위 코디네이터에 접근하는 것을 방지\n\nextension AppCoordinator: CoordinatorFinishDelegate &#123;\n  func coordinatorDidFinish(childCoordinator: some Coordinator) &#123;\n    self.finish(childCoordinator: childCoordinator)\n    \n    self.navigationController.viewControllers.removeAll()\n    \n    switch childCoordinator.self &#123;\n    case is AuthCoordinator:\n      self.showTabBarFlow()\n    case is TabBarCoordinator:\n      self.showAuthFlow()\n    default:\n      break\n    &#125;\n  &#125;\n&#125;\n\n\noverride를 활용하여 추가 로직 구현 방식으로 접근\n\noverride func finish(childCoordinator: some Coordinator) &#123;\n  super.finish(childCoordinator: childCoordinator)\n  \n  self.navigationController.viewControllers.removeAll()\n  \n  switch childCoordinator.self &#123;\n  case is AuthCoordinator:\n    self.showTabBarFlow()\n  case is TabBarCoordinator:\n    self.showAuthFlow()\n  default:\n    break\n  &#125;\n&#125;\n\n사실 완벽하게 동일한 로직이지만 접근 방법의 차이를 갖고 있고, 어떤 방식이 더 나을까를 고민하던 중에\ndelegate 패턴을 사용하는 방식이 “위임”한다는 로직 측면에서는 직관적이지만 코드 가시성 측면에서는 복잡하다는 의견으로 귀결되었습니다.\ndelegate 패턴을 어떻게 하면 더 쉽게 사용할 수 있을까를 고민하던 중에 rx를 활용하면 되지 않을까라는 생각에 라이브러리를 찾아보게 되었고, RxFlow를 발견하게 되었습니다!\n❓ RxFlow란공식 GitHub 설명은 RxFlow를 다음과 같이 설명하고 있습니다.\n\n\n\n\n\n\n\n\n\nRxFlow는 Reactive Flow를 활용하여 Coordinator 패턴을 구현한 iOS 앱을 위한 navigation 라이브러리이다.\n요약하면 “코디네이터 패턴에 rx를 접목시켰다.” 정도겠네요.\nRxFlow는 Coordinator 패턴을 Reactive화 시킨 것이기 때문에 Coordinator 패턴의 장단점을 먼저 설명하고 있습니다.\n😊 장점\nUIViewController에서 네비게이션 코드를 분리한다.\nUIViewController를 다른 화면 전환 상황에서도 재사용할 수 있다.\n의존성 주입을 쉽게 이룰 수 있다.\n\n😭 단점\n코디네이터 패턴의 기본적인 로직들은 앱을 bootstrap할 때마다 작성해주어야 한다.\n코디네이터 패턴 스택의 교류 과정에서 boilerplate 코드가 많이 발생할 수 있다.\n\n그렇다면 RxFlow는 어떤 발전을 이루었다고 주장하고 있을까요?\n\nFlows를 활용하여 네비게이션을 좀 더 명확하게 발전시켰다.\nFlowCoordinator를 기본적으로 제공하여 Flows 사이의 네비게이션을 제어할 수 있다.\n네비게이션 액션들이 Reactive하게 이루어진다.\n\n그리고 아래는 RxFlow를 이해하기 위해 알아두어야 할 6가지 용어들입니다.\n\nFlow: 각각의 Flow는 앱의 네비게이션 공간들을 정의합니다. 이 공간은 네비게이션 액션들이 선언되는 곳입니다.\n\nStep: Step은 네비게이션까지 이어질 수 있는 state를 표현하기 위한 방법입니다. Flow와 Step을 조합하면 가능한 모든 네비게이션 액션을 설명할 수 있습니다. Step은 (id나 URL 같은) 내부적인 값들을 지니고 있을 수도 있어 이 값들을 Flow에 선언되어 있는 화면들에 전달할 수도 있습니다.\n\nStepper: Flow 안에서 Step을 발생시킬 수 있다면, 그 어떤 것도 Stepper라고 불릴 수 있습니다.\n\nPresentable: Present 될 수 있는 어떤 것을 추상적으로 표현한 개념입니다. (기본적으로 UIViewController와 Flow가 Presentable한 객체입니다.)\n\nFlowContributor: 어떤 것들이 Flow 안에서 새로운 Step을 만들어낼 수 있을지를 FlowCoordinator에게 알려주는 간단한 데이터 구조입니다.\n\nFlowCoordinator: 개발자가 적절한 Flow와 Step을 조합하여 가능한 네비게이션을 정의하면, FlowCoordinator는 앱의 모든 네비게이션을 제어하기 위해 이 조합들을 섞습니다. FlowCoordinator는 RxFlow에 의해 제공되어 개발자가 직접 구현하지 않아도 됩니다.\n\n\n사용 예시\n\n공식 문서는 위와 같은 영화 정보앱을 예시로 들어 설명하고 있습니다.\n하나씩 살펴볼게요..! 😉\nStep 정의우선 Step을 정의해주어야 합니다.\n한 가지 주의할 점은 Step은 앱의 상태를 나타내는 요소이기 때문에 어디로 navigation이 이루어질 지와 같은 특정적인 요소들은 Step이 아니라 Flow에서 정해줘야 한다고 합니다.\n예를 들어 showMovieDetail(withID: Int)는 영화를 선택했을 때 영화의 세부 정보를 보여주는 매우 특정된 케이스이기 때문에 바람직하지 않습니다.\n대신 movieIsPicked(withID: Int)와 같이 조금 더 독립적인 케이스를 추가해줘야 합니다. 이런 식으로 정의해주면 영화가 선택됐을 때 영화의 세부 정보 화면을 불러오는 것 말고도 다른 조건에서 다른 액션을 추가해줄 수 있습니다.\n아래와 같이 enum 타입으로 정의하는 것을 추천하고 있습니다.\nenum DemoStep: Step &#123;\n\t&#x2F;&#x2F; Login\n\tcase loginIsRequired\n\tcase userIsLoggedIn\n\n\t&#x2F;&#x2F; Onboarding\n\tcase onboardingIsRequired\n\tcase onboardingIsComplete\n\n\t&#x2F;&#x2F; Home\n\tcase dashboardIsRequired\n\n\t&#x2F;&#x2F; Movies\n\tcase moviesAreRequired\n\tcase movieIsPicked(withID: Int)\n\tcase castIsPicked(withID: Int)\n\n\t&#x2F;&#x2F; Settings\n\tcase settingsAreRequired\n\tcase settingsAreComplete\n&#125;\n\nFlow 정의Flow 정의는 두 가지를 필수적으로 해줘야합니다.\n\n네비게이션의 근간이 되는 root Presentable을 선언해줍니다.\nnavigate(to:) 메서드를 구현함으로서 Step을 네비게이션 액션으로 변환해주는 기능을 구현합니다.\n\nnavigate(to:) 메서드는 FlowContributos를 리턴합니다.\n.one(flowContributor: .contribute(withNextPresentable: viewController, withNextStepper: viewController.viewModel))의 형태로 리턴을 하면 되는데요.. 각 파라미터는 다음과 같습니다.\n\nviewController: 모두가 아는바와 같이 Presentable이고, LifeCycle에 따라 연결된 Stepper(ViewModel)가 Step을 emit하는 것에 영향을 줍니다.\n예를 들어 Presentable이 hidden(present되지 않은 상황)일 경우, Stepper가 Step을 emit한다고 해도 해당 emit은 효력이 없습니다.\n\n\nviewModel: Stepper로서 연결된 Presentable의 LifeCycle에 영향을 받으며, Step을 emit함으로서 Flow안에서 네비게이션에 기여합니다.\n\n부가적으로 Flow는 View Controller를 instantiate 해줄 때 이루어지는 의존성 주입에 이용될 수도 있습니다.\nclass WatchedFlow: Flow &#123;\n\tvar root: Presentable &#123;\n\t\treturn self.rootViewController\n\t&#125;\n\n\tprivate let rootViewController &#x3D; UINavigationController()\n\tprivate let services: AppServices\n\n\tinit(withServices services: AppServices) &#123;\n\t\tself.services &#x3D; services\n\t&#125;\n\n\tfunc navigate(to step: Step) -&gt; FlowContributors &#123;\n\t\tguard let step &#x3D; step as? DemoStep else &#123; return .none &#125;\n\n\t\tswitch step &#123;\n\t\tcase .moviesAreRequired:\n\t\t\treturn self.navigateToMovieListScreen()\n\t\tcase .movieIsPicked(let movieID):\n\t\t\treturn self.navigateToMovieDetailScreen(with: movieID)\n\t\tcase .castIsPicked(let castID):\n\t\t\treturn self.navigateToCastDetailScreen(with: castID)\n\t\tdefault:\n\t\t\treturn .none\n\t\t&#125;\n\t&#125;\n&#125;\n\nprivate extension WatchedFlow &#123;\n\n\tfunc navigateToMovieListScreen() -&gt; FlowContributors &#123;\n\t\tlet viewController &#x3D; WatchedViewController.instantiate(withViewModel: WatchedViewModel(), andServices: self.services)\n\t\tviewController.title &#x3D; &quot;Watched&quot;\n\n\t\tself.rootViewController.pushViewController(viewController, animated: true)\n\t\treturn .one(flowContributor: .contribute(withNextPresentable: viewController, withNextStepper: viewController.viewModel))\n\t&#125;\n\n\tfunc navigateToMovieDetailScreen(with movieID: Int) -&gt; FlowContributors &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n\n\tfunc navigateToCastDetailScreen(with castID: Int) -&gt; FlowContributors &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n&#125;\n\nStepper 정의Stepper는 protocol이기 때문에 어떤 것이든 될 수 있다고 합니다. ViewController가 될 수도 있고, ViewModel이 될 수도 있죠.\n하지만 ViewModel 같이 로직을 분리할 수 있는 곳에 사용하는 것이 적절합니다.\nRxFlow는 OneStepper라는 Stepper 클래스를 기본으로 구현하여 제공하고 있습니다. 아래와 같이 생겼는데요..\npublic class OneStepper: Stepper &#123;\n\tpublic let steps &#x3D; PublishRelay&lt;Step&gt;()\n\tprivate let singleStep: Step\n\n\tpublic init(withSingleStep singleStep: Step) &#123;\n\t\tself.singleStep &#x3D; singleStep\n\t&#125;\n\n\tpublic var initialStep: Step &#123;\n\t\treturn self.singleStep\n\t&#125;\n&#125;\n\n이 OneStepper는 초기화와 동시에 오직 하나의 Step을 emit하는 것을 유일한 로직으로 갖는 Stepper입니다.\n새로운 Flow를 생성하고 첫 Step을 실행할 때 유용하다고 합니다.\n아래 Stepper는 pick(movieID:) 메서드가 실행될 때마다 DemoStep.movieIsPicked(withID)를 emit합니다.\n해당 Step이 emit되면, 위의 WatchedFlow에서 navigate(to step:) 메서드가 실행되고, 결과적으로 navigateToMovieDetailScreen(withmovieID: Int) 메서드가 실행되게 됩니다.\nclass WatchedViewModel: Stepper &#123;\n\tlet movies: [MovieViewModel]\n\tlet steps &#x3D; PublishRelay&lt;Step&gt;()\n\n\tinit(with service: MovieService) &#123;\n\t\tself.movies &#x3D; service.watchedMovies().map(&#123; movie -&gt; MovieViewModel in\n\t\t\treturn MovieViewModel(id: movie.id, title: movie.title, image: movie.image)\n\t\t&#125;)\n\t&#125;\n\n\t&#x2F;&#x2F; 영화가 pick 됐을 때 새로운 Step을 emit합니다.\n\t&#x2F;&#x2F; 이 emit은 WatchedFlow에서 네비게이션 액션을 촉발합니다.\n\tpublic func pick(movieID: Int) &#123;\n\t\tself.steps.accept(DemoStep.movieIsPicked(withID: movieID))\n\t&#125;\n&#125;","slug":"Swift/2023-01-27-Swift19","date":"2023-01-26T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Favor","author_index":"nomatterjun"},{"id":"dd29b53b3fa8ec1be54827ce6b92cee8","title":"18)🍎 Swift - 다운샘플링","content":"다운샘플링으로 메모리 효율적인 이미지 처리하기이전 게시물에서 알아보았던 PHPicker를 사용해서 이미지를 처리하던 중 아래와 같은 에러를 마주쳤습니다.\n\nSwift가 허용한 4,194,304 바이트보다 큰 데이터를 UserDefaults에 저장할 수 없다는 에러입니다.\nUserDefaults는 작은 데이터들을 저장할 목적으로 만들어진 것이기 때문에 위와 같은 에러는 자연스러운 현상인 듯 합니다.\n지금 저장하려는 이미지는 원본 이미지 그 자체였으니 당연히 용량이 컸을 것이고, 이미지의 용량을 줄이려면 보통 이미지 크기를 줄이겠다는 생각부터 하겠죠?\n이미지 크기의 축소는 가장 직관적으로 이미지 용량을 줄이고 메모리 가용률도 높이는 좋은 방법 중 하나입니다.\n그래서 저도 이미지를 줄일 수 있는 방법부터 찾아보게 되었죠.\n이미지 리사이즈시의 CPU와 메모리 동작하지만 공부를 한 지 얼마 지나지 않아 단순히 이미지를 줄이는 방법은 좋은 방법이 아니고, 오히려 앱이 기기에 과부하를 더 줄 수 있다는 사실을 깨달았습니다.\n그 까닭은 2018년에 진행된 WWDC2018에서 찾아볼 수 있었습니다.\nImage and Graphics Best Practices - WWDC18 - Videos - Apple Developer\n이미 이미지 처리 게시물들에서 많이 다루고 있고 iOS의 화면 표현 방법을 학습해볼 수 있는 세션입니다.\n아래는 UIGraphicsImageRenderer를 사용하여 PHPicker를 통해 받은 이미지 여러개의 크기를 줄이는 코드입니다.\n\nvar images: [UIImage] &#x3D; []\n\nvar result in results &#123;\n\tresult.itemProvider.loadObject(ofClass: UIImage.self) &#123; object, error in\n\t\tguard let image &#x3D; object as? UIImage else &#123; return &#125;\n\t\tguard let resizedImage: UIImage &#x3D; UIGraphicsImageRenderer(size: CGSize(width: 2_000, height: 2_000)).image &#123; context in\n\t\t\timage.draw(in: CGRect(origin: CGPoint.zero, size: newSize))\n\t\t&#125; else &#123; return &#125;\n\t\timages.append(resizedImage)\n\t&#125;\n&#125;\n\n단순히 보기에는 아무런 문제가 없어보이죠.\n문제는 두 번에 걸쳐서 발생합니다.\n1. 원본을 로드한다.guard let image &#x3D; object as? UIImage else &#123; return &#125;\n\n첫 번째 문제입니다.\n이미지 사이즈를 줄이는 목적이 무엇이였나요?\n메모리에 부하를 덜 주기 위해서였죠.\n위 방법은 성공적으로 수행만 된다면 그 이후에는 메모리 사용률을 낮춰줄겁니다.\n그런데 이미지 크기를 줄이기 위해서 우선 원본 이미지를 한 번 로드해주어야 합니다.\n그 한 번 로드하는 과정에서 백그라운드 작업들을 종료시키거나 심하면 앱 자체를 종료시키는 현상이 발생할 수 있습니다.\n실제로 위 코드만 봐도 PHPicker는 선택한 데이터를 UIImage 타입으로서 제공하지 않습니다.\n굳이 크기가 큰 그 데이터를 아무런 처리 없이 UIImage로 바로 변환하여 사용하고 있었던 것이죠!\n2. 작은 이미지를 직접 그린다.image.draw(in: CGRect(origin: .zero, size: newSize))\n\n두 번째 문제입니다.\n위 방법은 이미지를 불러와 그 이미지의 작은 버전을 draw 메서드를 사용하여 직접 그려줘야 하는 방법입니다.\n그래픽 작업을 하는 것이기 때문에 CPU와 메모리 두 하드웨어 모두에게 작업을 부여하는 것이고, 이 또한 메모리 부하를 줄이는 것과는 거리가 먼 것을 알 수 있습니다.\n다운 샘플링그러면 단순히 이미지를 리사이징 하는 방법 외에 어떤 방법이 있을까요?\n\n바로 데이터를 UIImage로 바로 변환하여 사용하는 것이 아니라 CGImage 타입의 데이터를 사용하여 디코딩할 파일(data buffer) 자체의 사이즈를 줄이는 다운샘플링 방법이 있습니다.\n다만 이 방법은 Core Graphics이라는 한 층 더 low-level한 내용을 사용하기 때문에 코드가 좀 더 길고 복잡합니다.\nfunc downsample(at url: URL, to pointSize: CGSize, scale: CGFloat) -&gt; Data? &#123;\n\n\tlet sourceOptions &#x3D; [kCGImageSourceShouldCache: false] as CFDictionary\n\n\tguard let source &#x3D; CGImageSourceCreateWithURL(url as CFURL, sourceOptions) else &#123; return nil &#125;\n\n\tlet maxDimensionInPixels &#x3D; max(pointSize.width, pointSize.height) * scale\n\n\tlet downsampleOptions &#x3D; [\n\t\tkCGImageSourceCreateThumbnailFromImageAlways: true,\n\t\tkCGImageSourceCreateThumbnailWithTransform: true,\n\t\tkCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels\n\t] as CFDictionary\n\n\tguard let cgImage &#x3D; CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOptions) else &#123; return nil &#125;\n\n\tlet data &#x3D; NSMutableData()\n\n\tguard let imageDestination &#x3D; CGImageDestinationCreateWithData(data, UTType.jpeg.identifier as CFString, 1, nil) else &#123; return nil &#125;\n\n\tlet isPNG: Bool &#x3D; &#123;\n\t\tguard let utType &#x3D; cgImage.utType else &#123; return false &#125;\n\t\treturn (utType as String) &#x3D;&#x3D; UTType.png.identifier\n\t&#125;()\n\n\tlet destinationProperties &#x3D; [\n\t\tkCGImageDestinationLossyCompressionQuality: isPNG ? 1.0 : 0.75\n\t] as CFDictionary\n\n\tCGImageDestinationAddImage(imageDestination, cgImage, destinationProperties)\n\tCGImageDestinationFinalize(imageDestination)\n\n\treturn data as Data\n&#125;\n\n\n\n\n\n\n\n\n\n\n어질어질하쥬..? 😵\n복잡해 보이지만 두 파트로 나눌 수 있습니다. 한 번 살펴봅시다.\n1. CGImage 생성let sourceOptions &#x3D; [kCGImageSourceShouldCache: false] as CFDictionary\nguard let source &#x3D; CGImageSourceCreateWithURL(url as CFURL, sourceOptions) else &#123; return nil &#125;\n\nlet maxDimensionInPixels &#x3D; max(pointSize.width, pointSize.height) * scale\nlet downsampleOptions &#x3D; [\n\tkCGImageSourceCreateThumbnailFromImageAlways: true,  \n\tkCGImageSourceShouldCacheImmediately: true,\n\tkCGImageSourceCreateThumbnailWithTransform: true,\n\tkCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels\n] as CFDictionary\n\nguard let cgImage &#x3D; CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOptions) else &#123; return nil &#125;\n\ndownsampling의 핵심이 되는 부분입니다.\n사실상 필수적인 로직들은 이 안에 다 있습니다.\nOption flag를 정의해주고 해당 옵션을 통해 CGImage를 생성해주는 방식입니다.\n\nkCGImageSourceShouldCache: false\n이미지 소스에  대한 참조값만을 생성하고 CGImageSource가 생성되는 즉시 디코딩을 진행하지 않습니다.\n\n\nkCGImageSourceShouldCacheImmediately: true\n앞선 옵션과는 반대로 다운샘플링 로직이 시작됨과 동시에 디코딩 작업을 수행합니다.\n\n\nkCGImageSourceCreateThumbnailWithTransform: true\n다운샘플링된 이미지를 원본 이미지와 같은 형태를 갖도록 합니다.\n\n\n\n2. PNG 퀄리티 보존let data &#x3D; NSMutableData()\n\nguard let imageDestination &#x3D; CGImageDestinationCreateWithData(data, UTType.jpeg.identifier as CFString, 1, nil) else &#123; return nil &#125;\n\nlet isPNG: Bool &#x3D; &#123;\n\tguard let utType &#x3D; cgImage.utType else &#123; return false &#125;\n\treturn (utType as String) &#x3D;&#x3D; UTType.png.identifier\n&#125;()\n\nlet destinationProperties &#x3D; [\n\tkCGImageDestinationLossyCompressionQuality: isPNG ? 1.0 : 0.75\n] as CFDictionary\n\nCGImageDestinationAddImage(imageDestination, cgImage, destinationProperties)\nCGImageDestinationFinalize(imageDestination)\n\nreturn data as Data\n\n이 부분은 사실 선택적으로 구현하면 되는 부분입니다.\nPNG 확장자는 보통 스크린샷과 같이 이미지의 품질이 중요한 이미지들에 사용됩니다.\n이러한 이미지의 품질이 손상된다면 이미지에 포함된 텍스트 등의 시인성, 가독성이 중요한 요소들에 영향이 갈 수 있습니다.\nPNG 확장자라면 1.0의 손상 없는 압축을, 그 외의 확장자라면 0.75의 압축률로 데이터를 디코딩하였습니다.\nPHPicker와의 사용이전 PHPicker를 사용할 때는 아래와 같은 코드를 사용하였습니다.\nitemProvider.loadObject(ofClass: UIImage.self) &#123; image, error in\n\t&#x2F;&#x2F; do something\n&#125;\n\n이번 게시물에서 사용한 방법은 URL 타입으로 이미지를 받기 때문에 아래와 같이 사용해야 합니다.\nitemProvider.loadFileRepresentation(forTypeIdentifier: UTType.image.identifier) &#123; url, error in\n\t&#x2F;&#x2F; do something\n&#125;\n","slug":"Swift/2022-12-27-Swift18","date":"2022-12-26T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"d307c77550c3e506aba3109e585568f0","title":"17)🍎 Swift - Property Wrapper","content":"Property Wrapper오늘은 UserDefaults를 어떻게 하면 조금이라도 더 편하게 사용할 수 있을까 고민하다가 아주 좋은 친구를 발견했습니다.\n바로 Property Wrapper라는 친구인데요.\n이 친구는 SwiftUI와 Combine의 기능을 UIKit에서도 적용할 수 있도록 Swift 5.1버전에 등장했습니다.\n많은 게시물에서 SwiftUI의 @State를 예시로 들며 설명하고 있는데, 저는 경험이 없어서.. 넘어가구요…\n이름을 보면 프로퍼티를 감싸서 뭔가를 하는 친구인 것 같죠?\n바로 알아보도록 하겠습니다.\n용도일단 어떤 개념으로 사용되는 건지부터 알아봅시다.\nSwift에는 lazy프로퍼티 라는 것이 있습니다.\n해당 프로퍼티가 사용될 때 로드를 시작하도록 해주는 키워드이죠.\n이 lazy 키워드는 모든 키워드들에 붙일 수 있고 동일한 동작을 합니다.\n만약 이 키워드가 없다면 해당 기능을 구현하기 위해서 어떤 과정을 밟게 될까요?\nfunc getMyClass() -&gt; MyClass &#123;\n\tif self.myVar &#x3D;&#x3D; nil &#123;\n\t\tself.myVar &#x3D; MyClass()\n\t&#125;\n\treturn self.myVar\n&#125;\n\n위와 같이 해당 프로퍼티가 초기화가 됐는지 확인을 한 후에 값을 불러오는 함수를 만들어 모든 프로퍼티에 직접 구현하며 적용시켜주어야 할 거에요.\n다행히도 위 동작을 우리는\nlazy var myClass &#x3D; MyClass()\n\n이렇게 간편하게 구현할 수 있습니다.\nProperty Wrapper는 lazy와 같이 동일한 동작을 하는 프로퍼티들에 대해서 공통적으로 미리 구현된 동작들을 부여할 수 있는 기능입니다.\n정의프로퍼티를 감싸는 기능이기 때문에 우선 프로퍼티를 가질 수 있는 class, struct, enum 앞에 @propertyWrapper를 붙여 정의합니다.\n예시로 UserDefaults로 자동으로 동기화 작업을 하는 프로퍼티를 만들어보겠습니다.\n@propertyWrapper\nstruct UserDeafult&lt;T&gt; &#123;\n\tvar key: String\n\tvar defaultValue: T\n&#125;\n\n그런데 이렇게까지만 하면 해당 프로퍼티에 변경이 있을 때마다 어떤 작업이 실행되는지에 대한 명시가 없죠.\n그래서 에러가 발생하고, 그 에러를 살펴보면 wrappedValue가 정의되지 않았다는 것을 알 수 있습니다.\nwrappedValue를 정의해주고,  get-set을 사용하여 해당 프로퍼티가 변경될 때마다 발생하는 로직을 넣어줍니다.\nvar wrappedValue: T &#123;\n\tget &#123;\n\t\tUserDefaults.standard.object(forKey: key) as? T ?? defaultValue\n\t&#125;\n\tset &#123;\n\t\tUserDefaults.standard.set(newValue, forKey: key)\n\t&#125;\n&#125;\n\n이제 합쳐볼까요?\n@propertyWrapper\nstruct UserDefault&lt;T&gt; &#123;\n\tvar key: String\n\tvar defaultValue: T\n\n\tvar wrappedValue: T &#123;\n\t\tget &#123;\n\t\t\tUserDefaults.standard.object(forKey: key) as? T ?? defaultValue\n\t\t&#125;\n\t\tset &#123;\n\t\t\tUserDefaults.standard.get(newValue, forKey: key)\n\t\t&#125;\n\t&#125;\n&#125;\n\n사용자 그럼 적용은 어떻게 할까요?\nlazy와 마찬가지로 앞에 명시해주면 됩니다.\nstruct AppData &#123;\n\t@UserDefault(key: &quot;isLoggedIn&quot;, defaultValue: false)\n\tstatic var isLoggedIn: Bool\n\n\t@UserDefault(key: &quot;username&quot;, defaultValue: &quot;&quot;)\n\tstatic var username: String\n&#125;\n\nAppData.isLoggedIn &#x3D; true\nprint(AppData.isLoggedIn) &#x2F;&#x2F; true\n\nprint(AppData.username) &#x2F;&#x2F; &quot;&quot;\n\n조금 더 나아가서 커스텀 타입에도 적용될 수 있도록 바꿔봅시다.\n@propertyWrapper\nstruct UserDefault&lt;T: Codable&gt; &#123;\n\t&#x2F;&#x2F; key와 default 값은 바뀔 일이 없으니 let으로 변경\n\tprivate let key: String\n\tprivate let defaultValue: T\n\n\tinit(key: String, defaultValue: T) &#123;\n\t\tself.key &#x3D; key\n\t\tself.defaultValue &#x3D; defaultValue\n\t&#125;\n\n\tvar wrappedValue: T &#123;\n\t\tget &#123;\n\t\t\tguard let data &#x3D; Userdefaults.standard.object(forKey: key) as? Data else &#123;\n\t\t\t\treturn defaultValue\n\t\t\t&#125;\n\t\t\tlet value &#x3D; try? JSONDecoder().decode(T.self, from: data)\n\t\t\treturn value ?? defaultValue\n\t\t&#125;\n\t\tset &#123;\n\t\t\tlet data &#x3D; try? JSONEncoder().encode(newValue)\n\t\t\tUserDefaults.standard.set(data, forKey: key)\n\t\t&#125;\n\t&#125;\n&#125;\n\n이렇게 자동으로 UserDefaults로 값을 동기화시켜주는 Property Wrapper를 만들고 적용해보았습니다.\n참고 게시물# Create the Perfect UserDefaults Wrapper Using Property Wrapper\n","slug":"Swift/2022-12-26-Swift17","date":"2022-12-25T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"79bbbda6f45f64c92a28adda5128658d","title":"16)🍎 Swift - PHPicker","content":"PHPicker토이 프로젝트를 진행하던 중에 이미지를 선택해서 업로드하는 동작이 필요했습니다. \n당연히 처음에는 자료가 많은 UIImagePickerController를 사용하고자 했습니다.\n이 때는 PHPicker라는 모듈이 있는지도 몰랐었죠.\n기능이 굉장히 제한적이라는 사실에 한탄하며 공부를 하던 중에 iOS14에 기존의 UIImagePickerController를 대체하고자 PHPicker가 등장했다는 소식을 접하게 됐습니다.\n기본 사진 앱에 있는 다중선택&#x2F;줌인아웃&#x2F;검색 기능이 포함되어 있다고 하네요..! 🫢\nPhotoKit사실 이 PHPicker 라는 놈.. 혼자 떡하니 등장했던 건 아닙니다.\n애플이 라이브 포토 등을 추가하며 사진과 비디오 기능에 힘을 주기 위해 개발한 PhotoKit에 포함된 모듈들 중 하나입니다.\n역시 공식 문서가 정보를 찾기엔 가장 좋겠죠?\nTechnology - PhotoKit\n새로운 API를 소개하는 WWDC에서도 당연히 소개했던 적이 있습니다.\nWWDC2020 - Meet the new Photos picker\n세션 제목에도 “Photos”라고 강조를 해두었네요.\n개발자들이 얼마나 여러 사진 선택을 요구했었는지 확인할 수 있는 대목이 아닌가 싶습니다.\n살짝쿵 2021년과 2022년 세션에서도 소개된 내용을 살펴보니, 2021년에는 ProRAW 포맷 소개에 힘을 준 만큼 새로운 포맷 지원을 소개했고 2022년에는 실리콘 맥과 함께 떡상한 macOS에서도 PHPicker를 제대로 지원한다는 내용들이 있네요.\n이미 기존의 UIImagePicker를 완전히 대체한 것 같습니다.\n자 그래서 핵심은 뭐냐..?\nPHPicker는 PhotoKit 중에서도 PhotosUI 프레임워크에 포함되어 있기 때문에 사용하려면 PhotosUI를 import해야 합니다.\nimport PhotosUI\n\nPhotos Picker의 이점그래서 애플은 왜 Photos Picker(PHPicker)를 사용해야 한다고 할까요?\n기존의 UIImagePicker에 대응되는 6가지 이점을 내세우고 있습니다.\n\n이미지 로딩의 지연과 복구 UI\nRAW와 파노라마 이미지 등의 크고 복잡한 애셋을 안전하게 핸들링\nUIImagePickerController에서는 불가능한 유저 선택 옵션\n라이브 포토만을 선택할 수 있는 설정 제공\n라이브러리 접근 없이 PHLivePhoto 객체 사용 가능\n유효하지 않은 입력에 대한 까다로운 validation\n\n기존의 앱들은 핸드폰에 저장된 사진들에 접근하기 위해서 접근 요청을 했었죠?\n\n위 사진처럼요.\n하지만 새로운 PHPicker를 사용하면 프로필 사진 선택등의 단순한 사진 라이브러리 작업으로는 권한을 요구하지 않는다고 합니다.\n사진 편집, 카메라 앱등은 여전히 권한을 요구한다고 하네요.\n또한 사진을 단순히 저장하는 작업 또한 사진 저장 권한이라는 낮은 레벨의 권한만을 부여해서 사용자의 아이폰을 더 안전하게 지킬 수 있다고 합니다.\n\n가장 중요한 점은 보안에서입니다.\nPHPicker는 소프트웨어적인 캡처에서 안전합니다.\n스크린샷을 찍을 때 모든 컨텐츠(사진, 비디오)들을 렌더링하지 않은 상태로 캡처하여 불법 프로그램으로 인해 라이브러리가 캡처되어 개인 정보가 유출되는 것을 막을 수 있다고 합니다.\n이게 어떻게 가능한 것이냐?\nPHPicker는 앱 안에서 실행되는 것 같은 UI를 갖지만 사실을 독립된 다른 프로세스입니다. 위 사진에서처럼요.\n앱의 모양을 그저 렌더링하여 배경으로 보여주고 있는 것이죠.\n따라서 앱은 PHPicker의 기능들을 직접 사용하고 있는 것이 아니라, PHPicker는 따로 동작하고 유저가 선택한 컨텐츠들에 한해서만 정보를 제공하는 것입니다.\nPHPickerViewController\n위 사진에서 알 수 있듯이 PHPickerViewController는 PHPickerConfiguration을 통해 생성되고 제어할 수 있습니다.\nvar configuration &#x3D; PHPickerConfiguration()\n\nfilter와 selectionLimitfilter 프로퍼티로는 PHPicker에서 선택할 수 있는 컨텐츠 타입을 정해줄 수 있습니다.\nimages, livePhotos, videos, screenshots 등 다양한 옵션을 지원하고 있고, 따로 지정해주지 않는다면 기본값으로 .all 값을 갖습니다.\nconfiguration.filter &#x3D; .images\nconfiguration.filter &#x3D; .any(of:\n\t[.images, .livePhotos, .videos]\n)\n\nselectionLimit 프로퍼티로는 선택할 이미지의 개수를 정해줄 수 있습니다.\n기본값은 1이고, 음수의 값을 넣으면 앱이 크래쉬납니다.\nnumberOfLines와 같이 0의 값을 넣어주면 선택 개수를 제한 없이 설정해줄 수 있습니다.\nconfiguration.selectionLimit &#x3D; 12\n\n이렇게 설정해준 configuration 값은 PHPickerViewController의 파라미터로 넣어주어 적용합니다.\nlet imagePicker &#x3D; PHPickerViewController(configuration: configuration)\nimagePicker.delegate &#x3D; self\npresent(imagePicker, aniamted: true)\n\nUIImagePickerController와 마찬가지로 delegate까지 위임해주고 present하면 사진을 고를 수 있는 화면이 present됩니다.\n선택 결과 핸들링유저가 컨텐츠를 선택했다면 해당 컨텐츠들로 무언가를 해야겠죠.\nPHPicker는 delegate의 메서드를 통해 결과를 처리해줄 수 있습니다.\nPHPickerViewControllerDelegate 프로토콜을 채용해주고, \nextension DefaultImagePickerCoordinator: PHPickerViewControllerDelegate &#123;\n\n    func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) &#123;\n\t\t&#x2F;&#x2F; do something\n    &#125;\n\n&#125;\n\n유저가 선택을 완료했다는 버튼을 탭하면 호출되는 picker(_,didFinishPicking) 함수를 구현해줍니다.\nfunc picker(_ picker: PHPickerViewController, didFinishPicking reuslts: [PHPickerResult]) &#123;\n\tpicker.dismiss(animated: true)\n\n\tlet itemProvider &#x3D; results.first?.itemProvider\n\n\tif let itemProvider &#x3D; itemProvider, itemProvider.canLoadObject(ofClass: UIImage.self) &#123;\n\t\titemProvider.loadObject(ofClass: UIImage.self) &#123; image, error in\n\t\t\tif let image &#x3D; image &#123;\n\t\t\t\t&#x2F;&#x2F; do something\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n우선 picker.dismiss(animated:)로 PHPickerView를 dismiss 해줍니다.\n그 후 NSItemProvider라는 객체로부터 유저가 선택한 컨텐츠를 제공받을 수 있도록 초기화 과정과 실제로 불러오는 과정을 넣어줍니다.\n이 과정은 내부적으로 async하게 구현되어 있기 때문에 @escaping 클로저 안에서 이미지를 받아 처리해주어야 합니다.\n단순히 이미지나 비디오를 선택해서 받아오는 작업은 이것만으로도 충분합니다.\n여기까지의 작업은 사진 접근 권한을 요구하지 않지만 사진을 편집하는 등의 작업등은 사진 라이브러리 권한을 요구하고, PhotoKit의 다른 API를 활용하여 작업해야합니다.\n마무리오늘은 우선 여기까지 알아보았습니다.\n애플은 이미 UIImagePickerView를 deprecated 시켰습니다.\n구글 검색 결과는 아직 이전 게시물들을 상단에 노출시키고 있어 WWDC 세션을 찾아보지 않았다면 여전히 헤매고 있었을 것 같습니다.\n틈틈히 WWDC 구석구석을 살펴보는 습관을 가집시다!\n","slug":"Swift/2022-12-22-Swift16","date":"2022-12-21T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"7d828fe1b889c290d917612e7e7aa09f","title":"45)🧰 Swift - Date","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nDateUTC (Coordinated Universal Time)UTC는 국제적인 표준 시간(협전 세계시)입니다.\n영국의 그리니치 천문대를 기준으로 하여 전세계적인 시간 기준을 맞춰 사용하고 있습니다.\n우리나라의 경우 UTC+9의 시간을 가집니다.\n앱에서 시간을 다루는 경우는 굳이 생각해보지 않아도 굉장히 많겠죠?\n다른 모든 언어들이 날짜를 다루는 라이브러리를 제공하듯이 Swift 또한  Date라는 구조체를 제공하여 날짜를 사용할 수 있도록 해주었습니다.\n가장 단순한 예시를 들자면  Date()로 파라미터 없이 초기화만 해주어도 현재 시간을 반환해줍니다.\nlet now &#x3D; Date()\nprint(now) &#x2F;&#x2F; 2022-12-08 12:30:00 +0000\nprint(now.timeIntervalSinceReferenceDate) &#x2F;&#x2F; 647786168.423142\n\nDate 구조체Date를 잘 이해하려면 기준 시간을 인지하고 있어야 합니다.\n영국 시간을 기준으로 2001.01.01. 00:00:00 UTC 시간을 기준으로 잡고 계산을 합니다.\nDate 구조체는 기준 시간으로부터 시간이 몇 초나 흘렀는지에 대한 정보를 담고 있습니다. \n하지만 기본적으로 사람이 읽기 편하도록 2022-12-08 12:30:00 +0000와 같이 형식을 변환하여 반환하기 때문에 이 값은 볼 일이 많지 않죠.\n초 단위의 값을 보고 싶다면 .timeIntervalSinceReferenceDate를 통해  알아낼 수 있지만 쓸 일이 많을 것 같진 않네요..!참고로 이 함수는 값을 TimeInterval 타입으로 반환합니다. 이에 대한 건 뒤에 적어두도록 하겠습니다.\n또한 +0000을 보면 알 수 있듯이 이 시간은 각 지역의 시간에 맞추어 제공되는 것이 아니라 UTC+0시를 기준으로 제공됩니다.\n이 값을 지역에 맞게 제대로 사용하려면 달력(Calendar)이나 타임존(TimeZone)을 통해 변환해야 하고, Date 타입으로 제공되기 때문에 String 타입으로 변환하여 사용해야 합니다.\n\n\n\n\n\n\n\n\n\n보통 기준 시간은 1970년으로 잡지 않나요…?\n유닉스 기준 시간은 1970년 1월 1일이 맞습니다.\n그런데 애플은 이 날짜가 너무 오래전이라고 생각한 듯 싶습니다.\n기준 시간을 1970년으로 잡는 .timeIntervalSince1970  메서드도 지원하니 알아두시면 좋을 듯 합니다!\nnow.timeIntervalsince1970\n\nDate 변환하여 날짜와 시간 다루기Swift에서는 Date 구조체를 두 가지 방법으로 변환할 수 있습니다.\n날짜와 시간을 계산하기 위한 Calendar와 문자열로 표시하기 위한 DateFormatter가 두 방법입니다.\nCalendarCalendar는 타입 속성의 구조체 타입으로, Calendar.current로 확인할 수 있습니다.\n양력과 음력이 있지만 기본적으로 양력으로 설정되어 있기 때문에 대부분의 경우 기본값으로 사용해도 문제 없습니다.\nvar calendar &#x3D; Calendar.current\nCalendar(identifier: .gregorian) &#x2F;&#x2F; 양력\n\n지역 설정지역마다 날짜와 시간을 표기하는 형식이 다르기 때문에 지역 설정을 해주어야 합니다.&#96;\nprint(calendar.locale) &#x2F;&#x2F; en_US (current)\nprint(calendar.timeZone) &#x2F;&#x2F; Asia&#x2F;Seoul (current)\n\ncalendar.locale &#x3D; Locale(identifier: &quot;ko_KR&quot;)\ncalendar.timeZone &#x3D; TimeZone(identifier: &quot;Asia&#x2F;Seoul&quot;)\n\ntimeZone은 기기로부터 정보를 받아와서 자동으로 서울로 설정된 것 같네요.\nidentifier는 필요한 값을 그때그때 검색해서 사용하시면 됩니다.\nDate의 년&#x2F;월&#x2F;일&#x2F;시&#x2F;분&#x2F;초를 확인하는 방법\n.component 사용\n\nlet year: Int &#x3D; calendar.component(.year, from: now)\nlet month: Int &#x3D; calendar.component(.month, from: now)\nlet day: Int &#x3D; calendar.component(.day, from: now)\nlet hour: Int &#x3D; calendar.component(.hour, from: now)\nlet minute: Int &#x3D; calendar.component(.minute, from: now)\nlet second: Int &#x3D; calendar.component(.second, from: now)\n&#x2F;&#x2F; 요일 (일: 1, 월: 2, ...)\nlet weekday: Int &#x3D; calendar.component(.weekday, from: now)\n\n\n\n\n\n\n\n\n\n\n열거형을 사용하여 요일 계산하기\nenum Weekday: Int &#123;\n\tcase sunday &#x3D; 1, monday, tuesday, wednesday, thursday, friday, saturday\n\n\tstatic var today: Weekday &#123;\n\t\tlet weekday: Int &#x3D; Calendar.current.component(.weekday from: Date())\n\t\treturn Weekday(rawValue: weekday)!\n\t&#125;\n&#125;\n\nlet today &#x3D; Weekday.today &#x2F;&#x2F; monday\n\n한 번에 여러 데이터를 얻는 방법\n.dateComponents 사용\n\nvar myDateComp &#x3D; calendar.dateComponents([.year, .month, .day], from: now)\nprint(myDateComp.year) &#x2F;&#x2F; 2022\nprint(myDateComp.month) &#x2F;&#x2F; 12\nprint(myDateComp.day) &#x2F;&#x2F; 6\n\n\n\n\n\n\n\n\n\n\n두 날짜 사이의 일 수 계산하기\nlet startDate &#x3D; Date()\nlet endDate &#x3D; startDate.addingTimeInterval(3600 * 24 * 60)\nlet someDays &#x3D; Calendar.current.dateComponents([.day], from: startDate, to: endDate).day!\nprint(someDays) &#x2F;&#x2F; 60\n\nDateFormatterDateFormatter는 날짜와 시간을 원하는 형식의 문자열(String )으로 변환하는 방법을 제공하는 클래스입니다.\nRFC 3339 표준으로 작성되었기 때문에 원하는 형식을 검색해서 사용하면 됩니다.\nlet formatter &#x3D; DateFormatter()\n&#x2F;&#x2F; 지역 설정\nformatter.locale &#x3D; Locale(identifier: &quot;ko_KR&quot;)\n&#x2F;&#x2F; 시간대 설정\nformatter.timeZone &#x3D; TimeZone.current\n&#x2F;&#x2F; 혹은\nformatter.timeZone &#x3D; TimeZone(identifier: &quot;Asia&#x2F;Seoul&quot;)\n\n애플이 만들어둔 기존 형식으로 생성formatter.dateStyle &#x3D; .full &#x2F;&#x2F; &quot;Tuesday, December 6, 2022&quot;\nformatter.dateStyle &#x3D; .long &#x2F;&#x2F; &quot;December 6, 2022&quot;\nformatter.dateStyle &#x3D; .medium &#x2F;&#x2F; &quot;Dec 6, 2022&quot;\nformatter.dateStyle &#x3D; .none &#x2F;&#x2F; &quot;&quot;\nformatter.dateStyle &#x3D; .short &#x2F;&#x2F; &quot;12&#x2F;6&#x2F;22&quot;\n\nformatter.timeStyle &#x3D; .full &#x2F;&#x2F; &quot;2:53:12 PM Korean Standard Time&quot;\nformatter.timeStyle &#x3D; .long &#x2F;&#x2F; &quot;2:53:12 PM GMT+9&quot;\nformatter.timeStyle &#x3D; .medium &#x2F;&#x2F; &quot;2:53:12 PM&quot;\nformatter.timeStyle &#x3D; .none &#x2F;&#x2F; &quot;&quot;\nformatter.timeStyle &#x3D; .short &#x2F;&#x2F; &quot;2:55 PM&quot;","slug":"Allen/2022-12-06-Allen45","date":"2022-12-05T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"a100c7d58a4f32a64e774374f49a8b76","title":"44)🧰 Swift - Result","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nResultResult 타입은 열거형입니다.\n내부적으로 success(연관값)과 failure(연관값)을 갖고 있어요.\n성공했을 때와 실패했을 때의 정보를 모두 담고 있는 것이죠.\n이 Result 타입을 사용하면 do-catch문을 활용한 에러 처리를 보다 편리하게 할 수 있습니다.\nResult 타입을 활용한 에러의 처리func resultTypeCheckingHeight(hight: Int) -&gt; Result&lt;Bool, HeightError&gt; &#123;\n\tif height &gt; 190 &#123;\n\t\treturn Result.failure(HeightError.maxHeight)\n\t&#125; else if height &lt; 130 &#123;\n\t\treturn Result.failure(HeightError.minHeight)\n\t&#125; else &#123;\n\t\tif height &gt;&#x3D; 160 &#123;\n\t\t\treturn Result.success(true)\n\t\t&#125; else &#123;\n\t\t\treturn Result.success(false)\n\t\t&#125;\n\t&#125;\n&#125;\n\nlet result &#x3D; resultTypeCheckingHeight(height: 200)\n\nswitch result &#123;\ncase .success(let data):\n\tprint(&quot;결과값은 \\(data)입니다.&quot;)\ncase .failure(let error):\n\tprint(error)\n&#125;\n\nResult 타입을 사용하면 결과를 처리할 때 코드가 상당히 깔끔해지는 이점이 있습니다.\n연관값을 사용하여 바로 다른 작업을 수행할 수 있고, 에러를 하나의 case에서 통합하여 처리할 수 있게 됩니다.\ndo &#123;\n\tlet data &#x3D; try result.get()\n\tprint(&quot;결과값은 \\(data)입니다.&quot;)\n&#125; catch &#123;\n\tprint(error)\n&#125;\n\n위와 같이 get()을 사용하여 에러를 다시 한번 던져줄수도 있습니다.\n\n\n\n\n\n\n\n\n\nResult 타입을 왜 사용할까?\n성공과 실패의 경우를 명확하게 나누어 사용할 수 있습니다.\n에러 타입을 명시적으로 선언해서 타입캐스팅이 필요없다는 이점이 있어요.\n원래의 방식을 대체하려고 나온 것이 아니라 하나의 방법을 더 제안하는 방식으로 고안되었다고 합니다.\n네트워킹 코드에서 Result 타입예외 처리인만큼 네트워킹을 할 때 가장 많이 사용이 되겠죠.\n네트워킹 예시를 비교해보고 마치도록 하겠습니다.\nResult 타입 사용 전enum NetworkError: Error &#123;\n\tcase someError\n&#125;\n\nfunc performRequest(with url: String, completion: @escaping (Data?, NetworkError?) -&gt; Void) &#123;\n\tguard let url &#x3D; URL(string: url) else &#123; return &#125;\n\tURLSession.shared.dataTask(with: url) &#123; data, response, error in\n\t\tif error !&#x3D; nil &#123;\n\t\t\tprint(error!)\n\t\t\tcompletion(nil, .someError)\n\t\t\treturn\n\t\t&#125;\n\t\tguard let safeData &#x3D; data else &#123;\n\t\t\tcompletion(nil, .someError)\n\t\t\treturn\n\t\t&#125;\n\t\tcompletion(safeData, nil)\n\t&#125;.resume()\n&#125;\n\nperformRequest(with: &quot;URL&quot;) &#123;  data, error in\n\tif error !&#x3D; nil &#123;\n\t\tprint(error!)\n\t&#125;\n\n\t&#x2F;&#x2F; 데이터 처리 관련 코드\n&#125;\n\nResult 타입 사용 후func performRequest(with urlString: String, completion: @escaping (Result&lt;Data, NetworkError&gt;) -&gt; Void) &#123;\n\tguard let url &#x3D; URL(string: urlString) else &#123; return &#125;\n\tURLSession.shared.dataTask(with: url) &#123; data, response, error in\n\t\tif error !&#x3D; nil &#123;\n\t\t\tprint(error!)\n\t\t\tcompletion(.failure(.someError))\n\t\t\treturn\n\t\t&#125;\n\t\tguard let safeData &#x3D; data else &#123;\n\t\t\tcompletion(.failure(.someError))\n\t\t\treturn\n\t\t&#125;\n\t\tcompletion(.success(safeData))\n\t&#125;\n&#125;\n\nperformRequest(with: &quot;URL&quot;) &#123; result in\n\tswitch result &#123;\n\tcase .success(let data):\n\t\tbreak\n\tcase .failure(let error):\n\t\tbreak\n\t&#125;\n&#125;\n\n","slug":"Allen/2022-12-05-Allen44","date":"2022-12-04T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"c2e56e6a64d2c2ad251d398ab5d466c0","title":"43)🧰 Swift - 제네릭 (Generics)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n제네릭 (Generics)제네릭이 왜 필요한가?var num1 &#x3D; 10\nvar num2 &#x3D; 20\n\nfunc swapTwoInts(_ a: inout  Int, _ b: inout Int) &#123;\n\tlet tempA &#x3D; a\n\ta &#x3D; b\n\tb &#x3D; tempA\n&#125;\n\nswapTwoInts(&amp;num1, &amp;num2)\nprint(num1) \nprint(num2)\n\n타입을 한정지어 메서드를 만든다면 위의 예시와 같이 만들면 되고, 아무런 문제가 없습니다.\n그런데 만약 Double 타입도 파라미터로 받고 싶다면..?\nString까지도 받고 싶다면 어떻게 해야할까요?\n타입별로 모든 메서드를 따로 만들어줘야겠죠.\n그런데 이런 방법은 너무 번거롭습니다.\n제네릭을 사용하면 여러 타입에 대해 대응이 가능하기 때문에 이런 번거로움이 줄일 수 있습니다.\nfunc swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) -&gt; T &#123;\n\tlet tempA &#x3D; a\n\ta &#x3D; b\n\tb &#x3D; tempA\n\treturn a\n&#125;\n\n제네릭 문법제네릭 문법은 타입에 관계없이 한번의 구현으로 모든 타입에 대한 처리가 가능해서 유연한 함수를 작성할 수 있도록 해주는 문법입니다.\n심지어 함수 뿐만 아니라 구조체, 클래스, 열거형 모두 일반화가 가능합니다.\n타입 파라미터는 함수 내부에서 파라미터 형식이나 리턴형으로 사용할 수 있습니다.\n보통 T(Type)로 사용하지만 다른 이름을 사용해도 문제는 없으며, 두 개 이상을 선언하는 것도 아무 문제가 없습니다.\n제네릭의 사용 예시 (Swift 문법)저희는 사실 이런 제네릭 문법을 지금까지 많이 사용했습니다.\nSwift에서 컬렉션은 모두 제네릭 타입의 구조체로 구현되어 있기 떄문인데요..\nlet array1: [String] &#x3D; [] \nlet array2: Array&lt;String&gt; &#x3D; []\n\nlet dictionary1: [String: Int] &#x3D; [&quot;Steve&quot;: 24]\nlet dictionary2: Dictionary&lt;String, Int&gt; &#x3D; [&quot;Alex&quot;: 25]\n\nlet optional1: String?\nlet optional2: Optional&lt;String&gt;\n\n배열, 딕셔너리, 옵셔널 모두 사실은 제네릭 타입을 사용하고 있습니다.\n[1, 2, 3].map(transform: (Int) throws -&gt; T)\n\n또한 map과 같은 고차함수들도 모두 제네릭 타입을 사용하고 있습니다.\n제네릭 정의하기구조체로 제네릭 정의하기struct GenericMember&lt;T&gt; &#123;\n\tvar members: [T] &#x3D; []\n&#125;\nvar member1 &#x3D; GenericMember(members: [&quot;Jobs&quot;, &quot;Cook&quot;, &quot;Musk&quot;])\nvar member2 &#x3D; GenericMember(members: [1, 2, 3])\n\n클래스로 제네릭 정의하기class GridPoint&lt;A&gt; &#123;\n\tvar x: A\n\tvar y: A\n\n\tinit(x: A, y: A) &#123;\n\t\tself.x &#x3D; x\n\t\tself.y &#x3D; y\n\t&#125;\n&#125;\n\nlet aPoint &#x3D; GridPoint(x: 10, y: 20)\nlet bPoint &#x3D; GridPoint(x: 10.4, y: 20.5)\n\n열거형으로 제네릭 정의하기열거형에서는 연관값을 가질때만 제네릭으로 정의할 수 있습니다.\nenum Pet&lt;T&gt; &#123;\n\tcase dog\n\tcase cat\n\tcase etc(T)\n&#125;\n\nlet animal &#x3D; Pet.etc(&quot;고슴도치&quot;)\n\n제네릭 구조체의 확장제네릭 타입을 확장할 떄는 &lt;T&gt;는 생략해야 합니다.\nstruct Coordinates&lt;T&gt; &#123;\n\tvar x: T\n\tvar y: T\n&#125;\n\nextension Coordinates &#123; &#x2F;&#x2F; Coordinates&lt;T&gt; (X)\n\tfunc getPlace() -&gt; (T, T) &#123;\n\t\treturn (x, y)\n\t&#125;\n&#125;\n\n또한 where절을 추가하여 제네릭 타입에 제한을 줄 수도 있습니다.\nextension Coordinates where T &#x3D;&#x3D; Int &#123;\n\tfunc getIntArray() -&gt; [T] &#123;\n\t\treturn [x, y]\n\t&#125;\n&#125;\n\n타입 제약제네릭을 사용하더라도 모든 타입에 대해서 열어두기는 싫을 때가 있겠죠.\n그럴때는 타입 매개 변수 뒤에 콜론(:)을 붙이고 프로토콜이나 단일 클래스를 적어 제한을 둘 수 있습니다.\nfind findIndex&lt;T: Equatable&gt;(item: T, array: [T]) -&gt; Int? &#123;\n\tfor (index, value) in array.enumerated() &#123;\n\t\tif item &#x3D;&#x3D; value &#123;\n\t\t\treturn index\n\t\t&#125;\n\t&#125;\n\treturn nil\n&#125;\n\nlet aNumber &#x3D; 5\nlet someArray &#x3D; [3, 4, 5, 6, 7]\n\nif let index &#x3D; findIndex(item: aNumber, array: someArray) &#123;\n\tprint(&quot;밸류 값과 같은 배열의 인덱스: \\(index)&quot;) &#x2F;&#x2F; 2\n&#125;\n\n위 예시에서 T 타입은 Equatable 프로토콜을 채택한 타입들만 들어갈 수 있습니다.\n프로토콜에서의 제네릭 문법 사용protocol RemoteControl &#123;\n\tassociatedtype T\n\tfunc chnageChannel(to: T)\n\tfunc alert() -&gt; T?\n&#125;\n\nprotocol에서도 제네릭 타입을 사용할 수 있지만, &lt;T&gt;와 같이 사용하는 것이 아니라 associatedtype을 사용합니다.\n이 프로토콜을 사용하는 방법은 아래와 같습니다.\nstruct TV: RemoteControl &#123;\n\ttypealias T &#x3D; Int &#x2F;&#x2F; 생략 가능\n\n\tfunc changeChannel(to: Int) &#123;\n\t\tprint(&quot;TV 채널바꿈: \\(to)&quot;)\n\t&#125;\n\n\tfunc alert() -&gt; Int? &#123;\n\t\treturn 1\n\t&#125;\n&#125;","slug":"Allen/2022-12-05-Allen43","date":"2022-12-04T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"8fd8cb15083779ba6732fe56b2a7d55a","title":"42)🧰 Swift - 동시성 프로그래밍","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n비동기 프로그래밍비동기 처리가 필요한 이유네트워크 통신과 비동기 처리대부분의 앱에서는 서버와의 통신이 필요합니다. \n\n당근 마켓의 화면입니다. UIKit의 요소만 보자면 단순하게 테이블뷰를 나열한 것이지만, 그 내용은 서버에서 받아온 데이터들로 이루어져 있습니다.\n\n그런데 이 테이블뷰를 스크롤하면 새롭게 화면에 보여지는 내용을 보여주기 위해서 서버와 통신을 해야겠죠.\n이 통신 과정을 동기적으로 처리한다면, 스크롤 할 때마다 화면이 버벅이는 현상이 발생합니다.\nThread우리가 코드로 적은 프로그램은 CPU의 쓰레드에서 한 줄 씩 실행됩니다.\n\n\n\n\n\n\n\n\n\n\n출처: 레나참나님 블로그\n그런데 별 다른 명시가 없다면(비동기 프로그래밍을 하지 않는다면) 이 코드의 실행이 모두 1번 쓰레드(메인 쓰레드)에서 실행됩니다.\nprint문과 같은 단순한 작업들은 전부 메인 쓰레드에서 동작해도 아무 문제가 없지만, 네트워킹과 같은 비교적 무거운 작업들은 메인 쓰레드에서 동작시키면 상당히 긴 작업시간을 잡아먹어버리게 됩니다.\n그러면 이런 무거운 작업들을 놀고 있는 2번 쓰레드, 3번 쓰레드 등에 넘겨주면 메인 쓰레드는 다른 가벼운 작업들을 멈춤 없이 실행할 수 있겠죠!\n사실 메인 쓰레드는 우리가 입력한 코드 외에도 할 일이 매우 많습니다.\n앱의 시작 과정과 동작 원리앱의 시작 과정과 동작은 모두 메인 쓰레드에서 담당합니다.\n앱을 처음 실행하면, 다른 모든 프로그램들과 마찬가지로 main 함수가 실행됩니다.\n이 main 함수는 UIApplicationMain()이라는 앱 객체를 생성하고 UI 구성, 앱 상태 측정등의 앱 준비 과정을 거쳐서 앱이 실행됩니다.\n앱이 실행된 후에는 런루프가 생성됩니다. 이 런루프는 무한 반복문으로서 유저의 인터랙션(터치, 핀치 등)을 받아 그 이벤트를 처리하는 객체입니다.\n\nex) @IBAction, #selector\n\n\n\n아이폰의 화면은 대부분 60Hz입니다. (최근엔 144Hz까지 지원하는 기종도 있지만)\n그렇다면 1초에 60번 화면을 출력해야 하는데 이 1초의 과정을 Update Cycle이라고 하고, 메인 쓰레드가 담당하여 화면 출력을 위한 연산을 합니다.\n그래서 사실 우리가 입력하는 코드는 이 사이클 중간중간에 끼워넣어지는 것이죠..!\n화면이 버벅이는 현상은 여기서 발생합니다.\n네트워킹과 같은 무거운 작업이 메인 쓰레드를 붙잡고 있어버리면, 이 업데이트 사이클이 돌지 못해버리는 현상이 발생합니다.\n따라서 화면이 새로 그려지지 못하고, 멈추는 것과 같은 현상이 발생하는 것이죠.\n그래서 화면을 그리는 일을 방해하지 않으면서 무거운 작업을 하기 위해서는 동시성 프로그래밍을 해야한다는 것입니다.\n다행히 iOS의 동시성 프로그래밍은 매우매우 쉬운 편입니다.\niOS에서의 동시성 프로그래밍iOS에서는 작업(Task)를 “대기행렬”(Queue)에 보내기만 해주면, iOS가 알아서 순서대로 작업 처리를 해줍니다.\n할 일을 iOS에서 관리해주는 Queue에 던져주기만 하면 알아서 순서대로 작업을 해준다는 뜻입니다.\n조금 더 정확히 설명하면, Queue에 넣어준 작업(Task)들은 FIFO 방식으로 즉시 각각의 쓰레드에 배치됩니다.\niOS는 두 가지 Queue를 제공합니다.\n\nDispatchQueue\n&#x3D; GCD(Grand Central DispatchQueue)\n\n\nOperationQueue\n\n여기서 우리가 주목해야할 것은 DispatchQueue입니다. OperationQueue는 상당히 어려운 개념이고, 실무에서도 거의 사용되지 않기 때문에 우선 DispatchQueue만 공부해보도록 하겠습니다!\nNSThread자 그런데, 사실 프로그래밍을 하며 관리하는 소프트웨어적인 쓰레드(NSThread)는 하드웨어의 쓰레드와 1:1 매칭되는 객체는 아닙니다.\n물리적인 쓰레드는 하나하나가 굉장히 빠릅니다.\n사실 소프트웨어적으로 아무리 작업을 끼워넣어도 하드웨어적인 쓰레드에게는 매우 여유로운 일입니다.\n그래서 하드웨어적인 쓰레드는 한가지 NSThread에서만 일하지 않고, 여러 군데에 왔다갔다하면서 작업을 수행합니다.\n이 과정은 OS가 알아서 해주는 동작이라서 코딩을 하는 우리는 NSThread의 개수가 하드웨어적으로 명시된 쓰레드의 개수보다는 훨씬 많겠구나! 정도만 알아두면 될 것 같습니다.\n비동기(async), 동시(concurrent)의 개념동기(sync) vs 비동기(async)\n- 비동기(asynchronous)\n    - 작업을 시작한 후에, 작업이 끝나길 기다리지 않는다\n    - 작업을 시작시킨 후에 다른 작업을 하러 간다.\n- 동기(synchronous)\n    - 작업을 시작한 후에, 작업이 끝날때까지 기다린다.\n    - 작업이 수행되는 동안 쓰레드는 block된다.\n\n직렬(Serial) vs 병렬(concurrent)\n직렬(serial)\n하나의 쓰레드만 생성하여 하나의 쓰레드로만 작업 전달\n순서가 중요한 작업을 처리할 때 사용\n\n\n병렬(concurrent)\n여러개의 쓰레드를 생성하여 알아서 알맞는 쓰레드에 작업 전달\n각자 독립적이지만 유사한 여러개의 작업을 처리할 때 사용\n\n\n\nGCD의 개념 및 종류큐(Queue)의 종류\n\n\n:큐의 종류\n\n생성 코드\n특징\n직렬&#x2F;동시\n\n\n\nDispatch  Queue\n.main\nDispatchQueue.main\n메인큐 &#x3D; 메인쓰레드\nSerial\n\n\n\n.global()\nDispatchQueue.global(qos:)\n6가지 Qos (작업에 따라 Qos 상승 가능)\nConcurrent\n\n\n\ncustom\nDispatchQueue(label: &quot;...&quot;)\nQos추론 &#x2F; 설정 가능\nBoth\n\n\n:OperationQueue\n\nlet opQ = OperationQueue()\n디폴트: .background, underlying 디스패치큐에 영향\nBoth\n\n\n&#x2F;&#x2F; 직렬 Queue\nlet privateQueue &#x3D; DispatchQueue(label: &quot;com.inflearn.serial&quot;)\n\nlet concurrentQueue &#x3D; DispatchQueue(label: &quot;custom&quot;, attributes: .concurrent)\n\nGCD 사용 시 주의해야 할 사항1) 반드시 메인큐에서 처리해야하는 작업화면을 그리는 UI와 관련된 작업들은 메인쓰레드에서 동작해야합니다.\n따라서 GCD를 사용하여 메인쓰레드가 아닌 쓰레드에서 동작하던 코드 중간에 UI와 관련된 작업이 필요하다면, 메인 쓰레드에 이 작업을 보내주는 작업이 필요합니다.\n&#x2F;&#x2F; URLSession은 내부적으로 비동기 작업\nURLSession.shared.dataTask(with: url) &#123; data, response, error in\n\tif let error &#x3D; error &#123;\n\t\tprint(&quot;에러&quot;)\n\t&#125;\n\n\tguard let imageData &#x3D; data else &#123; return &#125;\n\tlet photoImage &#x3D; UIImage(data: imageData)\n\tDispatchQueue.main.async &#123; &#x2F;&#x2F; UI 관련 작업은 main thread에서\n\t\timageView?.image &#x3D; photoImage\n\t&#125;\n&#125;.resume()\n\n2) 컴플리션 핸들러의 존재 이유 - 올바른 콜백 함수의 사용비동기 처리를 사용하다보면 발생하는 문제점이 하나 있습니다.\n비동기적이라고 하면 일을 시작시키고 작업이 끝날때까지 기다리지 않고 다른 일을 처리하러 간다는 장점이 있었습니다.\n비동기적으로 처리시킨 작업이 끝나는 시점에 필요한 작업이 있다면 어떻게 해야할까요? 예를 들면 작업이 끝났을 때 나온 결과를 return해야할 경우가 있습니다.\nreturn 구문을 사용한다면 작업이 끝나기 전에 끝나버리기 때문에 항상 nil 값을 받아올 것입니다.\nfunc getImages(str: String) -&gt; UIImage? &#123;\n\tURLSession.shared.dataTask(...) &#123;\n\t&#125;.resume()\n\treturn photoImage &#x2F;&#x2F; nil (작업이 끝나지 않았는데 return)\n&#125;\n\n이 때 바로 @escaping 클로저가 등장합니다.\nfunc getImage(str: String, completion: @escaping ((UIImage?) -&gt; Void) &#123;\n\tURLSession.shared.dataTask(...) &#123;\n\t\tcompletion(photoImage) &#x2F;&#x2F; 내부 작업이 끝나면 escaping closure 호출\n\t&#125;.resume()\n&#125;\n\ngetImage(&quot;url&quot;) &#123; image in\n\timageView?.setImage(image)\n&#125;\n\n@escaping 클로저의 파라미터로 데이터를 받아 처리를 하면, 해당 함수가 “끝난” 시점에 클로저를 호출할 수 있기 때문에 이런 방식으로 사용해야합니다.\n3) weak, strong 캡처의 주의DispatchQueue.global(qos: .utility).async &#123; [weak self] in\n\tguard let self &#x3D; self else &#123; return &#125;\n\tDispatchQueue.main.async &#123;\n\t\tself.textLabel.text &#x3D; &quot;New posts updated.&quot;\n\t&#125;\n&#125;\n\n대부분의 경우, 캡처리스트 안에서 weak self로 선언하는 것이 권장됩니다.\n4) 동기함수를 비동기적으로 동작하는 함수로 변형func longTimePrint(name: String) -&gt; String &#123;\n\tprint(&quot;1&quot;)\n\tsleep(1)\n\tprint(&quot;2&quot;)\n\tsleep(2)\n\tprint(&quot;3&quot;)\n\tsleep(3)\n\treturn &quot;작업 종료&quot;\n&#125;\n\nfunc asyncLongTimePrint(name: String, completion: @escaping (String -&gt; Void) &#123;\n\tDispatchQueue.global().async &#123;\n\t\tlet n &#x3D; longtimePrint(name: name)\n\t\tcompletion(n)\n\t&#125;\n&#125;\n\n비동기 함수&#x2F;메서드의 이해URLSession대표적으로 URLSesison은 이미 내부적으로 GCD를 이용해서 비동기적으로 처리하는 메서드로 생각해야 합니다.\n따라서 굳이 DispatchQueue로 감싸주지 않아도 됩니다.\n그런데 비슷한 동작을 하는 Data(contentsOf: url)의 경우에는 비동기적으로 만들어져 있지 않습니다.\n애플 공식 문서를 보고 비동기적으로 구현된 함수인지 아닌지 확인하면서 사용해야할 것 같습니다!\nasync&#x2F;await의 도입Swift 5.5이후 async와 await가 도입되었습니다. 파이썬과 자바스크립트에서 사용되던 패턴을 Swift에 맞게 가져온 개념입니다.\nfunc processImageData(completion: (_ result: Image) -&gt; Void) &#123;\n\tloadWebResource(&quot;dataprofile.txt&quot;) &#123; dataResource in\n\t\tloadWebResource(&quot;imagedata.dat&quot;) &#123; imageResource in\n\t\t\tdecodeImage(dataResource, imageResource) &#123; imageTmp in\n\t\t\t\tdewarpAndCleanupImage(imageTmp) &#123; imageResult in\n\t\t\t\t\tcompletion(imageResult)\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n와우.. 보기만해도 숨이 막히죠\nasync, await를 사용하면 이런 들여쓰기의 반복을 해소할 수 있습니다. 또한 return을 사용할 수 있게 됩니다..!\nfunc processImageData() async throws -&gt; Image &#123;\n\tlet dataResource &#x3D; try await loadWebResource(&quot;dataprofile.txt&quot;)\n\tlet imageResource &#x3D; try await loadWebResource(&quot;imagedata.dat&quot;)\n\tlet imageTmp &#x3D; try await decodeImage(dataResource, imageResource)\n\tlet imageResult &#x3D; try await dewarpAndCleanupImage(imageTmp)\n\treturn imageResult\n&#125;\n\n동시성 프로그래밍의 메모리 구조코드-데이터-힙-스택의 메모리 구조 중에서 “스택” 영역을 쓰레드마다 각각 가지게 됩니다.\n동작이 할당될때마다 각자의 스택 영역에 해당 메서드를 쌓아두면서 실행합니다.\n반면 코드-데이터-힙 영역은 모든 쓰레드가 공유하는 자원입니다.\n동시성 프로그래밍과 관련된 문제점1) 경쟁 상황 &#x2F; 경쟁 조건 (Race  Condition)같은 시점에 여러개의 쓰레드에서 하나의 메모리에 동시 접근하는 문제입니다.\n메모리에 쓰고 있는 동안에는 여러 쓰레드에서 접근하지 못하도록 해당 메모리를 잠구는 기능을 Thread-Safe 처리한다 라고 합니다.\n2) 교착 상태 (Deadlocks)Thread-Safe 처리한다고 해서 모든 문제점이 사라지는 건 아닙니다.\nThread2와 Thread3이 있다고 가정하고, 각각이 person1.name = &quot;홍길동&quot;, persone2.name = &quot;임꺽정&quot;과 같이 정의하고 Thread-Safe 처리했다고 합시다.\n\n\nThread2와 Thread3이 같은 시점에 서로의 데이터 영역에 있는 값에 접근을 하면, 두 값 모두 잠겨있기 때문에 두 쓰레드 모두 작업을 종료하지 못하고 앱이 충돌하며 강제종료되게 됩니다.\n동시성 프로그래밍 문제점의 해결동시큐에서 직렬큐로 보내기아주 간단한 해결방법이 있습니다. 동시큐에서 각자 작업을 한 뒤에, 데이터 영역이나 힙 영역에 접근을 하는 부분에서만 직렬큐로 작업을 보내주어서 처리하는 방법입니다.\n직렬큐는 하나의 일만 할 수 있기 때문에, 경쟁 상황을 해소할 수 있습니다.\nvar array &#x3D; [String]()\n\nlet serialQueue &#x3D; DispatchQueue(label: &quot;serial&quot;)\n\nfor i in 1...20 &#123;\n\tDispatchQueue.global().async &#123; &#x2F;&#x2F; 여러개의 쓰레드\n\t\tprint(&quot;\\(i)&quot;)\n\t\tarray.append(&quot;\\(i)&quot;) &#x2F;&#x2F; 동시 다발적으로 배열의 메모리에 접근\n\t&#125;\n&#125;\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 5) &#123;\n\tprint(array) &#x2F;&#x2F; [&quot;2&quot;, &quot;6&quot;, &quot;4&quot;, ..., &quot;1&quot;, &quot;19&quot;] 빠지는 숫자가 생긴다\n&#125;\n\nvar array &#x3D; [String]()\n\nlet serialQueue &#x3D; DispatchQueue(label: &quot;serial&quot;)\n\nfor i in 1...20 &#123;\n\tDispatchQueue.global().async &#123; &#x2F;&#x2F; 여러개의 쓰레드\n\t\tprint(&quot;\\(i)&quot;)\n\t\tserialQueue.async &#123;\n\t\t\tarray.append(&quot;\\(i)&quot;) &#x2F;&#x2F; 한 번에 하나의 작업만 접근\n\t\t&#125;\n\t&#125;\n&#125;\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 5) &#123;\n\tprint(array) &#x2F;&#x2F; [&quot;2&quot;, &quot;6&quot;, &quot;4&quot;, ..., &quot;1&quot;, &quot;19&quot;] 모든 숫자가 제대로 들어간다\n&#125;\n\n\n\n\n\n\n\n\n\n\n왜 UI를 메인쓰레드에서만 업데이트 해야 할까?\n\nUIKit의 모든 속성을 Thread-Safe하게 설계하면, 느려짐과 같은 성능 저하가 발생할 수 있기 때문에 그렇게 설계할 수 없다. (Thread-Safe하지 않게 설계한 것은 애플의 의도이다!)\n메인 런루프(Runloop) 가 뷰의 업데이트를 관리하는 View Drawing Cycle을 통해 뷰를 동시에 업데이트 하고 있는데, 백그라운드 쓰레드가 각자의  런루프로  동작을 하면 뷰가 제멋대로 동작할 수 있다.\niOS가 그림을 그리는 렌더링 프로세스에서 여러 쓰레드가 각자의 변경사항을 GPU로 보내면, GPU는 각각의 정보를 모두 해석해야해서 느려지거나 비효율적이다.\n\n","slug":"Allen/2022-12-04-Allen42","date":"2022-12-03T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"1cd419cd63835d685fc8cde482245df5","title":"15)🍎 Swift - ReactorKit","content":"ReactorKit앱스토어에 등록된 앱들의 오픈소스를 훔쳐보면 꽤나 자주 보였던 ReactorKit입니다.\n사실 막연하게 React Native랑 관련된건가보다~ 하고 지나치곤 했었는데.. 전혀 아니였죠? 😜\n겨울 프로젝트 동안 사용해야 할 것 같아서 공부해보게 되었습니다!\n\n\n\n\n\n\n\n\n\nReactorKit\nReactorKit은 RxSwift를 제대로, 또 편하게 사용하기 위해 나온 프레임워크입니다.\n공식 github에 설명된 글을 읽어보면, ReactorKit은 리액티브하고 일방성을 갖는 Swift 어플리케이션을 지원하기 위해 만들어졌다고 합니다.\n리액티브한거야 RxSwift 기반이니 그렇다고 치고, 일방성에 주목하고 공부를 해보면 되겠네요!\n기본 컨셉\n\nReactorKit은 View와 Reactor라는 것 사이를 유저의 Action과 뷰의 State를 Observable stream을 만들어 전달한다고 합니다.\n당최 무슨 말인지 알 수가 없네요 🤯\n하나씩 차근차근 봅시다.\nViewView는 우리가 생각하는 그 View 자체입니다.\n화면을 표시하는 모든 요소들을 View라고 하고 이 View들은 유저의 입력을 action stream으로 bind하거나 각각의 UI Component들에게 view states를 bind한다고 합니다.\n그러니까 1. 유저의 인터랙션을 받거나 2. 하위 UI Component들에게 Reactor의 상태를 알려준다는 뜻인 것 같네요.\n이 View에는 비즈니스 로직이 없다고 합니다. 단지 전달자의 역할만 한다고 보면 될 것 같아요!\nView Controller가 View라는 것을 명시하기 위해서 View 프로토콜을 채택하라고 합니다.\nclass ProfileViewController: UIViewController, View &#123;\n\tvar disposeBag &#x3D; DisposeBag()\n&#125;\n\nView 프로토콜을 채택하는 것 만으로 이 뷰컨은 reactor 프로퍼티를 갖게 됩니다.\nprofileViewController.reactor &#x3D; UserViewReactor()\n\n위와 같은 작업이 자동으로 이루어진다는 의미입니다.\n이렇게 주어진 reactor라는 프로퍼티가 변경되게 되면, bind(reactor:) 메서드가 자동으로 호출됩니다. action stream과 state stream을 정의하기 위해 뷰컨 안에 이 함수를 만들어줍시다.\nfunc bind(reactor: ProfileViewReactor) &#123;\n\t&#x2F;&#x2F; action (View -&gt; Reactor)\n\trefreshButton.rx.tap.map &#123; Reactor.Action.refresh &#125;\n\t\t.bind(to: reactor.action)\n\t\t.disposed(by: self.disposeBag)\n\n\t&#x2F;&#x2F; state (Reactor -&gt; View)\n\treactor.state.map &#123; $0.isFollowing &#125;\n\t\t.bind(to: followButton.rx.isSelected)\n\t\t.disposed(by: self.disposeBag)\n&#125;\n\n스토리보드도 지원한다고 합니다!\n스토리보드를 사용하는 뷰컨은 View가 아니라 StoryboardView를 채택해야 합니다!\nclass MyViewController: UIViewController, StoryboardView &#123;\n\tfunc bind(reactor: MyReactor) &#123;\n\t\t...\n\t&#125;\n&#125;\n\nReactorReactor는 UI와는 전혀 관련없는 독립된 레이어 계층입니다.\n하지만 View의 상태를 결정해주는 아주 중대한 역할을 합니다.\n모든 View는 각자의 Reactor를 가져야하고, 모든 로직을 그 Reactor에 위임(delegate)합니다.\n그러면서도 Reactor는 View에 대한 의존성이 1도 없기 때문에 Unit Test하기에도 수월하다고 하네요!\nReactor를 사용하기 위해서는 View와 마찬가지로 Reactor 프로토콜을 채택해야 합니다.\n이 프로토콜을 채택한 객체는 Action, Mutation, State 세가지 타입을 가져야합니다.\n또한 initialState라는 프로퍼티도 가져야 한다고 합니다.\nclass ProfileViewReactor: Reactor &#123;\n\t&#x2F;&#x2F; represent user actions\n\tenum Action &#123;\n\t\tcase refreshFollowingStatus(Int)\n\t\tcase follow(Int)\n\t&#125;\n\n\t&#x2F;&#x2F; represent state changes\n\tenum Mutation &#123; \n\t\tcase setFollowing(Bool)\n\t&#125;\n\n\t&#x2F;&#x2F; represents the current view state\n\tstruct State &#123;\n\t\tvar isFollowing: Bool &#x3D; false\n\t&#125;\n\n\tlet initialState: State &#x3D; State()\n&#125;\n\n\nAction유저 인터랙션을 의미합니다.\n\nStateView의 상태를 의미합니다.\n\nMutationAction과 State를 이어주는 역할을 합니다.\n\n\nReactor는 두 단계를 거쳐 action stream을 state stream으로 변환합니다.\n\n\n바로 mutate()와 reduce()를 통해서죠.\nmutate()는 Action을 받아 Observable&lt;Mutation&gt;을 생성합니다.\n모든 비동기 작업들이나 API 호출 등이 여기에 들어가는 작업이라고 합니다.\nfunc mutate(action: Action) -&gt; Observable&lt;Mutation&gt; &#123;\n\tswitch action &#123;\n\tcase let .refreshFollowingStatus(userID): &#x2F;&#x2F; receive action\n\t\treturn UserAPI.isFollowing(userID) &#x2F;&#x2F; create API stream\n\t\t\t.map &#123; (isFollowing: Bool) -&gt; Mutation in\n\t\t\t\treturn Mutation.setFollowing(isFollowing) &#x2F;&#x2F; convert to Mutation stream\n\t\t\t&#125;\n\tcase let .follow(userID):\n\t\treturn UserAPI.follow()\n\t\t\t.map &#123; _ -&gt; Mutation in\n\t\t\t\treturn Mutation.setFollowing(true)\n\t\t\t&#125;\n\t&#125;\n&#125;\n\nreduce()는 이전의 State와 Mutation으로부터 새로운 State를 만드는 메서드입니다.\n새로운 State를 동기적으로 반환하는 기능 외의 기능은 넣지 말라고 하네요.\nfunc reduce(state: State, mutation: Mutation) -&gt; State &#123;\n\tvar state &#x3D; state &#x2F;&#x2F; create a copy of old state\n\tswitch mutation &#123;\n\tcase let .setFollowing(isFollowing):\n\t\tstate.isFollowing &#x3D; isFollowing &#x2F;&#x2F; manipulate the state, creating a new state\n\t\treturn state &#x2F;&#x2F; return new state\n\t&#125;\n&#125;\n\ntransform()은 각 stream을 다른 stream으로 변환하는 기능을 하는 메서드입니다.\nfunc transform(action: Observable&lt;Action&gt;) -&gt; Observable&lt;Action&gt;\nfunc transform(mutation: Observable&lt;Mutation&gt;) -&gt; Observable&lt;Mutation&gt;\nfunc transform(state: Observable&lt;State&gt;) -&gt; Observable&lt;State&gt;\n\n심화Global StatesRedux와 다르게 ReactorKit은 global app state를 정의하지 않는다고 합니다.\n저는 Redux가 뭔지 모르니 일단 넘어가볼게요..\n그렇기 때문에 global state를 아무걸로나 관리할 수 있다고 합니다. BehaviorSubject나 PublishSubject, 혹은 reactor를 사용해서 관리할 수 있다고 하네요.\n동시에 global state를 사용하도록 강제하지도 않는다고 합니다.\nReactorKit에는 Action ➡️ Mutation ➡️ State Flow가 존재하지 않습니다.\n그래서 global state를 Mutation으로 변환하려면 transform(mutation:을 사용해야 합니다.\nvar currentUser: BehaviorSubject&lt;User&gt; &#x2F;&#x2F; global state\n\nfunc transform(mutation: Observable&lt;Mutation&gt;) -&gt; Observable&lt;Mutation&gt; &#123;\n\treturn Observable.merge(mutation, currentUser.map(Mutation.setUser))\n&#125;\n\n위 예시는 currentUser가 바뀔 때  Mutation.setUser를 실행해달라는 코드입니다.\n*음.. 🤔 * \n*이 부분은 ReactorKit을 사용해가면서 차차 이해해봐야겠습니다… 😂  *\nView CommunicationView간의 데이터 전달이 이루어질 때 보통 delegate 패턴이나 closure를 사용하죠?\nReactorKit은 데이터 전달에 위 두 가지 방법을 사용하지 말고 reactive extension을 사용하는 것을 추천한다고 합니다.\n&#x2F;&#x2F; Read as &quot;Reactive Extension where Base is a SomeType&quot;\nextension Reactive where Base: SomeType &#123;\n\t&#x2F;&#x2F; Any specific reactive extension for SomeType\n&#125;\n\n\n\nView A를 ChatViewController, View B를 MessageInputView라고 합시다.\nView B는 View A의 subview입니다.\nView B가 View A에 ControlEvent를 보내면 View A에서 본인의 reactor인 Reactor A에 Action을 전달하는 시나리오입니다.\n원래의 방식대로 View B에서 View A로 이벤트나 데이터를 전달하려면 delegate나 closure를 사용했었죠.\n대신 ReactorKit이 추천하는 방식대로 Reactive extension을 사용해서 구현을 해보면 아래와 같습니다.\n&#x2F;&#x2F; MessageInputView.swift\nextension Reactive where Base: MessageInputView &#123;\n\tvar sendButtonTap: ControlEvent&lt;String&gt; &#123;\n\t\tlet source &#x3D; base.sendButton.rx.tap.withLatestFrom(...)\n\t\treturn ControlEvent(events: source)\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; ChatViewController.swift\nmessageInputView.rx.sendButtonTap\n\t.map(Reactor.Action.send)\n\t.bind(to: reactor.action)\n","slug":"Swift/2022-12-04-Swift15","date":"2022-12-03T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,ReactorKit","author_index":"nomatterjun"},{"id":"1ca7fb6a95b8a418f4c9c554aca0e0f9","title":"40)🧰 Swift - 네트워크 통신.01","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n네트워크 통신네트워킹TCP&#x2F;IP\n인터넷에 관련된 다양한 프로토콜 집합의 총칭\n프로토콜: 통신을 하기 위해 마련해둔 약속\nHTTP, IP, FTP, UDP, TCP, IEEE 802.3\n\n\n\nHTTP\nHyper Text Transfer Protocol\n하이퍼 문서를 전송하는 것에서 시작하여\n현재는 이미지, 영상, 음성, 파일, json 등 모든 형태의 데이터 전송\n\nTCP&#x2F;IP의 계층클라이언트와 서버 모두 크게 4가지 계층을 가지고 통신을 합니다. \n이 통신이라는 것이 현실에서의 우편과 상당히 유사한 개념이기 때문에 우편을 가지고 쉽게 적어보려 합니다.\n\n\n\n4계층\n명칭\n\n우편\n설명\n\n\n\nApp\n애플리케이션: HTTP\n리퀘스트\n편지지 작성\n데이터를 어떻게 주고 받을지에 대한 약속 (요청&#x2F;응답)\n\n\nOS\n\n트랜스포트: TCP\n조각 &#x2F; PORT\n편지지 포장\n\n\n^^\n\n인터넷: IP\n\n발송&#x2F;수신자 주소 첨부\n\n\nLAN\n링크: 네트워크\nMAC주소 추가\n편지 봉투 포장\n\n\n\n서버에 데이터를 어떤 형식으로 요청하는 지는 알아두어야 하기 때문에 HTTP는 필수적으로 알고 있어야 합니다.\nHTTPRequest &amp; ResponseRequest\n요청\n클라이언트\n\nPOST &#x2F;form&#x2F;entry HTTP&#x2F;1.1\nHost: www.naver.com\nConnection: Keep-alive\nContent-Type: application&#x2F;x-www-form-urlencoded\nContent-Length: 16\n\nname&#x3D;gildong&amp;age&#x3D;20\n\n\nPOST /form/entry HTTP/1.1: 메소드 + 요청대상(경로) + HTTP버전\nHost ~ Content-Length: 부가 정보 (메타데이터)\nname=gildong&amp;age=20: 실제 전송할 데이터 (body)\n\nResponse\n응답\n서버\n\nHTTP&#x2F;1.1 200 OK\nDate: Tue, 10 Jul 2020 06:40:14 GMT\nContent-Length: 352\nContent-Type: text&#x2F;html\n\n&lt;html&gt;\n...\n&lt;&#x2F;html&gt;\n\n\nHTTP/1.1 200 OK: HTTP버전 + 상태코드 + 문구\nDate ~ Content-Type: 부가 정보 (메타데이터)\n&lt;html&gt;&lt;/html&gt;: 실제 전송할 데이터 (body)\n\n요청 메소드의 종류\n\n\n메소드\n설명\n제공 HTTP 버전\n\n\n\n⭐ GET\n리소스 휙득 (조회)\n1.0 1.1\n\n\n⭐ POST\n엔티티 (등록)\n1.0 1.1\n\n\n⭐ PUT\n파일 전송 (데이터 대체&#x2F;없다면 생성)\n1.0 1.1\n\n\n⭐ PATCH\n리소스 부분 변경 (부분 변경)\n1.1\n\n\nHEAD\n메세지 헤더 취득\n1.0 1.1\n\n\n⭐ DELETE\n파일 삭제 (삭제)\n1.0 1.1\n\n\nOPTIONS\n서포트 메소드 문의\n1.1\n\n\nTRACE\n경로 조사\n1.1\n\n\nCONNECT\n프록시 터널링 요구\n1.1\n\n\nLINK\n리소스 간 링크 관계 확립\n1.0\n\n\nUNLINK\n링크 관계 삭제\n1.0\n\n\n응답 메시지의 종류\n\n\n상태 코드\n클래스\n설명\n\n\n\n1xx\nInformational\n리퀘스트를 받아들여 처리중\n\n\n⭐ 2xx\nSuccess\n리퀘스트를 정상적으로 처리\n\n\n3xx\nRedirection\n리퀘스트 완료를 위한 추가 동작 필요\n\n\n⭐ 4xx\nClient Error\n서버에서 리퀘스트 이해 불가능 (클라이언트 에러)\n\n\n⭐ 5xx\nServer Error\n서버가 리퀘스트 처리 실패 (서버 에러)\n\n\n2xx (Success)\n200 OK\n201 Created\n202 Accepted: 요청이 접수되었으나 처리가 완료되지는 않음\n204 No Content: 요청이 성공적으로 수행 되었으나, 응답으로 보낼 메시지가 없음\n\n4xx (Client Error)\n400 Bad Request: 요청 구문&#x2F;파라미터, 메시지 등의 오류\n401 Unauthorized: 인증이 되지 않았음을 알려주는 오류\n403 Forbidden: 요청이 접수되었으나 처리가 완료되지 않음 (ex: 어드민 권한)\n404 Not Found: 요청 리소스가 서버에 없음\n\n5xx (Server Error)\n500 Internal Server Error: 서버 내부 문제로 오류\n503 Service Unavailable: 서비스 이용 불가 (과부하&#x2F;점검)\n\nAPI\nApplication Programming Interface\n\nquery\nhttps://www.google.com:443/search?q=swift&amp;hl=ko\n?q=swift&amp;hl-ko 부분\nkey&#x3D;value의 형태\n?로 시작, &amp;로 추가 기능\n요청 body에 넣어(POST PUT PATCH) 보내거나 주소에 붙여(GET) 요청한다.\n\nXML &#x2F; JSON&lt;users>\n\t&lt;user>\n\t\t&lt;name> John &lt;/name>\n\t\t&lt;age> 22 &lt;/age>\n\t&lt;/user>\n\t&lt;user>\n\t\t&lt;name> Mary &lt;/name>\n\t\t&lt;age> 21 &lt;/age>\n\t&lt;/user>\n&lt;/user>\n\n[\n\t&#123;\n\t\t\"name\": \"John\",\n\t\t\"age\": 22\n\t&#125;,\n\t&#123;\n\t\t\"name\": \"Mary\",\n\t\t\"age\": 20\n\t&#125;\n]\n\n최근에는 xml을 사용하는 경우는 거의 없고 json 파일의 형태로 데이터를 주고 받습니다.\nREST APIAPI라는 것은 단순하게 요청 방식에 대한 약속을 정해둔 것입니다.\n하지만 https://(ADDRESS)/1이나 https://(ADDRESS)/2와 같이 요청을 넣어버리면 개발자들 간의 소통이 어려워지는 문제점이 있습니다.\nREST API는 이런 부분을 해소하고자 제안된 방안입니다.\nRESTFUL API누가 보더라도 어떤 요청인지 이해가 되도록!\n\nhttps://(ADDRESS)/movielists\nhttps://(ADDRESS)/movielist?open=tomorrow\nhttps://(ADDRESS)/movie-reservation\n\n","slug":"Allen/2022-12-03-Allen40","date":"2022-12-02T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"6c682199b51a2e4376ed412751ae3d24","title":"41)🧰 Swift - 네트워크 통신.02","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\niOS에서의 네트워크 통신let movieURL &#x3D; &quot;https:&#x2F;&#x2F;kobis.or.kr&#x2F;kobisopenapi&#x2F;webservice&#x2F;rest&#x2F;boxoffice&#x2F;searchDailyBoxOfficeList.json&quot;\nlet structURL &#x3D; URL(string: movieURL)!\nURLSession.shared.dataTask(with: structURL) &#123; data, response, error in\n\tif error !&#x3D; nil &#123; &#x2F;&#x2F; 에러 체크\n\t\tprint(error?.localizedDescription)\n\t\treturn\n\t&#125;\n\tguard let safeData &#x3D; data else &#123;\n\t\treturn\n\t&#125;\n\tdump(parseJSON(safeData))\n&#125;.resume()\n\niOS의 네트워킹1) iOS 데이터 요청의 4단계웹 브라우저로 하는 통신에 대입해봅시다.\n\nURL 구조체\nURLSession\n웹 브라우저 실행\n\n\ndataTask\nurl 입력\n\n\n시작 (resume)\nEnter\n\n\n\n2) Data &#x2F; JSON 타입의 응답[\n\t&#123;\n\t\t\"name\": \"John\",\n\t\t\"age\": 22\n\t&#125;,\n\t&#123;\n\t\t\"name\": \"Mary\",\n\t\t\"age\": 20\n\t&#125;\n]\n\n3) 실제 사용 타입으로 변환Data나 json 타입의 데이터를 그대로 사용할 수는 없으니 Swift에서 평소에 사용하던 struct나 class 타입으로 변환하는 과정이 필요합니다.\n이 과정을 JSON Parsing이라고 부르고, Swift는 이 파싱을 위한 Codable 프로토콜을 지원합니다.\nstruct MovieData: Codable &#123;\n\tlet boxOfficeResult: BoxOfficeResult\n&#125;\n\nstruct BoxOfficeResult: Codable &#123;\n\tlet dailyBoxOfficeList: [DailyBoxOfficeList]\n&#125;\n\nstruct DailyBoxOfficeList: Codable &#123;\n\tlet rank: String\n\tlet movieNm: String\n\tlet audiCnt: String\n\tlet audiAcc: String\n\tlet openDt: String\n&#125;\n\nfunc pareJSON(_ movieData: Data) -&gt; [DailyBoxOfficeList]? &#123;\n\tdo &#123;\n\t\tlet decoder &#x3D; JSONDecoder()\n\t\tlet decodedData &#x3D; try decoder.decode(MovieData.self, from: movieData)\n\t\treturn decodedData.boxOfficeResult.dailyBoxOfficeList\n\t&#125; catch &#123;\n\t\treturn nil\n\t&#125;\n&#125;\n\n여기서 핵심은\ntry decoder.decode(MovieData.self, from: movieData)\n이 부분입니다.\n만들어둔 MovieData라는 구조체의 형식에 맞게 movieData를 JSONDecoder를 사용해서 변환하겠다는 의미입니다.\nCodable을 붙여둔 구조체의 형식이 데이터와 맞다면, 자동으로 json 데이터를 변환하여 함수의 리턴 타입인 [DailyBoxOfficeList]?의 형태로 받아올 수 있습니다.\nCodableCodable은 Encodable과 Decodable을 통합한 프로토콜입니다.\n\nEncodable: 데이터 ➡️ 클래스, 구조체\nDecodable: 클래스, 구조체 ➡️ 데이터\n\n","slug":"Allen/2022-12-03-Allen41","date":"2022-12-02T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"ce2e6e038e6cdd39ed0992f2d4217d3d","title":"38)🧰 Swift - 에러 처리","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n에러에러의 종류\n컴파일 에러\n코드가 잘못되었음을 알려주는 문법적 오류\n\n\n런타임 에러\n여러가지 이유로 앱이 실행되는 동안 발생하는 오류\n미리 발생 가능한 에러에 대응할 필요가 있다\n\n\n\n에러 처리의 3단계\nthrows와 throw를 사용\nenum 타입에 Error 프로토콜을 채택하여 커스텀 에러 사용\n\nenum SomeError: Error &#123;\n\tcase aError, bError, cError\n&#125;\n\nfunc doSomething(num: Int) throws -&gt; Bool &#123;\n\tif num &gt;&#x3D; 7 &#123;\n\t\treturn true\n\t&#125; else &#123;\n\t\tif num &lt; 0 &#123;\n\t\t\tthrow SomeError.aError\n\t\t&#125;\n\t\treturn false\n\t&#125;\n&#125;\n\ndoSomething(num: 7) &#x2F;&#x2F; true\n\n1) 에러 정의enum 타입으로 사용할 에러를 정의해야 합니다. \n이 때 Error 프로토콜을 채용해야 Swift에서 이 열거형 타입이 에러인지를 알 수 있기 때문에 꼭 채택해야 합니다!\nenum HeightError: Error &#123;\n\tcase maxHeight\n\tcase minHeight\n&#125;\n\n2) 에러가 발생할 수 있는 함수에 대한 정의throws 키워드를 파라미터와 반환 타입 중간에 넣어주어 에러가 발생할 수 있는 함수라는 것을 명시해주어야 합니다.\nfunc checkingHeight(height: Int) throws -&gt; Bool &#123;\n\tif height &gt; 190 &#123;\n\t\tthrow HeightError.maxHeight\n\t&#125; else if height &lt; 130 &#123;\n\t\tthrow HeightError.minHeight\n\t&#125; else &#123;\n\t\tif height &gt;&#x3D; 160 &#123;\n\t\t\treturn true\n\t\t&#125; else &#123;\n\t\t\treturn false\n\t\t&#125;\n\t&#125;\n&#125;\n\n3) 에러가 발생할 수 있는 함수의 처리(실행)try, do-catch문을 사용하여 일반적인 함수와는 조금 다르게 실행해야 합니다.\n에러가 발생할 수 있다고 throws 키워드를 명시해둔 함수는 실행할 때 try 키워드를 붙여주어야 합니다.\n또한 이 try로 실행되는 함수들은 do-catch문 안에서만 쓰일 수 있습니다.\ndo 블럭 안에는 try 함수가 정상적으로 실행됐을 경우에 실행되는 함수들이 들어있습니다.\n반대로 catch 블럭 안에는 try로 실행된 함수에서 에러가 발생했을 때 실행되는 함수들이 들어있습니다.\ndo &#123; &#x2F;&#x2F; 정상 처리\n\tlet result &#x3D; try checkingHeight(height: 160)\n\tswitch result &#123;\n\tcase true:\n\t\tprint(&quot;참&quot;)\n\tcase false:\n\t\tprint(&quot;거짓&quot;)\n\t&#125;\n&#125; catch &#123; &#x2F;&#x2F; 에러 처리\n\tprint(&quot;올바르지 않은 몸무게&quot;)\n&#125;\n\n에러 발생 가능한 함수의 형태일반적인 형태의 함수는 () -&gt; ()의 형태였습니다.\nthrows는 이 사이에 간단하게 쇽 넣어주는 것으로 사용할 수 있습니다.\n() throws -&gt; () ⬅️ 이렇게요!\n에러 처리 방법에러를 발생시키는 방법을 알아보았습니다.\n그러면 이 에러가 발생 됐을 때 처리할 수 있는 방법들을 알아볼까요?\n1) 정식 처리 방법위에서 사용했던 예시와 동일합니다.\ndo &#123;\n\tlet result &#x3D; try checkingHeight(height: 160)\n&#125; catch &#123;\n\tprint(&quot;Error!&quot;)\n&#125;\n\n2) Optional try 방법에러 처리의 경우에도 Optional을 사용하면 아주 간단하게 처리할 수 있습니다.\ntry 뒤에 ?를 붙여서 try? 처럼 사용하면 Optional try가 됩니다.\n이 Optional try는 정상적인 경우에는 정상 타입으로 반환하지만, 에러가 발생하면 nil 값을 반환해줍니다.\n나오는 값은 당연히 Optional이기 때문에 Optional Binding을 해주고 사용할 수 있습니다!\nlet isChecked &#x3D; try? checkingHeight(height: 200)\n\n3) Forced try 방법Optional 방법이 있었으니 Forced 방법도 있겠죠?\nOptional하지 않은 타입으로 반환되지만, 에러가 발생할 경우 앱이 강제로 꺼질 수 있다는 위험이 있습니다!\nlet isChecked2 &#x3D; try! checkingHeight(height: 120)\n\ncatch 블럭 처리법그런데 enum 타입으로 에러들을 정의할 때 한가지 에러만 만들었던 것이 아니였죠?\nenum SomeError: Error &#123;\n\tcase aError, bError, cError\n&#125;\n\n이렇게 여러가지 에러 타입이 있는데, 이 많은 종류의 에러들을 catch 블럭 하나에서 처리하려면 어떻게 해야할까요?\nswitch문이나 if-else 문을 사용해서 분기 처리를 할 수도 있지만, 단순히 catch를 여러 가지로 붙여 쓰는 것으로 다양한 에러에 각각 처리문을 넣어줄 수 있습니다.\ndo &#123;\n\tlet isChecked &#x3D; try checkingHeight(height: 100)\n&#125; catch &#123;\n\tif let error &#x3D; error as? HeightError &#123;\n\t\tswitch error &#123;\n\t\tcase .maxHeight:\n\t\t\tprint(&quot;키가 커서 놀이기구를 탈 수 없어요.&quot;)\n\t\tcase .minHeight:\n\t\t\tprint(&quot;키가 작아서 놀이기구를 탈 수 없어요.&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\ndo &#123;\n\tlet isChecked &#x3D; try checkingHeight(height: 100)\n&#125; catch HeightError.maxHeight &#123;\n\tprint(&quot;키가 커서 놀이기구를 탈 수 없어요.&quot;)\n&#125; catch HeightError.minHeight &#123;\n\tprint(&quot;키가 작아서 놀이기구를 탈 수 없어요.&quot;)\n&#125; catch &#123; &#x2F;&#x2F; default\n\tprint(&quot;알 수 없는 에러&quot;)\n&#125;\n\n에러를 던지는 함수를 처리하는 함수에러를 발생시키는 함수와 처리하는 함수를 꼭 같은 곳에서 정의해줘야 한다면, 앱이 커질수록 불편함이 늘어날 수 있습니다.\n그래서 Swift는 에러를 처리하는 함수를 정의하는 여러가지 방법들을 만들어두었습니다.\nthrowing 함수로 에러 다시 던지기함수 내에서 에러를 직접 처리하기 곤란한 경우, 해당 에러를 다른 함수로 던지고 그 다른 함수가 다시 에러를 던지도록 할 수 있습니다.\nfunc handleError() throws &#123;\n\tdo &#123; &#x2F;&#x2F; do문까지 생략 가능\n\t\ttry throwingFunc()\n\t&#125;\n&#125; &#x2F;&#x2F; no catch\n\ndo &#123;\n\ttry handleError()\n&#125; catch &#123;\n\tprint(error)\n&#125;\n\nrethrowing 함수로 에러 다시 던지기 (rethrow)에러를 던지는 throwing 함수를 파라미터로 받는 경우, 해당 함수의 에러를 다시 던지는 것 또한 가능합니다.\nfunc someFunction(callback: () throws -&gt; Void) rethrows &#123;\n\t&#x2F;&#x2F; do문 생략\n\ttry callback()\n&#125;\n\nfunc someFunction2(callback: () throws -&gt; Void) rethrows &#123;\n\tenum ChangedError: Error &#123;\n\t\tcase cError\n\t&#125;\n\n\tdo &#123;\n\t\ttry callback()\n\t&#125; catch &#123;\n\t\tthrow ChangedError.cError\n\t&#125;\n&#125;\n\n","slug":"Allen/2022-12-02-Allen38","date":"2022-12-01T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"32fd8798e5c3d3654084b9ba0acefdda","title":"39)🧰 Swift - Defer","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nDefer우리가 할 일을 미루는 것처럼 코드 실행도 미룰 수 있다면 어떨까요?\nSwift는 defer 키워드를 제공해서 블럭 안에 있는 구문들을 해당 스코프의 마지막까지 미뤄줄 수 있습니다.\nfunc deferStatement() &#123;\n\tdefer &#123;\n\t\tprint(&quot;나중에 실행하기&quot;)\n\t&#125;\n\tprint(&quot;먼저 실행하기&quot;)\n&#125;\n&#x2F;&#x2F; 먼저 실행하기\n&#x2F;&#x2F; 나중에 실행하기\n\n 위 예시에서 defer 키워드로 묶어둔 블럭이 아래에 있는 print문보다 늦게 실행된 것을 알 수 있습니다.\ndefer문도 호출되어 실행된다그런데 주의할 점이 하나 있습니다.\ndefer도 하나의 함수이기 때문에 일단 호출이 되어야 제대로 실행된다는 것입니다.\nfunc deferStatement2() &#123;\n\tif true &#123;\n\t\tprint(&quot;먼저 실행하기&quot;)\n\t\treturn\n\t&#125;\n\tdefer &#123;\n\t\tprint(&quot;나중에 실행하기&quot;)\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 먼저 실행하기\n\n위 예시의 경우, 무조건 진입되는 if 분기에 있는 return 에 의해 아래에 있는 defer문은 한 번도 실행되지 못하였습니다.\n결과적으로 “나중에 실행하기”는 출력되지 못하였네요.\ndefer문이 여러개 있다면?defer문이 꼭 하나만 오리란 법은 없겠죠.\n혹시라도 여러개의 defer문이 같은 스코프 안에 있다면 어떻게 동작할까요?\nfunc deferStatement3() &#123;\n\tdefer &#123;\n\t\tprint(1)\n\t&#125;\n\tdefer &#123;\n\t\tprint(2)\n\t&#125;\n\tdefer &#123;\n\t\tprint(3)\n\t&#125;\n&#125;\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 1\n\n조금 극단적인 예시지만, 실행의 순서를 알아보기엔 딱 좋은 예시입니다.\ndefer문은 등록한 역순으로 실행됩니다.\n가장 먼저 나온 defer문이 가장 뒤에 배치되고, 그 이후에 나오는 defer문들이 순서대로 그 앞에 배치됩니다.\n스택과 같이 동작한다고 보면 될 것 같습니다!\n그런데 사실, defer문을 하나의 스코프에서 여러 번 사용하는 것은 추천되지 않습니다. \n하나일 땐 도움이 될 수 있지만 여러개의 defer문이 배치되면 가시성도 안좋기 때문이죠.. 😂\n","slug":"Allen/2022-12-02-Allen39","date":"2022-12-01T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"01b2dffc69fa4db38318456db0dbef20","title":"14)🍎 Swift - Rx 없이 Reactive Binding 해보기","content":"Rx 없이 View ➡️ ViewModel Binding하기Rx라는 놈 공부할 땐 어려웠는데..한 번 써보니까 없이 기능 구현을 할 때 갈증이 계속해서 일어나는 현상을 겪고 있습니다.\n하지만 라이브러리에 의존하는 것은 좋지 않으니까 Rx 없이 데이터 바인딩을 하는 방법을 공부해보았습니다.\n\n\n\n\n\n\n\n\n\n코드의 경우 검색해본 거의 모든 게시물에서 동일한 형태로 사용되고 있었습니다. 내부적인 동작 과정도 모른채로 가져다쓰긴 싫어서 공부 겸 작성한 게시물입니다!\n체크 리스트 앱을 만든다고 가정합시다.할 일을 완료할 때마다 그 날 일의 완료율 Label을 계속해서 바꿔주고 싶어요.딱 Rx를 사용하면 편리한 상황이지만 다른 기능을 찾아봅시다.\n값이 바뀔 때마다 수행하는 동작..정확히 해당 기능을 하는 친구가 있었던 것 같아요.\n바로 didSet입니다.\ndidSetvar donePercentage: Int &#x3D; 0 &#123;\n\tdidSet &#123;\n\t\tprint(oldValue)\n\t&#125;\n&#125;\n\ndonePercentage의 값이 바뀔 때마다 didSet에 있는 print 함수가 자동으로 호출됩니다.이 didSet을 키워드로 잡고 시작해보겠습니다.\nObservableRx에서 우리는\nviewModel.todos\n\t.subscribe(onNext: &#123; todo in\n\t\tprint(todo.count)\n\t&#125;)\n\t.disposed(by: self.disposeBag)\n\n이런 식으로 Observable한 데이터를 만들어주고 subscribe하여 필요한 동작들을 처리해주었습니다.\n먼저 필요한 Observable 타입을 차근차근 만들어봅시다.\nvalue: Tclass Observable&lt;T&gt; &#123;\n\tvar value: T\n\n\tinit(_ value: T) &#123;\n\t\tself.value &#x3D; value\n\t&#125;\n&#125;\n\nObservable은 모든 타입에 대해서 관찰이 가능해야하기 때문에 Generic 타입을 T라는 이름으로 사용해주었습니다.그리고 생성자를 통해 알맹이인 value 값을 넣어주었죠.\n이 value 값이 바뀔 때마다 어떤 함수를 실행해주어야 하기 때문에 didSet을 사용해줍시다.\nvar value: T &#123;\n\tdidSet &#123;\n\t\t&#x2F;&#x2F; 실행할 함수\n\t&#125;\n&#125;\n\nlistener (클로저)다시 Rx의 경우를 봐볼까요?\n저 didSet 안에 들어가게 될 함수를 찾아봅시다.\n.subscribe(onNext: &#123; todo in\n\tprint(todo)\n&#125;)\n\nsubscribe라는 함수를 호출하고 클로저의 형태로 함수를 전달받아 실행하는 것 같네요.\n그렇다면 안에 들어갈 함수를 담을 클로저 변수를 정의해줍시다.\nvar listener: ((T) -&gt; Void)?\n\nreturn 받는 값은 없으니 Void로 주고 value 값을 받아 처리해주어야 하니 input 파라미터로 T(제너릭 타입)을 받아줍시다.\n이제 이 listener 클로저를 Observable 코드에 적용시켜줍시다.\nclass Observable&lt;T&gt; &#123;\n\tvar value: T &#123;\n\t\tdidSet &#123;\n\t\t\tself.listener?(value)\n\t\t&#125;\n\t&#125;\n\n\tvar listener: ((T) -&gt; Void)?\n\n\tinit(_ value: T) &#123;\n\t\tself.value &#x3D; value\n\t&#125;\n&#125;\n\nsubscribeView쪽에서 subscribe 안에서 클로저로 받는 함수를 listener에 담고 있다가 didSet이 호출되면 실행되야합니다.\n따라서 파라미터로 @escaping 클로저를 받아주고 클래스 내부의 listener에 담아줍시다.\nfunc subscribe(listener: @escaping (T) -&gt; Void) &#123;\n\tlistener(value)\n\tself.listener &#x3D; listener\n&#125;\n\n이 때 listener(value)와 같이 한 번 실행해줬기 때문에, subscribe와 동시에 무조건 한 번은 실행됩니다.\nbinding과 동시에 실행을 하지 않고 싶은 경우에는 빼주어도 아무 문제 없습니다.\n종합이제 코드들을 합쳐봅시다!\nclass Observable&lt;T&gt; &#123;\n\tvar value: T &#123;\n\t\tdidSet &#123;\n\t\t\tself.listener?(value)\n\t\t&#125;\n\t&#125;\n\n\tvar listener: ((T) -&gt; Void)?\n\n\tinit(_ value: T) &#123;\n\t\tself.value &#x3D; value\n\t&#125;\n\n\tfunc subscribe(listener: @escaping (T) -&gt; Void) &#123;\n\t\tlistener(value)\n\t\tself.listener &#x3D; listener\n\t&#125;\n&#125;\n\n사용class HomeViewModel &#123;\n\tvar todoData: Observable&lt;[ToDo]&gt; &#x3D; Observable([])\n&#125;\n\nclass HomeViewController: UIViewController &#123;\n\tprivate var viewModel &#x3D; HomeViewModel()\n\n\tlazy var progressLabel &#x3D; UILabel().then &#123; ... &#125;\n\n\toverride func viewDidLoad() &#123;\n\t\tself.viewDidLoad()\n\t\tself.viewModel.todoData.subscribe &#123; todo in\n\t\t\tDispatchQueue.main.async &#123;\n\t\t\t\tself.progressLabel.text &#x3D; todo.count\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tDispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123;\n\t\t\tself.viewModel.todoData.value &#x3D; [\n\t\t\t\tToDo(title: &quot;Test&quot;, state: .completed)\n\t\t\t]\n\t\t&#125;\n\t&#125;\n&#125;\n","slug":"Swift/2022-11-20-Swift14","date":"2022-11-19T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"c821c58f061b1a40d9641a5392a7fb36","title":"37)🧰 Swift - 메모리 관리 (ARC)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nARC (Automatic Reference Counting)스위프트의 메모리 관리 모델값 형식과 참조 형식메모리 관리에 대해 공부하기 전에 메모리 관리가 어떤 때에 필요한 지 먼저 알아보겠습니다.\n값 형식\n필요시에 메모리의 스택 영역에 값을 저장합니다.\n값이 들어있는 스택 영역의 스코프가 종료되면 메모리에서 자동으로 해제됩니다.\nSwift의 기본 타입(Int, String, …)들, 튜플, 구조체, 열거형, 컬렉션 등\n\n참조 형식\n필요시에 메모리의 힙 영역에 값을 저장하고, 스택 영역에 주소를 저장합니다.\nRC(Reference Counting) 을 통해 메모리를 관리합니다. ➡️ ARC\n클래스, 클로저\n\n값 형식과 참조 형식의 차이점을 보면 알 수 있듯이, 참조 형식의 데이터들은 힙 영역에 저장되기 때문에 별도의 Reference Counting 모델이 필요합니다. \n\n\n\n\n\n\n\n\n\n힙 영역 데이터에는 왜 별도의 관리 모델이 필요한건가요?\n메모리의 구조힙 영역과 스택 영역의 차이점을 기억해내기 위해 메모리의 구조를 한 번 복습해볼까요?\n\n코드: 명령어 &#x2F; 프로그램\n데이터: 전역 변수 &#x2F; 타입 변수\n앱이 실행되는 공간 변하지 않는 공유하기 위한 데이터\n\n\n힙: 동적 할당\n크기가 크고, 관리가 필요한 데이터\n\n\n스택: 함수 실행을 위한 임시 공간\n크기가 작고 단기간 사용하기 위한 데이터\n\n\n\n스택 영역의 데이터들은 빠르게 사용되고 빠르게 해제되기 때문에 메모리 관리가 별도로 필요하지 않습니다. 데이터 영역의 데이터들은 프로그램이 실행되는 동안 유지되는 불변의 데이터이기 때문에 마찬가지로 해제가 필요하지 않습니다.\n하지만 힙 영역의 데이터들은 스택 영역에 비해 비교적 오랜 기간 머물면서, 동적 할당되기 때문에 빈 공간에 임의로 영역을 잡아 저장됩니다.\n문제는 힙 영역의 데이터는 관리를 해주지 않으면 계속해서 메모리를 잡아먹으면서 상주한다는 점입니다. 이를 메모리 누수(Memory Leak) 라고 부릅니다.\n이 문제를 해결하기 위해 Swift에서는 ARC라는 메모리 관리 모델이 적용되었습니다.\nJava와 Obj-C, Swift의 메모리 관리 모델\n\n\nJava\nObj-C\nSwift\n\n\n\nGarbage Collector)\nMRC + ARC\nARC\n\n\nJava의 Garbage Collector메모리 누수가 힙 영역의 메모리 할당 문제라면, 이 문제는 Swift 뿐만 아니라 다른 언어에서도 발생하는 문제일 것입니다.\n객체기반 언어의 어머니라고 불리는 Java에서는 Garbage Collector라는 모델이 적용되었습니다.\nGarbage Collector 모델은 프로그램 실행중(런타임)에 힙 영역에 할당된 모든 데이터들을 스캔합니다. 그 후에 해제되어도 되겠다고 판단되는 데이터들을 알아서 메모리에서 해제해줍니다. \n따라서 이 모델의 장점은 개발자가 따로 신경 써주지 않아도 알아서 메모리 누수 관리가 된다는 점입니다. 반대로 단점은 힙 영역을 모두 스캔하는 과정이 필요로 하기 때문에 비교적 느리다는 점이 있습니다.\nSwift의 Reference CountingReference Counting 모델은 할당된 데이터가 참조되고 있는 곳의 수를 세면서 참조 카운터가 0이 되는 순간 메모리에서 해제되는 모델입니다.\n이 RC 모델은 카운팅을 개발자가 수동으로 해줘야하는 MRC(Manual RC) 모델과 컴파일러가 자동으로 수행해주는 ARC(Automatic RC) 모델로 나뉩니다. \nSwift 이전에 쓰였던 Obj-C 언어에서는 MRC와 ARC 모델을 섞어서 사용하였지만, Swift 언어로 넘어온 후부터는 ARC 모델만을 사용하게 되었습니다.\n주의ARC 모델은 Java의 Garbage Collector 모델과는 다르게 메모리 관리 자체를 자동으로 해주지는 않습니다. \nARC 모델의 Automatic은 Reference Counting을 자동으로 해준다는 점에 초점이 맞춰져 있습니다. 따라서 이 카운팅되는 법칙을 개발자가 잘 알지 못하고 사용한다면, 원하지 않을 때 카운터가 증가될수도, 감소될수도 있습니다.\nMRC (Manual Reference Counting)\n위 예시는 애플이 wwdc2016에서 발표한 내용입니다.\nXCode는 실제로 개발자가 작성한 코드(왼쪽)에 ARC를 위한 코드들을 삽입(오른쪽)하여 컴파일합니다. refCount라는 카운터 변수를 클래스에 넣어주고, retain과 release를 통해 카운터를 증가시키거나 감소시킨다는 것을 볼 수 있습니다.\n\nretain: 메모리 할당 (RC + 1)\nrelease: 메모리 해제 (RC - 1)\n\nMRC 모델을 사용할 때는 이와 같은 코드들을 개발자가 직접 넣어주어야 했습니다. ARC 모델을 사용하는 지금은 XCode가 컴파일할 때 자동으로 추가해줍니다!\nclass Dog &#123;\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nvar choco: Dog? &#x3D; Dog(name: &quot;초코&quot;, weight: 15.0) &#x2F;&#x2F; retain(choco) RC 1\nvar bori: Dog? &#x3D; Dog(name: &quot;보리&quot;, weight: 10.0) &#x2F;&#x2F; retain(choco) RC 1\n\nchoco &#x3D; nil &#x2F;&#x2F; &quot;초코 메모리 해제&quot; RC 0\n&#x2F;&#x2F; release(choco)\nbori &#x3D; nil &#x2F;&#x2F; &quot;보리 메모리 해제&quot; RC 0\n&#x2F;&#x2F; release(bori)\n\n강한 참조 사이클과 메모리 누수강한 참조 사이클은 객체가 서로를 참조하는 상황에서 일어납니다. \n객체가 서로를 참조하게 되면 서로의 Reference Count를 1씩 증가시킵니다.\n이런 상황이 발생하면 두 객체에 nil을 할당한다고 해도 서로의 RC를 계속해서 유지하고 있기 때문에 해제되지 못하고 상주하게 되는 문제가 발생합니다.\n이를 메모리 누수(Memory Leak) 라고 부릅니다.\nclass Dog &#123;\n\tvar name: String\n\tvar owner: Person?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nclass Person &#123;\n\tvar name: String\n\tvar pet: Dog?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nvar bori: Dog? &#x3D; Dog(name: &quot;보리&quot;)\nvar gildong: Person? &#x3D; Person(name: &quot;홍길동&quot;)\n\nbori?.owner &#x3D; gildong\ngildong?.pet &#x3D; bori\n&#x2F;&#x2F; 강한 참조 사이클 발생\n\n&#x2F;&#x2F; bori?.owner &#x3D; nil\n&#x2F;&#x2F; gildong?.pet &#x3D; nil\n&#x2F;&#x2F; 강한 참조 사이클을 해소하려면 서로의 참조를 끊어주어야 한다.\n\nbori &#x3D; nil\ngildong &#x3D; nil\n&#x2F;&#x2F; nil로 해제해주었지만, 강한 참조 사이클로 인해 메모리에서 해제되지 못함\n&#x2F;&#x2F; deinit에 들어있는 print문이 실행되지 않음\n\n메모리 누수의 해결 방안\nRC를 고려하며 참조 해제 순서를 주의하며 코드 작성\n신경쓸 것이 많고 실수할 가능성이 큼\n\n\n약한 참조(Weak Reference) 사용\n비소유 참조(Unowned Reference) 사용\n\n위 세 가지 방법 중에서 첫 번째 방법은 너무나 번거롭고 실수가 일어나기 쉬운 방법입니다. 그다지 좋은 방법이 아니라는 뜻이죠.\n그래서 그 대안으로 두 번째와 세 번째 방법이 있습니다.\n이 두 방법은 서로의 RC를 증가시키지 않으면서 참조한다는 공통적인 특징이 있습니다.\n약한 참조 (Weak Reference)class Dog &#123;\n\tvar name: String\n\tweak var owner: Person?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nclass Person &#123;\n\tvar name: String\n\tweak var pet: Dog?\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nvar bori: Dog? &#x3D; Dog(name: &quot;보리&quot;)\nvar gildong: Person? &#x3D; Person(name: &quot;홍길동&quot;)\n\nbori?.owner &#x3D; gildong\ngildong?.pet &#x3D; bori\n\nbori &#x3D; nil &#x2F;&#x2F; 보리 메모리 해제\ngildong &#x3D; nil &#x2F;&#x2F; 홍길동 메모리 해제\n\n위의 예시와 같은 예시이지만 서로의 참조 부분 앞에 weak 키워드를 넣어주어서 약한 참조를 하도록 해주었습니다.\n이 경우에는 서로의 RC를 증가시키지 않기 때문에, 각각을 nil로 만들어주면 RC가 0이 되어 메모리에서 해제됩니다.\n한 가지 알아두어야 할 점이 있습니다. 약한 참조의 경우에는 참조하고 있던 인스턴스가 사라지면, 해당 속성을  nil 값으로 자동으로 초기화합니다.\ngildong &#x3D; nil\nprint(bori?.owner) &#x2F;&#x2F; nil\n\n위의 예시에서 gildong에 nil 값을 주면, 이 gildong을 참조하고 있던 bori의 owner이라는 속성도 자동으로 nil 값으로 초기화된다는 뜻입니다.\n비소유 참조 (Unowned Reference)비소유 참조도 약한 참조와 마찬가지로 참조 타입의 변수 선언 시에 앞에 unowned라는 키워드를 붙여서 선언할 수 있습니다.\n약한 참조와의 차이점은 참조하고 있던 인스턴스가 사라져도 해당 속성을 nil로 초기화하지 않는다는 점입니다.\ngildong &#x3D; nil\nprint(bori?.owner) &#x2F;&#x2F; ERROR: 실제로 메모리에 값이 없음 (nil X)\n\n위 코드는 약한 참조때와는 다르게 에러가 발생하며 프로그램이 종료됩니다. 비소유 참조는 nil로 초기화하지 않기 때문에 실제로 해당 메모리에 아무런 값이 없기 때문입니다.\n그래서 비소유 참조는 직접 nil 값을 초기화해주어야 합니다.\ngildong &#x3D; nil\nbori?.owner &#x3D; nil\nprint(bori?.owner) &#x2F;&#x2F; nil\n\n\n\n\n\n\n\n\n\n\n그러면 약한 참조와 비소유 참조는 각각 어떤 상황에 사용해야 적절할까요?\n두 참조 방식 모두 RC를 증가시키지 않는다는 공통점을 갖고 있습니다. 하지만 참조하던 값이 사라지면 nil 값으로 자동으로 초기화되는지 아닌지에 따라 역할이 구분됩니다.\n소유자에 비해 짧은 생명주기를 가진 인스턴스를 참조할 때는 약한 참조(weak)를 사용하면 좋습니다. 반대로 소유자보다 인스턴스의 생명주기가 더 길거나 같은 경우에는 비소유 참조(unowned)를 사용하면 좋습니다.\n한마디로 한 인스턴스가 참조하는 인스턴스보다 더 오래 메모리에 유지될 경우에는 weak을, 더 일찍 해제될 경우에는 unowned를 사용하면 좋습니다.\nunowned의 속도가 더 빠르다고 하지만 그 차이가 미미하고, unowned는 고려해야할 사항이 하나 더 생기는 것이기 때문에 실제 사용시에는 weak만 사용해도 무방하다고 합니다.\n클로저와 메모리 관리# 35)🧰 Swift - 클로저 (Closure)\n여기부터의 내용은 클로저에 대한 이해가 필요합니다.이전 게시물을 확인해주세요!\n캡처리스트의 형태\n파라미터가 없는 경우\n\n&#123; [캡처리스트] in\n\tprint(&quot;프린트&quot;)\n&#125;\n\n\n파라미터가 있는 경우\n\n&#123; [캡처리스트] (파라미터) -&gt; 리턴형 in\n\t print(&quot;프린트&quot;)\n&#125;\n\nfunc calculate() -&gt; ((Int) -&gt; Int) &#123;\n\tvar sum &#x3D; 0\n\n\tfunc square(num: Int) -&gt; Int &#123;\n\t\tsum +&#x3D; (num * num)\n\t\treturn sum\n\t&#125;\n\n\treturn square\n&#125;\n\nvar squareFunc &#x3D; calculateFunc()\nsquareFunc(10) &#x2F;&#x2F; 100\nsquareFunc(20) &#x2F;&#x2F; 500\nsquareFunc(30) &#x2F;&#x2F; 1400\n\n위 예시의 캡처 현상을 기억하시나요? \nsquareFunc에 저장한 square 함수를 실행하기 위해 필요한 sum이라는 변수는 calculateFunc 함수의 실행이 종료되면서 메모리에서 해제됩니다.\n이럴 때 발생하는 필연적인 에러를 방지하기 위해 squareFunc에 함수가 할당될 때 내부에 있지는 않지만 필요한 변수들의 값을 해당 시점에 캡처하여 함께 저장해두는 현상이였습니다.\n이런 이유로 클로저가 외부 변수를 사용하는 경우에는 무조건! 캡처가 발생됩니다.\n클로저 실행 시 값 타입의 캡처캡처 리스트를 사용하지 않은 경우var num &#x3D; 1\nlet valueCaptureClosure &#x3D; &#123;\n\tprint(&quot;밸류 값 출력(캡처): \\(num)&quot;)\n&#125;\n\nnum &#x3D; 7\nvalueCaptureClosure() &#x2F;&#x2F; 7\n\nnum &#x3D; 1\nvalueCaptureClosure() &#x2F;&#x2F; 1\n\n이 예시의 valueCaptureClosure는 캡처 리스트를 사용하지 않은 예시입니다.\n외부에 있는 num 변수를 사용하기 위해 변수를 캡처 해야하는데, 캡처 리스트를 사용하지 않은 경우에는 힙 영역의 클로저는 변수의 주소를 캡처합니다.\n그래서 num 변수의 값을 바꾼 후에 valueCaptureClosure를 실행시키면, 바뀐 변수의 값을 받아올 수 있는 것입니다.\n캡처 리스트를 사용한 경우var num &#x3D; 1\nlet valueCaptureListClosure &#x3D; &#123; [num] in\n\tprint(&quot;밸류 값 출력(캡처리스트): \\(num)&quot;)\n&#125;\n\nnum &#x3D; 7\nvalueCaptureListClosure() &#x2F;&#x2F; 1\n\n이번 예시의 valueCaptureListClosure는 캡처 리스트를 사용한 예시입니다.\n마찬가지로 외부에 있는 num 변수를 캡처하는데, 캡처 리스트를 사용했기 때문에 주소가 아니라 값 자체를 힙 영역에 함께 복사하여 캡처합니다.\n따라서 num 변수의 값을 바꾸더라도 바뀐 값이 적용되지 않고 힙 영역에 저장된 값을 계속 사용하게 됩니다.\n클로저 실행 시 참조 타입의 캡처지금까지의 예시는 값 타입의 변수들을 캡처할 때 발생하는 일들이였습니다.\n그렇다면 class나 closure 같은 참조 타입을 캡처할 때는 어떤 일이 발생할까요?\nclass SomeClass &#123;\n\tvar num &#x3D; 0\n&#125;\n\nvar x &#x3D; SomeClass()\nvar y &#x3D; SomeClass()\n\nprint(x.num, y.num) &#x2F;&#x2F; 0, 0\n\nlet refTypeCapture &#x3D; &#123; [x] in\n\tprint(&quot;참조 출력 값(캡처리스트): &quot;, x.num, y.num)\n&#125;\n\nx.num &#x3D; 1\ny.num &#x3D; 1\n\nprint(x.num, y.num) &#x2F;&#x2F; 1, 1\nrefTypeCapture() &#x2F;&#x2F; 1, 1\nprint(x.num, y.num) &#x2F;&#x2F; 1, 1\n\nrefTypeCapture 부분을 보면 [x]와 같이 x 클래스만 캡처리스트를 통해 받아온 것을 확인할 수 있습니다.\n두 값을 바꾼 후에 출력을 했을 때 값 타입때와는 다르게 이번에는 두 값 모두 바뀐 상태로 출력되었습니다.\n이런 일이 일어난 이유는 참조 타입임을 생각해보면 알 수 있습니다.\n먼저 캡처 리스트를 통해 복사해서 사용한 x 클래스의 경우에는 값 타입때와 같은 이유로 x 인스턴스의 주소값을 그대로 복사하여 저장했기 때문에 바로 힙 영역의 인스턴스로 찾아가 값이 바뀌었습니다.\n문제는 y 클래스인데, 클래스는 참조 타입이기 때문에 힙 영역의 클로저에서 스택 영역의 원본의 주소로 찾아가게 되면, 그곳에는 또 힙 영역에 할당되어 있는 원본 y 인스턴스의 주소가 담겨있습니다.\n\n힙 영역의 클로저(y 변수의 주소) ➡️ 스택 영역의 변수 (y의 주소) ➡️ 힙 영역의 인스턴스\n\n이렇게 결국 원본의 주소에 찾아가게 되기 때문에 값의 변경이 적용될 수 있었던 것입니다.\n강한 참조 사이클 문제의 해결자 그런데 참조하면 고려해야할 점이 하나 있습니다.바로 메모리의 천적 강한 참조입니다.\nvar z &#x3D; SomeClass()\nlet refTypeCapture &#x3D; &#123; [z] in\n\tprint(&quot;참조 출력값(캡처리스트): &quot;, z.num)\n&#125;\n\n참조 타입을 캡처하면 주소를 갖게 되고 인스턴스의 RC를 하나 올리게 됩니다. 이 말은 곧 캡처된 인스턴스가 다시 클로저를 참조하게 되면 강한 참조가 발생한다는 의미가 될 것입니다.\n그래서 캡처리스트에도 약한 참조(weak)와 비소유 참조(unowned)를 사용할 수 있습니다.\nvar z &#x3D; SomeClass()\nlet refTypeCapture &#x3D; &#123; [weak z] in\n\tprint(&quot;참조 출력값(캡처리스트):&quot;, z?.num)\n&#125;\n\n약한 참조와 비소유 참조의 경우 , 할당이 해제되면 값이 사라질 수 있기 때문에 Optional로 결과가 나왔었죠. 여기서도 마찬가지인 점 유의합시다.\n\n\n\n\n\n\n\n\n\n강한 참조..? 오히려 좋아\n그런데 강한 참조가 꼭 나쁜 것이냐 하면 그건 또 아닙니다. 강한 참조의 특징은 RC를 증가시킨다는 것이고, RC가 증가하면 메모리에서 해제가 되지 않겠죠.\n정말 꼭 필요한 인스턴스라면 강한 참조를 사용해서 오히려 RC를 일부러 증가시켜 외부 요인들로 인해서 메모리 해제가 되지 않도록 방지하는 역할도 할 수 있습니다.\n나쁜 기능을 쓰라고 만들어 뒀을리는 없으니 코딩을 할 때 생각하면서 작성해야겠습니다.\n캡처리스트 바인딩var s &#x3D; SomeClass()\nlet captureBinding &#x3D; &#123; [weak z &#x3D; s] in\n\t&#x2F;&#x2F; ...\n&#125;\n\n일반적인 클로저의 사용객체 내에서의 사용class Dog &#123;\n\tvar name &#x3D; &quot;초코&quot;\n\n\tfunc doSomething() &#123;\n\t\t&#x2F;&#x2F; 비동기 동작 클로저\n\t\tDispatchQueue.global().async &#123;\n\t\t\tprint(&quot;나의 이름은 \\(self.name)입니다.&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\nvar choco &#x3D; Dog()\nchoco.doSomething()\n\n실제로 앱을 만들 때는 객체 안에서 클로저를 사용하는 경우가 거의 대부분입니다. UIView, UIViewController 등의 컴포넌트들도 전부 객체이기 때문이죠.\n그런데 클로저 안에서 객체의 속성이나 메서드에 접근하기 위해서는 반드시 self 키워드를 붙여줘야 합니다.\n클로저의 scope 안에 있는 속성&#x2F;메서드인지 외부인 객체에 있는 속성&#x2F;메서드인지 알 수가 없겠죠.\n이 self를 붙여주는 방법이 두가지 있습니다.\n첫 번째 방법은 위 예시처럼 self.name과 같은 형태로 속성이나 메서드앞에 붙여주는 방법입니다.\n두 번째 방법은 캡처 리스트에서 사용해주는 방법입니다.\nfunc doSomething() &#123;\n\tDispatchQueue.global().async &#123; [self] in\n\t\tprint(&quot;나의 이름은 \\(name)입니다.&quot;)\n\t&#125;\n&#125;\n\n이 두 번째 방법은 약한 참조와 함께 사용하는 형태로 굉장히 많이 쓰이고 있습니다.\nfunc doSomething() &#123;\n\tDispatchQueue.global().async &#123; [weak self] in\n\t\tprint(&quot;나의 이름은 \\(self?.name)입니다.&quot;)\n\t&#125;\n&#125;\n\nfunc doSomething() &#123;\n\tDispatchQueue.global().async &#123; [weak self] in\n\t\tguard let weakSelf &#x3D; self else &#123; return &#125;\n\t\tprint(&quot;나의 이름은 \\(weakSelf.name)입니다.&quot;)\n\t&#125;\n&#125;\n\n메모리 누수의 사례아무래도 개념만 보면 어떤 때에 강한 참조 순환이 생기는건지 가늠이 안되죠.\nclass Dog &#123;\n\tvar name &#x3D; &quot;초코&quot;\n\tvar run: (() -&gt; Void)?\n\n\tfunc walk() &#123;\n\t\tprint(&quot;\\(self.name)가 걷는다.&quot;)\n\t&#125;\n\n\tfunc saveClosure() &#123;\n\t\trun &#x3D; &#123;\n\t\t\tprint(&quot;\\(self.name)가 뛴다.&quot;)\n\t\t&#125;\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(self.name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nfunc doSomething() &#123;\n\tlet choco: Dog? &#x3D; Dog()\n\tchoco?.saveClosure() &#x2F;&#x2F; 강한 참조 사이클\n&#125;\n\ndoSomething()\n&#x2F;&#x2F; doSomething()이 종료되어도 choco가 참조하는 run 클로저와 run 클로저가 self.name으로 참조하는 choco 사이에서 강한 참조 순환 발생\n\nView Controller에서의 예시class ViewController: UIViewController &#123;\n\tvar name: String &#x3D; &quot;뷰 컨트롤러&quot;\n\n\tfunc doSomething() &#123;\n\t\tDispatchQueue.global().async &#123;\n\t\t\tsleep(3)\n\t\t\tprint(&quot;글로벌 큐에서 출력: \\(self.name)&quot;)\n\t\t&#125;\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nfunc localScopeFunction() &#123;\n\tlet vc &#x3D; ViewController()\n\tvc.doSomething()\n&#125;\n\nlocalScopeFunction()\n\n\n\n\n\n\n\n\n\n\n(3초후)글로벌 큐에서 출력: 뷰 컨트롤러뷰 컨트롤러 메모리 해제\nclass ViewController: UIViewController &#123;\n\tvar name: String &#x3D; &quot;뷰 컨트롤러&quot;\n\n\tfunc doSomething() &#123;\n\t\tDispatchQueue.global().async &#123; [weak self] in\n\t\t\tsleep(3)\n\t\t\tprint(&quot;글로벌 큐에서 출력: \\(self.name)&quot;)\n\t\t&#125;\n\t&#125;\n\n\tdeinit &#123;\n\t\tprint(&quot;\\(name) 메모리 해제&quot;)\n\t&#125;\n&#125;\n\nfunc localScopeFunction() &#123;\n\tlet vc &#x3D; ViewController()\n\tvc.doSomething()\n&#125;\n\nlocalScopeFunction()\n\n\n\n\n\n\n\n\n\n\n(3초후)뷰 컨트롤러 메모리 해제글로벌 큐에서 출력: nil\nsleep(3)이 실행되기 전에 약한 참조(weak)를 받은 vc 인스턴스가 메모리에서 해제되어 nil값이 출력된다.\n","slug":"Allen/2022-11-05-Allen37","date":"2022-11-04T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"e87344a11426ba57cb8d3c641a799f55","title":"36)🧰 Swift - 고차함수 (High-Order Function)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n고차 함수\n함수를 파라미터로 사용하거나, 함수 실행의 결과를 함수로 리턴하는 함수\n\nmapmap 함수는 기존 배열등의 컬렉션을 새롭게 매핑해서 새로운 배열을 리턴하는 함수입니다.\n컬렉션의 각 아이템들에 대해서 가공을 거친 같은 형태의 컬렉션을 만들 때 사용됩니다.\nmap(transform: (Int) throws -&gt; T)\nlet numbers &#x3D; [1, 2, 3, 4, 5]\nvar a &#x3D; numbers.map &#123; num in\n\treturn &quot;숫자: \\(num)&quot;\n&#125; &#x2F;&#x2F; (Int) -&gt; String\nprint(a)\n&#x2F;&#x2F; [&quot;숫자: 1&quot;, &quot;숫자: 2&quot;, &quot;숫자: 3&quot;, &quot;숫자: 4&quot;, &quot;숫자: 5&quot;]\n\n\n\n\n\n\n\n\n\n\nmap 함수는 컬렉션의 크기와 원소의 개수가 동일하게 1:1로 매핑되어 반환되는 함수입니다.\nfilterfilter 함수는 기존 배열 등의 컬렉션에 있는 아이템들이 조건에 부합하는지를 확인한 후, 참인 경우만 모아서 새로운 배열을 만들어 리턴하는 함수입니다.\nfilter(isIncluded: (String) throws -&gt; Bool)\nlet names &#x3D; [&quot;Apple&quot;, &quot;Black&quot;, &quot;Circle&quot;, &quot;Dream&quot;, &quot;Blue&quot;]\nvar aaa &#x3D; names.filter &#123; str in\n\treturn str.contains(&quot;B&quot;)\n&#125; &#x2F;&#x2F; (String) -&gt; Bool\nprint(aaa)\n&#x2F;&#x2F; [&quot;Black&quot;, &quot;Blue&quot;]\n\n\n\n\n\n\n\n\n\n\nfilter 함수는 컬렉션에서 원하는 조건에 부합하는 멤버만 골라내고 싶을 때 사용하는 함수입니다.\nreducereduce 함수는 기존 배열 등의 컬렉션에서 각 아이템을 클로저가 제공하는 방식대로 결합해서 마지막 결과값을 반환하는 함수입니다.\nreduce(initialResult: Result, nextPartialResult: (Result, Int) throws -&gt; Result)\nvar numbersArray &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nvar aa &#x3D; numbersArray.reduce(0) &#123; a, b in\n\treturn a + b\n&#125;\nprint(aa)\n&#x2F;&#x2F; 55\n\n\n\n\n\n\n\n\n\n\nreduce 함수는 컬렉션을 클로저 안의 연산에 따라 하나의 결과로 반환하는 함수입니다. 첫 번째 파라미터는 초기값이라는 것을 기억해둡시다.\nmap &#x2F; filter &#x2F; reduce의 활용map이나 filter의 반환값은 배열이기 때문에 그 뒤에 또 다른 고차 함수를 다시 적용할 수 있습니다.\nnumbersArray &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n&#x2F;&#x2F; 위의 배열 중에 홀수만 제곱해서 그 숫자들을 전부 더한 값은?\nnumbersArray.filter &#123; $0 % 2 !&#x3D; 0 &#125;\n\t\t\t.map &#123; $0 * $0 &#125;\n\t\t\t.reduce(0) &#123; $0 + $1 &#125;\n&#x2F;&#x2F; 165\n\nforEachforEach 함수는 기존 배열 등의 컬렉션에서 각 아이템들을 사용하여 특정 작업을 실행하는 함수입니다.\nforEach(body: (Int) throws -&gt; Void)\nlet immutableArray &#x3D; [1, 2, 3, 4, 5]\nimmutableArray.forEach &#123; print($0) &#125;\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; ...\n&#x2F;&#x2F; 5\n\ncompactMapcompactMap 함수는 기존 배열 등의 컬렉션에서 각 아이템들을 새롭게 매핑하여 변형하되, 옵셔널 아이템은 제거합니다.\n쉽게 말해 옵셔널 바인딩 기능이 추가된  map 함수입니다.\ncompactMap((Self.Element) -&gt; ElementOfResult?)\nlet stringArray: [String?] &#x3D; [&quot;A&quot;, nil, &quot;B&quot;, nil, &quot;C&quot;]\n\nvar newStringArray &#x3D; stringArray.compactMap &#123; $0 &#125;\nprint(newStringArray)\n&#x2F;&#x2F; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]\n\nlet numbers &#x3D; [-2, -1, 0, 1, 2]\nvar positiveNumbers &#x3D; numbers.compactMap &#123; $0 &gt;&#x3D; 0 ? $0 : nil &#125;\nprint(positiveNumbers)\n\nflatMapflatMap 함수는 기존 배열 등의 컬렉션을 중첩된 배열을 제거한 뒤에 매핑하고 그 결과를 반환합니다.\nflatMap((Self.Element) -&gt; SegmentOfResult)\nvar nestedArray &#x3D; [[1, 2, 3], [4, 5, 6], 7, 8, 9]\nprint(nestedArray.flatMap &#123; $0 &#125;)\n&#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n","slug":"Allen/2022-11-04-Allen36","date":"2022-11-03T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"05c7a8ad61ab635112e2267f3af9157c","title":"35)🧰 Swift - 클로저 (Closure)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n클로저 (Closure)클로저의 개념 및 1급 객체 취급클로저를 보기 전에기존의 함수의 타입 표기와 사용법은 다음과 같습니다. \n\n() -&gt; (), () -&gt; Void\n(String) -&gt; String\n(Int, Int) -&gt; (), (Int, Int) -&gt; Void\n\n클로저\n이름이 없는 (익명의) 함수\n클로저와 함수는 기능은 완전히 동일하지만, 형태가 다르다.\n\n함수와 클로저\n함수: 이름이 있는 코드의 묶음\n다른 코드가 함수 이름으로 호출하기 위해\n\n\n클로저: 이름이 없는 코드의 묶음\n굳이 이름이 없어도 호출할 수 있는 형태로 사용 가능\n\n\n\n함수와 클로저의 형태\n함수\n\nfunc aFunction(str: String) -&gt; String &#123;\n\treturn &quot;Hello, \\(str)&quot;\n&#125;\n\n\n클로저\n\nlet _ &#x3D; &#123; (str: String) -&gt; String in\n\treturn &quot;Hello, \\(str)&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n\n&#123;&#125;(중괄호)를 함수라고 인식하면 좋다…!\nlet aClosureType &#x3D; &#123; print(&quot;안녕!&quot;) &#125; &#x2F;&#x2F; () -&gt; ()\naClosureType() &#x2F;&#x2F; 호출( 안녕! )\n\n일급객체Swift는 함수를 일급객체로서 취급합니다. 따라서 함수는 타입으로서 취급됩니다. 함수를 타입으로서 취급하여 얻을 수 있는 이점들을 다음과 같습니다.\n\n함수를 변수에 할당할 수 있다.\n함수를 호출할 때, 함수를 파라미터로 전달할 수 있다.\n함수에서 함수를 반환할 수 있다.\n\n클로저는 왜 필요할까?콜백함수 (Callback Function)\n콜백함수: 함수를 실행할 때 파라미터로 전달하는 함수\n\n\n클로저를 파라미터로 받는 함수 정의\n\nfunc closureParamFunction(closure: () -&gt; Void) &#123;\n\tprint(&quot;안녕하세요!&quot;)\n\tclosure()\n&#125;\n\n\n함수를 실행할 때 파라미터를 클로저 형태로 전달\n\nclosureParamFunction(closure: &#123;\n\tprint(&quot;안녕히계세요!&quot;)\n&#125;)\n&#x2F;&#x2F; 안녕하세요!\n&#x2F;&#x2F; 안녕히계세요!\n\n\n\n\n\n\n\n\n\n\n함수 실행할 때 클로저를 정의하면서 실행하는게 왜 좋은거에요?\n콜백함수인데 따로 다른 곳에서는 쓰이지 않는 함수가 있다면 그 함수는 굳이 이름이 필요가 없겠죠.. 클로저는 그럴 때 유용합니다. \n파라미터를 처리한 결과를 함수에 바로 넣고 싶을 때 (사후처리)\n클로저를 파라미터로 받는 함수 정의\n\nfunc closureCaseFunction(a: Int, b: Int, closure: (Int) -&gt; Void) &#123;\n\tlet c &#x3D; a + b\n\tclosure(c)\n&#125;\n\n\n함수를 실행할 때 클로저 형태로 전달\n\nclosureCaseFunction(a: 5, b: 2, closure: &#123; (number) in \n\tprint(&quot;클로저의 결과: \\(number)&quot;)\n&#125;)\n&#x2F;&#x2F; 클로저의 결과: 7\n\n\n\n\n\n\n\n\n\n\n이게 왜 좋은건지 도저히 느낌이 안와요!\n예시는 단순 출력문만 있기 때문에 느낌이 안올 수 있어요. 하지만 후처리로 개발자가 원하는대로 클로저를 줄 수 있다는 것은 개발 과정에서의 엄청난 자율성과 활용성을 제공해줍니다.\n실제로 Swift 언어를 사용하는 개발자들은 이러한 형태의 코드를 굉장히 많이 사용하고 있어요. 오픈소스 라이브러리를 살펴보면, 이러한 클로저의 사후처리 개념을 알지 못하면 기능을 전혀 이해를 할 수 없을 정도에요!\n보통 애플이나 오픈소스 라이브러리 작성자들이 번거롭고 어려운 내용의 코드들을 작성해두고, 해당 코드의 결과를 다른 개발자들이 쉽게 이용할 수 있도록 클로저를 파라미터로 받는 형태로 함수를 제공합니다.\n클로저의 간소화 문법클로저는 실사용시의 가독성과 편의성을 위해 매우 다양한 축약 형태를 제공합니다. 크게 네 가지 형태로 나눌 수 있고, 다음과 같습니다.\n\n문맥 상 파라미터와 리턴 밸류 타입 추론 (Type Inference)\n싱글 익스프레션일 경우 (한 줄), 리턴 생략 (Implicit Return)\n아규먼트 이름을 축약 (Shorthand Arguments)\n트레일링(후행) 클로저 (Trailing Closure)\n\n하나씩 한 번 살펴보겠습니다.\n트레일링 (Trailing) 클로저\n원문\n\nclosureParamFunction(closure: &#123;\n\tprint(&quot;안녕히계세요.&quot;)\n&#125;)\n\n\n소괄호 앞으로 이동\n\nclosureParamFunction(closure: ) &#123;\n\tprint(&quot;안녕히계세요.&quot;)\n&#125;\n\n\n인자(Argument) 레이블 생략\n\nclosureParamFunction() &#123;\n\tprint(&quot;안녕히계세요.&quot;)\n&#125;\n\n\n마지막 인자로 클로저가 전달되는 경우 소괄호 생략 가능\n\nclosureParamFunction &#123;\n\tprint(&quot;안녕히계세요.&quot;)\n&#125;\n\n현실적인 사용 예시func closureCaseFunction(a: Int, b: Int, closure: (Int) -&gt; Void) &#123;\n\tlet c &#x3D; a + b\n\tclosure(c)\n&#125;\n\nclosureCaseFunction(a: 3, b: 4) &#123; res in &#x2F;&#x2F; 함수 인자 앞까지 소괄호 이동\n\tprint(&quot;Update Complete: \\(res) obtained.&quot;)\n&#125;\n\n멀티플 트레일링 클로저Swift 5.3에서 추가된 클로저 편의성 추가 기능입니다.\n원래는 마지막 클로저만 트레일링 클로저를 적용할 수 있었습니다. 하지만 5.3 버전부터는 여러 개의 클로저에 모두 적용할 수 있게 되었습니다.\nfunc multipleClosure(first: () -&gt; (), _ second: () -&gt; (), third: () -&gt; ()) &#123;\n\tfirst()\n\tsecond()\n\tthird()\n&#125;\n\n&#x2F;&#x2F; 5.3 이전\nmultipleClosure(first: &#123;\n\tprint(&quot;1&quot;)\n&#125;, _: &#123;\n\tprint(&quot;2&quot;)\n&#125;) &#123;\n\tprint(&quot;3&quot;)\n&#125;\n\n&#x2F;&#x2F; 5.3 이후\nmultipleClosure &#123;\n\tprint(&quot;1&quot;)\n&#125; _: &#123;\n\tprint(&quot;2&quot;)\n&#125; third: &#123;\n\tprint(&quot;3&quot;)\n&#125;\n\n파라미터 및 생략 등의 간소화func performClosure(param: (String) -&gt; (Int) &#123;\n\tparam(&quot;Swift&quot;)\n&#125;\n\nperformClosure(param: &#123; (str: String) -&gt; Int in \n\treturn str.count\n&#125;)\n\n\n타입 추론\n\nperformClosure(param: &#123; str in\n\treturn str.count\n&#125;)\n\n\n한 줄일 경우 return 생략 가능\n\nperformClosure(param: &#123; str in\n\tstr.count\n&#125;)\n\n\n인자(argument) 이름을 축약\n\nperformClosure(param: &#123;\n\t$0.count\n&#125;)\n\n\n\n\n\n\n\n\n\n\n엥.. $가 뭐에요…\n$0은 순서 상 첫 번째 파라미터입니다. 마찬가지로  $1, $2, $3 은 각각 두 번째, 세 번째, 네 번째 파라미터입니다.\n\n트레일링 클로저\n\nperformClosure &#123;\n\t$0.count\n&#125;\n\nperformClosure &#123; $0.count &#125;\n\n실제 사용 예시단순해지고 편해지는건 알겠는데, 실제로 써먹을 때의 모습을 봐야 이해가 딱 될 것 같아요.\nURLSessionURLSession(configuration: .default).dataTask(with: URL(string: &quot;https:&#x2F;&#x2F;address&quot;)!) &#123; data, response, error in\n\tswitch response &#123;\n\tcase .success:\n\t\treturn data\n\tcase .failure:\n\t\tprint(error)\n\t&#125;\n&#125;\n\n물론 위처럼 간단하게는 못 써요..! 중요한 건 클로저니까 형태 정도만 보면 됩니다.\nTimerTimer.scheduledTimer(withTimeInterval: 0.5, repeats: false) &#123; _ in\n\tprint(&quot;0.5초 뒤에 출력&quot;)\n&#125;\n\ndismissvc.dismiss(animated: true) &#123;\n\tprint(&quot;화면 종료&quot;)\n&#125;\n\n클로저의 메모리클로저는 참조타입!클로저는 클래스와 마찬가지로 참조 타입입니다. \n시작은 다른 모든 함수들과 동일하게 스택 영역에서 실행됩니다. \n클로저가 일반적인 함수와 다른 점은 함수를 호출할 때 일어납니다. \n일반적인 함수는 호출되면 코드 영역의 코드 블럭 시작점을 찾아가 한 줄씩 코드를 실행합니다.\n하지만 클로저는 참조 타입이기 때문에 힙 영역에 있는 클로저 주소에 찾아간 후에, 힙 영역에 저장된 코드 블럭 주소를 받아 코드 영역의 코드를 실행합니다.\n그렇다면 클로저는 왜 참조 타입으로 저장될까요?\n클로저의 캡처 현상var stored &#x3D; 0\nlet closure &#x3D; &#123; (number: Int) -&gt; Int in\n\tstored +&#x3D; number\n\treturn stored\n&#125;\n\nclosure(3) &#x2F;&#x2F; 3\nclosure(4) &#x2F;&#x2F; 7\nclosure(5) &#x2F;&#x2F; 12\nstored &#x3D; 0\nclosure(5) &#x2F;&#x2F; 5\n\n위 예시에서 stored이라는 변수는 클로저 내부에 정의된 변수가 아니라 외부에 있는 변수입니다. 따라서 클로저는 변수에 할당되거나 호출되는 순간, 자신이 참조하는 외부의 변수를 캡처합니다.\n\n\n\n\n\n\n\n\n\n클로저 내부에서 사용할 외부의 값을 필요할 경우 힙 영역에 저장해둔다는 의미입니다. 이 때 저장되는 값은 값 자체보다는 스택 영역에 저장된 변수의 주소가 참조 타입으로 저장됩니다.\n자 그러면 동일한 기능을 가지는 함수를 각각 일반적인 함수와 클로저를 사용하여 어떻게 과정과 결과가 달라지는지 확인해보겠습니다.\n일반적인 함수 (Nested Function)func calculate(number: Int) -&gt; Int &#123;\n\tvar sum &#x3D; 0\n\n\tfunc square(num: Int) -&gt; Int &#123;\n\t\tsum +&#x3D; (num * num)\n\t\treturn sum\n\t&#125;\n\n\tlet result &#x3D; square(num: number)\n\n\treturn result\n&#125;\n\ncalculate(number: 10) &#x2F;&#x2F; 100\ncalculate(number: 20) &#x2F;&#x2F; 400\ncalculate(number: 30) &#x2F;&#x2F; 900\n\n위 예시의 경우에는 일반적인 함수를 사용하는 방법입니다.\n이 경우에는, 모든 연산은 오직 스택 영역에서만 이루어집니다. Nested Function이라 할지라도 새로운 스택을 쌓아가며, 스택 안에서만 모든 연산들이 이루어지죠.\n변수를 캡처하는 함수func calculateFunc() -&gt; ((Int) -&gt; Int) &#123;\n\tvar sum &#x3D; 0\n\n\tfunc square(num: Int) -&gt; Int &#123;\n\t\tsum +&#x3D; (num * num)\n\t\treturn sum\n\t&#125;\n\n\treturn square\n&#125;\n\nvar squareFunc &#x3D; calculateFunc() &#x2F;&#x2F; square((Int) -&gt; Int)\nsquareFunc(10) &#x2F;&#x2F; 100\nsquareFunc(20) &#x2F;&#x2F; 500\nsquareFunc(30) &#x2F;&#x2F; 1400\nvar dodoFunc &#x3D; squareFunc\ndodoFunc(20) &#x2F;&#x2F; 1800\n\n위 예시의 경우에는 캡처 현상이 발생하는 함수입니다.\nsquareFunc 변수에는 calculateFunc 함수 내부에 있는 square 함수가 담겼습니다. 어떤 함수의 내부에 있는 함수가 리턴되는 경우, 클로저와 동일하게 힙 영역에 내부 함수를 저장하고 그 주소를 리턴하게 됩니다.\n따라서 squareFunc 변수에는 내부 함수 square가 힙 영역에 저장된 주소가 저장되게 됩니다.\n그런데 내부 함수 square는 외부의 변수 sum을 사용하고 있습니다. 문제는 여기서 발생합니다.\ncalculateFunc 함수의 실행이 끝나면 해당 함수는 스택 영역에서 해제됩니다. 그런데 그 내부에 있는 square 함수는 새로운 변수 squareFunc에 저장되어 보존되었고, calculateFunc 함수에 저장되었던 sum이라는 변수를 필요로 합니다.\n스택 영역에서 해제되버리면 sum 변수또한 해제되어 버리기 때문에, squareFunc 변수에 저장된 함수를 실행하면 무조건 에러가 나게 되었습니다. 이런 현상을 방지하기 위해 캡처 현상이 발생합니다. \n내부의 square 함수는 외부에 있지만 필요한 sum이라는 변수를 본인의 저장 공간(힙 영역)에 함께 저장합니다.\n이런 캡처 현상 때문에 일반적인 함수를 사용할 때처럼 매번 변수를 초기화하지 못하고 저장된 변수를 계속해서 사용하기 때문에 이전에 넣어주었던 값이 계속해서 보존되게 되는 것입니다.\n\n\n\n\n\n\n\n\n\n캡처 현상은 이렇게 힙 영역에 함수를 저장하는 현상이 발생하는 (1) 함수를 변수에 할당하거나 (2) 클로저를 사용하는 경우 발생합니다.\n@escaping &#x2F; @autoclosure 클로저@escaping 클로저원칙적으로 지금까지 배운 클로저들은 함수의 실행이 종료되면 파라미터로 쓰였던 클로저까지 함께 메모리에서 해제됩니다. \n@escaping 클로저는 클로저를 제거하지 않고 함수에서 탈출시킵니다. 다른 말로, 함수가 종료되어도 클로저가 해제되지 않습니다.\n이런 기능이 필요한 경우는 크게 두 가지입니다.\n\n내부에서 사용한 클로저를 외부 변수에 저장\nGCD (비동기 코드의 사용)\n\nvar aSavedFunction: () -&gt; () &#x3D; &#123; print(&quot;출력&quot;) &#125;\n\nfunc performEscaping2(closure: @escaping () -&gt; ()) &#123;\n\taSavedFunction &#x3D; closure &#x2F;&#x2F; 클로저를 외부 aSavedFunction에 할당\n&#125;\n\nperformEscaping2(closure: &#123; print(&quot;다르게 출력&quot;) &#125;)\naSavedFunction() &#x2F;&#x2F; 다르게 출력\n\nfunc performEscaping1(closure: @escaping (String) -&gt; ()) &#123;\n\tvar name &#x3D; &quot;홍길동&quot;\n\n\tDispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123;\n\t\tclosure(name)\n\t&#125;\n&#125;\n\nperformEscaping1 &#123; name in\n\tprint(&quot;이름 출력하기: \\(name)&quot;)\n&#125;\n\n\n\n\n\n\n\n\n\n\n정리\n\n함수 주소가 힙 영역에 저장되는 경우 ( &#x3D; 함수가 비교적 긴 시간 저장되어야 하는 경우)\n\n\n함수를 변수에 담는 경우\n중첩함수(Nested Function)에서 내부 함수를 반환하고, 그것을 외부 변수에 담는 경우\n비동기적인 클로저의 실행의 경우\n\n@autoclosure@autoclosure는 자동으로 클로저 처리를 해주는 키워드입니다. 번거로움을 조금이라도 줄이기 위해 자동으로 중괄호를 씌워줍니다.\n@autoclosure는 파라미터가 없는 경우에만 사용할 수 있습니다.\n하지만 사실 잘 사용되지 않는 문법입니다. 코드가 명확하지 않게 작성되기 때문에 애플에서도 추천하지 않고 있습니다.\nfunc someFunction(closure: @autoclosure () -&gt; Bool) &#123;\n\tif closure() &#123;\n\t\tprint(&quot;참입니다.&quot;)\n\t&#125; else &#123;\n\t\tprint(&quot;거짓입니다.&quot;)\n\t&#125;\n&#125;\n\nvar num &#x3D; 1\nsomeFunction(closure: true)\n&#x2F;&#x2F; someFunction(closure: &#123; true &#125;)\n\n클로저 사용 예시 (코드로 UI 작성)\n설정까지 완료된 UI 컴포넌트의 반환\n\nlet emailTextField: UITextField &#x3D; &#123;\n\tlet tf &#x3D; UITextField()\n\ttf.placeholder &#x3D; &quot;Email&quot;\n\ttf.backgroundColor &#x3D; .systemRed\n\ttf.borderStyle &#x3D; .roundedRect\n\ttf.font &#x3D; UIFont.systemFont(ofSize: 14)\n\ttf.addTarget(self, action: ..., for: ...)\n\treturn tf\n&#125;() &#x2F;&#x2F; 해당 클로저를 바로 실행하여 반환값을 할당\n\n","slug":"Allen/2022-11-01-Allen35","date":"2022-10-31T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"28d16104e44090134cb96751618130c4","title":"13)🍎 Swift - ScrollView 오토 레이아웃으로 구현하기","content":"UIScrollView는 스토리보드에서 사용할 때마다 에러를 내는 UI 컴포넌트 중 대표적인 친구입니다.하지만 언제나처럼 컴퓨터는 잘못이 없죠.제대로 알고 사용하지 못해서 일어나는 장애물이라고 생각하고 머리를 정리할 겸 단계별로 알아보겠습니다.\nUIScrollViewUIScrollView가 뭔지부터 알아보겠습니다.UIScrollView는 화면의 크기를 벗어나는 콘텐츠를 표현할 때 스크롤을 통해서 더 많은 정보를 탐색할 수 있도록 해주는 컴포넌트입니다.\n이 UIScrollView는 굉장히 중요한 녀석입니다.저희가 매일같이 사용하는 UITableView, UICollectcionView와 같은 스크롤이 가능한 컴포넌트들의 Super Class이기 때문이죠.그래서 이런 테이블뷰와 컬렉션뷰에서 스크롤뷰의 메서드와 속성들에 접근할 수 있습니다.\n스크롤뷰는 두 가지 레이아웃으로 나뉘어져 있습니다.Content Layout은 스크롤되며 화면에 표현될 컨텐츠들의 레이아웃을 결정하는 레이아웃입니다.Frame Layout은 화면 안에서 실제로 표현되는 스크롤뷰의 크기와 위치를 결정하는 레이아웃입니다.\nScrollView 오토 레이아웃 잡아주기\n\n위 사진처럼 UIScrollView를 하나 넣어주고 다른 View들과 마찬가지로 오토레이아웃을 잡아줍니다.그런데 다른 View들과는 다르게 바로 적용이 안되는 것처럼 보입니다?실질적인 Contents가 정의되어 있지 않아서 그런 것이라고 추정하고 있지만 정확한 이유는 잘 모르겠습니다.알게 되면 추가 내용으로 적어두겠습니다..!아무튼  Constraints를 보면 잘 적용되어 있는 것을 확인할 수 있습니다.\n\n\nView 추가하고 Layout Guide 설정하기스크롤뷰만 있으면 아무 쓸모가 없겠죠?실제로 스크롤 될 View를 넣어봅시다.\n저는 보기 편하게 스크롤뷰와 겹치게 위치를 잡아주고 이름도 Content View라고 바꿔주었습니다.필수 과정은 아닙니다!\n스크롤 될 실제 컨텐츠를 담을 View이기 때문에 Content Layout Guide를 이 View의 Layout과 맞춰줄 겁니다.일종의 배경이자 도화지 역할을 하는 Content View의 크기를 컴파일러에게 알려주는 과정인거에요!\n\n\nContent View를 Ctrl키를 누른 상태로 Content Layout Guide까지 끌어당기면 두 요소간의 레이아웃을 설정해줄 수 있습니다.\n\n\nContent View의 크기가 곧 스크롤뷰에 들어갈 컨텐츠의 크기이기 때문에 Leading, Top, Trailing, Bottom의 Spacing을 모두 0으로 설정해줍시다.\n\n\n현재 스토리보드에 놓여진 값 그대로 Constant 값이 들어가기 때문에 모두 0이 맞는지 확인해보는 작업이 필요합니다!\nScroll View의 방향 정해주기저는 세로로 스크롤되는 화면을 만들고 싶습니다.화면이 세로로 스크롤될 때 넓이와 높이 중에 고정되어 있는 값은 넓이죠?\n스크롤뷰의 Frame Layout Guide는 넓이가 고정되어 있다면 세로로 스크롤되게 작동합니다.반대로 높이가 고정되어 있다면 가로로 스크롤할 수 있습니다.\n왜 Frame Layout Guide를 설정해줘야 하는지 헷갈릴 수 있는데요, Frame Layout은 실제 스크롤뷰가 표현될 Layout이라고 했었습니다.\nFrame Layout의 넓이를 컨텐츠의 넓이와 같게 설정하면 컴파일러 Frame 밖에 가로 형태로 표현할 컨텐츠가 더 이상 없다는 걸 알 수 있겠죠?그래서 가로는 고정되고 세로로만 스크롤되게 됩니다.\n\n\n위에서 Content Layout을 잡아줬을 때처럼 Content View를 Ctrl키를 누른채로 Frame Layout Guide에 끌어놔줍니다.\n\n\n그러면 나오는 Constraint 설정 창에서 Equal Width를 선택해서 가로를 갖게 만들어줍니다.\n\n\n물론 위에서처럼 수치가 현재 스토리보드에 맞게 들어가기 때문에 한 번 확인해주어야 합니다.이번에는 비율로서 다뤄지는 값이기 때문에 Multiplier가 1인지 확인해줍니다!\n높이 정해주기여기까지가 스크롤뷰를 스토리보드에서 설정해주는 방법입니다.그런데 아직 빨간 에러가 사라지지 않았죠?컨텐츠의 넓이는 스크롤뷰의 Frame Layout과 같게 만들어주었기 때문에 정해졌지만, 높이는 아직 정해주지 않았기 때문입니다.\n따라서 Content View의 높이를 고정 값으로 정해주거나, 실제로 내부에 컴포넌트들을 집어넣어주면 해당 에러는 사라집니다.\n추천하는 방법으로는 Content View에 높이 값을 주되, Priority를 내려주어서 정해진 높이 이상이 필요하면 동적으로 늘어나게 하는 것이 좋습니다.\n\nContent View를 Ctrl키를 누른채로 끌었다가 Content View 본인에게 놔줍니다.그 상태에서 Height를 설정해주면, 현재 스토리보드에 설정된 높이가 Constraint에 추가됩니다.\n\n\nPriority도 마찬가지로 Constraint에서 수정해줄 수 있습니다. 기본값인 1000에서 낮은 값으로 설정해줍시다!이 값은 내부에 들어올 컴포넌트들의 높이 Priority보다 낮으면 됩니다.저는 넉넉하게 250으로 설정해주었습니다.\n\n이렇게 에러가 없는 깔끔한 스토리보드가 되었네요.\nUIScrollView는 다루기 굉장히 까다로운 녀석이지만, 개념 자체는 쉬운 것 같아요.개념을 이해하고 다룬다면 익숙해지는데 많은 시간이 걸리지 않을 것이라고 생각합니다!\n","slug":"Swift/2022-10-21-Swift13","date":"2022-10-20T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"1ed6334be43ee572a89c87ad1476b5f3","title":"34)🧰 Swift - 중첩 타입 (Nested Types)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n중첩 타입 (Nested Types)왜 사용할까?\n특정 타입 안에서만 사용하기 위해\n내부의 타입은 외부의 타입과 관계가 있고, 외부의 타입 없이는 의미가 없을 수 있다.\n\n\n타입 간의 연관성을 명확하게 구분하고 내부 구조를 상세하게 설계 가능\n\n예시struct BlackjackCard &#123;\n\tenum Suit: Character &#123;\n\t\tcase spades &#x3D; &quot;♠️&quot;, hearts &#x3D; &quot;♥️&quot;, diamonds &#x3D; &quot;♦️&quot;, clubs &#x3D; &quot;♣️&quot;\n\t&#125;\n\n\tenum Rank: Int &#123;\n\t\tcase two &#x3D; 2, three, four, five, six, seven, eight, nine, ten\n\t\tcase jack, queen, king, ace\n\n\t\tstruct Values &#123;\n\t\t\tlet first: Int, second: Int?\n\t\t&#125;\n\n\t\tvar values: Values &#123;\n\t\t\tswitch self &#123;\n\t\t\tcase .ace:\n\t\t\t\treturn Values(first: 1, second: 11)\n\t\t\tcase .jack, .queen, .king:\n\t\t\t\treturn Values(first: 10, second: nil)\n\t\t\tdefault:\n\t\t\t\treturn Values(first: self.rawValue, second: nil)\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tlet rank: Rank, suit: Suit &#x2F;&#x2F; 저장 속성\n\n\tvar subtitle: String &#123; &#x2F;&#x2F; 계산 속성\n\t\tvar output &#x3D; &quot;\\(suit.rawValue) 세트,&quot;\n\t\toutput +&#x3D; &quot; 숫자 \\(rank.values.first)&quot;\n\n\t\tif let second &#x3D; rank.values.second &#123;\n\t\t\toutput +&#x3D; &quot; 또는 \\(second)&quot;\n\t\t&#125;\n\n\t\treturn output\n\t&#125;\n&#125;\n\nlet card1 &#x3D; BlackjackCard(rank: .ace, suit: .spades)\nprint(&quot;1번 카드: \\(card1.subtitle)&quot;)\n&#x2F;&#x2F; &quot;1번 카드: ♠️ 세트, 숫자 1 또는 11&quot;\n\nlet card2 &#x3D; BlackjackCard(rank: .five, suit: .diamonds)\nprint(&quot;2번 카드: \\(card2.subtitle)&quot;)\n&#x2F;&#x2F; &quot;2번 카드: ♦️ 세트, 숫자 5&quot;\n\nlet heartsSymbol: Character &#x3D; BlackjackCard.Suit.hearts.rawValue\n\n예시2 (실제 API)let formatter &#x3D; DateFormatter()\n\nformatter.dateStyle &#x3D; .full\n&#x2F;&#x2F; formatter.dateStyle &#x3D; DateFormatter.Style.full\n\nlet setting1: DateFormatter.Style &#x3D; DateFormatter.Style.full\nlet setting2: DateFormatter.Style &#x3D; DateFormatter.Style.medium\n\n애플은 왜 이렇게 만들었을까?enum Style &#123;\n\tcase full\n\tcase long\n\tcase medium\n\tcase none\n&#125;\n\n위와 같이 선언했다면 위 열거형이 어떤 타입과 관계가 있는지 명확하지 않다.(DateFormatter인지 UIView인지)\nstruct DateFormatters &#123;\n\tvar style: Style\n\n\tenum Style &#123;\n\t\tcase full\n\t\tcase long\n\t\tcase medium\n\t\tcase none\n\t&#125;\n&#125;\n\n위와 같이 선언한다면 Style 열거형이 DateFormatters와 연관되어 있다는 것을 확실하게 확인할 수 있다.\n자주 사용되는 예시\n실제 앱에서 “문자열” 모음을 묶어서 사용하는 경우가 많다.\n실수 방지를 위해서\n\n\n\nstruct K &#123;\n\tstatic let appName &#x3D; &quot;MySuperApp&quot;\n\tstatic let cellIdentifier &#x3D; &quot;ReusableCell&quot;\n\tstatic let cellNibName &#x3D; &quot;MessageCell&quot;\n\tstatic let registerSegue &#x3D; &quot;RegisterToChat&quot;\n\tstatic let loginSegue &#x3D; &quot;LoginToChat&quot;\n\n\tstruct BrandColors &#123;\n\t\tstatic let purple &#x3D; &quot;BrandPurple&quot;\n\t\tstatic let lightPurple &#x3D; &quot;BrandLightPurple&quot;\n\t\tstatic let blue &#x3D; &quot;BrandBlue&quot;\n\t\tstatic let lightBlue &#x3D; &quot;BrandLightBlue&quot;\n\t&#125;\n\n\tstruct FStore &#123;\n\t\tstatic let collectionName &#x3D; &quot;messages&quot;\n\t\tstatic let senderField &#x3D; &quot;sender&quot;\n\t\tstatic let bodyField &#x3D; &quot;body&quot;\n\t\tstatic let dateField &#x3D; &quot;date&quot;\n\t&#125;\n&#125;\n\nlet app &#x3D; K.appName\nlet color &#x3D; K.BrandColors.blue\n\nclass Message &#123;\n\tprivate enum Status &#123;\n\t\tcase sent\n\t\tcase received\n\t\tcase read\n\t&#125;\n\n\tlet sender: String, recipient: String, content: String\n\tlet timeStamp: Date\n\n\tprivate var status &#x3D; Message.Status.sent\n\n\tinit(sender: String, recipient: String, content: String) &#123;\n\t\tself.sender &#x3D; sender\n\t\tself.recipient &#x3D; recipient\n\t\tself.content &#x3D; content\n\n\t\tself.timeStampe &#x3D; Date()\n\t&#125;\n\n\tfunc getBasicInfo() -&gt; String &#123;\n\t\treturn &quot;보낸사람: \\(sender), 받는사람: \\(recipient), 메세지 내용: \\(content), 보낸 시간: \\(timeStamp.subtitle)&quot;\n\t&#125; \n\n\tfunc statusColor() -&gt; UIColor &#123;\n\t\tswitch status &#123;\n\t\tcase .sent:\n\t\t\treturn UIColor(red: 1, green: 0, blue: 0, alpha: 1)\n\t\tcase .received:\n\t\t\treturn UIColor(red: 0, green: 0, blue: 1, alpha: 1)\n\t\tcase .read:\n\t\t\treturn UIColor(red: 0, green: 1, blue: 1, alpha: 1)\n\t\t&#125;\n\t&#125;\n&#125;\n\nlet message1 &#x3D; Message(sender: &quot;홍길동&quot;, recipient: &quot;임꺽정&quot;, content: &quot;뭐해?&quot;)\nprint(message1.getBasicInfo())\n","slug":"Allen/2022-10-15-Allen34","date":"2022-10-14T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"69f8880ec5c4a5498a069d7bb5807eb6","title":"33)🧰 Swift - 메서드 디스패치 (Method Dispatch)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nMethod Dispatch코드 영역에 저장된 함수&#x2F;메서드를 실행시키려면 그 주소를 알아야합니다.이 메서드를 실행시키는 방법에는 크게 3가지 방법이 있습니다.\nSwift가 함수를 실행시키는 방법Direct Dispatch다른 말로 Static Dispatch라고도 합니다.어떤 테이블을 거치지 않고 메서드의 메모리 주소를 직접 삽입하여 호출하는 방법입니다.그렇기 때문에 컴파일 타임에 미리 이루어지게 됩니다.호출 명령 코드를 코드의 인라인에 직접 심기 때문에 가장 빠른 방법입니다.값타입(구조체&#x2F;열거형)에서 주로 사용됩니다.\nTable Dispatch다른 말로 Dynamic Dispatch라고도 부릅니다.메서드의 주소를 가리키는 포인터를 배열의 형태로 보관한 후에 실행하는 방법입니다.그렇기 때문에 런타임에 동작이 이루어지게 되고, 세 가지 방법 중에서는 중간의 속도를 냅니다.클래스와 프로토콜에 테이블(배열)이 포함되는 형태로 주로 사용됩니다. (ex: Virtual Table - 클래스, Witness Table - 프로토콜)\nMessage Dispatch상속 구조를 모두 훑은 후에 실행할 메서드를 찾아내서 실행하는 방법입니다.Obj-C에서 사용되던 방법이고 속도도 가장 느려서 최근에는 많이 사용되지 않습니다.\n","slug":"Allen/2022-10-14-Allen33","date":"2022-10-13T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"5b935310e5ab86264b239e5fd2bbef6c","title":"32)🧰 Swift - 프로토콜 (Protocol)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n프로토콜 (protocol)프로토콜의 개념프로토콜의 필요성\n클래스 상속의 단점\n하나의 클래스만 상속 가능 (다중 상속 불가)\n상위 클래스의 메모리 구조를 따라감 (필요하지 않은 저장속성&#x2F;메서드도 상속)\n클래스(참조 타입)에서만 가능\n\n\n프로토콜의 특징\n클래스에서 벗어난 별도의 규칙\n다중 상속 가능\n필요한 경우 어떤 클래스&#x2F;구조체건 원할 때 상속 가능\n\n\n\n&#x2F;&#x2F; 클래스 상속의 단점\n\nclass Bird &#123;\n\tvar isFemale &#x3D; true\n\n\tfunc layEgg() &#123;\n\t\tif isFemale &#123;\n\t\t\tprint(&quot;새가 알을 낳는다.&quot;)\n\t\t&#125;\n\t&#125;\n\n\tfunc fly() &#123;\n\t\tprint(&quot;새가 하늘로 날아간다.&quot;)\n\t&#125;\n&#125;\n\nclass Eagle: Bird &#123;\n\tfunc soar() &#123;\n\t\tprint(&quot;공중으로 치솟아 난다.&quot;)\n\t&#125;\n&#125;\n\nclass Penguin: Bird &#123;\n\n\t&#x2F;&#x2F; Penguin은 Bird를 상속 받았기 때문에\n\t&#x2F;&#x2F; 자동으로 fly() 메서드를 상속 받는다.\n\t&#x2F;&#x2F; 펭귄은 날지 못하는데...?\n\t&#x2F;&#x2F; func fly()\n\n\tfunc swim() &#123;\n\t\tprint(&quot;헤엄친다.&quot;)\n\t&#125;\n&#125;\n\nclass Airplane: Bird &#123;\n\n\t&#x2F;&#x2F; Airplane 또한 Bird를 상속받았다.\n\t&#x2F;&#x2F; layEgg() 메서드를 상속 받았다.\n\t&#x2F;&#x2F; 비행기가 알을 낳아?\n\t&#x2F;&#x2F; func layEgg()\n\n\toverride func fly() &#123;\n\t\tprint(&quot;비행기가 엔진을 사용하여 날아간다.&quot;)\n\t&#125;\n&#125;\n\n잠깐!\n\n\n\n\n\n\n\n\n그냥 상속받지 말고 새로 만들면 안돼요?\n되기는 하는데, 프로젝트가 커지거나 실무에 들어가면 예제처럼 클래스가 메서드 한두개만 갖지는 않습니다.이미 구현되어 있는 그 많은 메서드들을 재사용하기 위해서 클래스를 새로 만들고 복붙을 한다는 건 너무나 성가시고 낭비도 심합니다.현실적으로 상속을 하는게 맞기 때문에 클래스의 이러한 속성은 단점으로 작용할 때가 꽤 많습니다.\n\n\n\n\n\n\n\n\n\n그러면 fly() 메서드 같이 몇몇 하위 클래스들에겐 필요 없는 메서드들을 분리해서 상속을 하지 않아도 사용할 수는 없나요?\n그것이 바로 오늘의 주인공 프로토콜이 하는 일입니다.\n&#x2F;&#x2F; 프로토콜의 형태\n\nprotocol CanFly &#123; &#x2F;&#x2F; 프로토콜은 구체적인 구현은 하지 않는다.\n\tfunc fly()\n&#125;\n\nstruct Penguin: CanFly &#123; &#x2F;&#x2F; 구조체도 채택 가능\n\tfunc fly() &#123;\n\t\tprint(&quot;날아갑니다.&quot;)\n\t&#125;\n&#125;\n\n프로토콜의 경우 채택을 했는데 포로토콜의 모든 메서드를 구현하지 않으면, 에러를 발생시킵니다. 채택한 프로토콜의 모든 메서드는 구현되어야 합니다!\n한가지 특징이 더 있습니다.프로토콜을 타입처럼 사용할 수 있습니다.\nstruct FlyingMuseum &#123;\n\tfunc flyingDemo(flyingObject: CanFly) &#123;\n\t\tflyingObject.fly()\n\t&#125;\n&#125;\n\n위 예시에서  CanFly의 의미는 CanFly 프로토콜을 채택한 인스턴스를 받는다는 의미입니다.\n프로토콜 문법\n프로토콜에서는 구체적인 구현은 하지 않고 최소 요구사항만을 정의한다.\n클래스의 상위 클래스가 있는 경우, 상위 클래스를 먼저 표기한다.\n\nprotocol MyProtocol &#123;\n\tfunc doSomething() -&gt; Int\n&#125;\n\nclass MyClass &#123; &#125;\n\nclass MySecondClass: MyClass, MyProtocol &#123;\n\tfunc doSomething() -&gt; Int &#123;\n\t\treturn 7\n\t&#125;\n&#125;\n\n속성 요구사항\nvar로만 선언 가능\nget, set 키워드를 통해서 읽기&#x2F;쓰기 가능 여부 설정\n저장속성&#x2F;계산속성 모두 가능\n\nprotocol RemoteMouse &#123;\n\tvar id: String &#123; get &#125; &#x2F;&#x2F; let (get만 가능)\n\tvar name: String &#123; get set &#125;\n\n\t&#x2F;&#x2F; 타입 저장 속성: static\n\t&#x2F;&#x2F; 타입 계산 속성: class\n\tstatic var type: String &#123; get set &#125;\n&#125;\n\nstruct TV: RemoteMouse &#123;\n\tlet id: String &#x3D; 456\n\tvar name: String &#x3D; &quot;Samsung TV&quot;\n\t\n\tstatic var type: String &#x3D; &quot;Remote Control&quot; &#x2F;&#x2F; 재정의 불가능\n\tclass var type: String &#123; &#x2F;&#x2F; 재정의 가능 (클래스에서 채택 시)\n\t\tget &#123; &quot;Remote Control&quot; &#125;\n\t\tset &#123; &#125;\n\t&#125;\n&#125;\n\n메서드 요구사항\n메서드의 헤드 부분만 요구사항으로 정의\nmutating: 구조체에서 저장 속성 변경 시 필요한 키워드\n타입 메서드로 구현 시에는 static만 붙여주면 됨\n채택하는 쪽에서 static, class 선택\n\n\n\n생성자 요구사항\n클래스는 상속을 고려해야 하기 때문에 채택하는 쪽에서 required를 붙여줘야 한다.\n구조체는 상속이 없기 때문에 required 키워드가 필요하지 않다!\n\n\n혹은  final 키워드로 상속을 막으면 필수생성자로 구현하지 않아도 된다.\n클래스일 경우 편의생성자(convenience)로 구현해도 된다.\n\nprotocol SomeProtocol &#123;\n\tinit(num: Int)\n&#125;\n\nclass SomeClass: SomeProtocol &#123;\n\trequired init(num: Int) &#123;\n\t&#125;\n&#125;\n\nclass SomeClass2: SomeClass &#123;\n\t&#x2F;&#x2F; 다른 생성자 구현하지 않을 시 필수생성자 자동 상속\n&#125;\n\nprotocol AProtocol &#123;\n\tinit()\n&#125;\n\nclass ASuperClass &#123;\n\tinit() &#123;\n\t\t\n\t&#125;\n&#125;\n\nclass ASubClass: ASuperClass, Aprotocol &#123;\n\t&#x2F;&#x2F; 상속으로 인한 재정의 키워드 (override)\n\t&#x2F;&#x2F; 프로토콜 채택으로 인한 필수 키워드 (required)\n\trequired override init() &#123;\n\t&#125;\n&#125;\n\n실패가능 생성자일 경우protocol AProtocol &#123;\n\tinit?(num: Int)\n&#125;\n\nstruct AStruct: AProtocol &#123;\n\t&#x2F;&#x2F; 실패가능, 실패불가능, 일반 모두 가능\n\t&#x2F;&#x2F; 범위의 개념!\n\tinit?(num: Int) &#123; &#125;\n\n\tinit(num: Int) &#123; &#125;\n\n\tinit!(num: Int) &#123; &#125;\n&#125;\n\n서브스크립트 요구사항\nget, set을 사용하여 읽기&#x2F;쓰기 여부 설정\n\nprotocol DataList &#123;\n\tsubscript(idx: Int) -&gt; Int &#123; get &#125;\n&#125;\n\nstruct DataStructure: DataList &#123;\n\tsubscript(idx: Int) -&gt; &#123;\n\t\tget &#123;\n\t\t\treturn 0\n\t\t&#125;\n\t&#125;\n&#125;\n\n타입으로써의 프로토콜\n프로토콜은 타입이다…!\n프로토콜을 변수에 할당할 수 있다.\n함수를 호출할 때, 프로토콜을 파라미터로 전달할 수 있다.\n함수에서 프로토콜을 반환할 수 있다.\n\n\n\nprotocol Remote &#123;\n\tfunc turnOn()\n\tfunc turnOff()\n&#125;\n\nclass TV: Remote &#123;\n\tfunc turnOn() &#123;\n\t\tprint(&quot;TV 켜기&quot;)\n\t&#125;\n\n\tfunc turnOff() &#123;\n\t\tprint(&quot;TV 끄기&quot;)\n\t&#125;\n\n\tfunc changeChannel() &#123;\n\t\tprint(&quot;채널 바꾸기&quot;)\n\t&#125;\n&#125;\n\nclass SetTopBox: Remote &#123;\n\tfunc turnOn() &#123; &#125;\n\tfunc turnOff() &#123; &#125;\n\tfunc doNetflix() &#123; &#125;\n&#125;\n\nlet tv: Remote &#x3D; TV()\ntv.turnOn() &#x2F;&#x2F; &quot;TV 켜기&quot;\ntv.turnOff() &#x2F;&#x2F; &quot;TV 끄기&quot;\ntv.changeChannel() &#x2F;&#x2F; Error\nlet sbox: Remote &#x3D; SetTopBox()\n\n타입으로써의 장점같은 프로토콜끼리 묶어서 취급let electronics: [Remote] &#x3D; [tv, sbox]\nfor item in electronics &#123;\n\titem.turnOn()\n&#125;\n\nfunc turnOnElectronics(item: Remote) &#123;\n\titem.turnOff()\n&#125;\n\n프로토콜 준수성 검사\nis: 특정 타입이 프로토콜을 채택하고 있는지 검사\nas: 타입캐스팅\n특정 인스턴스를 프로토콜로 변환, 혹은 프로토콜을 인스턴스 실제 형식으로 캐스팅\n\n\n\nlet newBox &#x3D; sbox as Remote\n\nlet sbox2 &#x3D; electronic[1] as? SetTopBox\nsbox2?.doNetflix()\n\n프로토콜의 상속\n프로토콜도 상속이 가능하다.\n프로토콜을 채택할 때 적용됐던 다중상속도 지원한다.\n\n\n단순하게 요구사항들의 나열들이라고 생각하면 된다.\n\nprotocol Remote &#123;\n\tfunc turnOn()\n\tfunc turnOff()\n&#125;\n\nprotocol AirconRemote &#123;\n\tfunc up()\n\tfunc down()\n&#125;\n\nprotocol SuperRemoteProtocol: Remote, AirconRemote &#123;\n\tfunc remote()\n&#125;\n\nclass HomePod: SuperRemoteProtocol &#123;\n\tfunc turnOn()\n\tfunc turnOff()\n\tfunc up()\n\tfunc down()\n\tfunc remote()\n&#125;\n\n클래스 전용 프로토콜 (AnyObject)\nAnyObject도 프로토콜 중의 하나이다.\n해당 프로토콜은 클래스만 채택할 수 있다.\n\n\n\nprotocol SomeProtocol: AnyObject &#123;\n\t&#x2F;&#x2F; ...\n&#125;\n\n프로토콜의 합성\n하나의 타입으로 여러가지 프로토콜을 채택하는 것\n[Protocol] &amp; [Protocol]\n\nprotocol Named &#123;\n\tvar name: String &#123; get &#125;\n&#125;\n\nprotocol Aged &#123;\n\tvar age: Int &#123; get &#125;\n&#125;\n\nstruct Person: Named, Aged &#123;\n\tvar name: String\n\tvar age: Int\n&#125;\n\nfunc wishHappyBirthday(to celebrator: Named &amp; Aged) &#123;\n\tprint(&quot;HBD, \\(celebrator.name), you&#39;re now \\(celebrator.age) years old.&quot;)\n&#125;\n\n선택적 요구사항 (Optional Protocol Requirements)어트리뷰트 (Attribute)\n@objc: Swift로 작성한 코드를 Obj-C 코드로도 사용할 수 있도록 해주는 어트리뷰트\n\n@objc protocol Remote &#123;\n\t@objc optional var isOn: Bool &#123; get set &#125;\n\tfunc turnOn()\n\tfunc turnOff()\n\t@objc optional func doNetflix()\n&#125;\n\nclass TV: Remote &#123; &#x2F;&#x2F; No Error\n\tfunc turnOn() &#123; &#125;\n\tfunc turnOff() &#123; &#125;\n&#125;\n\n프로토콜의 확장\n프로토콜의 확장을 통해 기본(default) 내용 구현이 가능하다.\n기본(default) 구현이기 때문에 채택한 쪽에서 내용을 구현하면 해당 내용이 우선 적용된다. \n데이터 영역에 만들어진 테이블에 찾아간다.(Witness Table)\n\n\nextension으로 확장된 프로토콜에서 요구 사항으로 정의되지 않은 메서드를 구현하면 타입에 따라 구현된다. \n코드 영역에 있는 코드 주소에 직접 찾아간다.(Direct Dispatch)\n\n\n\nprotocol Remote &#123;\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D; Witness Table &#x3D;&#x3D;&#x3D;\n\tfunc turnOn()\n\tfunc turnOff()\n&#125;\n\nextension Remote &#123;\n\t&#x2F;&#x2F; 요구사항에 선언되어 있기 때문에 채택 시에 구현되지 않으면\n\t&#x2F;&#x2F; 해당 기본 구현 내용을 실행한다.\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D; Witness Table &#x3D;&#x3D;&#x3D;\n\tfunc turnOn() &#123; print(&quot;리모컨 켜기&quot;) &#125;\n\tfunc turnOff() &#123; print(&quot;리모컨 끄기&quot;) &#125;\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\t&#x2F;&#x2F; 요구사항에 선언되어 있지 않기 때문에\n\t&#x2F;&#x2F; 타입에 따라 구현되거나 되지 않는다.\n\t&#x2F;&#x2F; 테이블에 추가되지 않음 (호출 시 직접적으로 주소로 찾아가 실행)\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D; Direct Dispatch &#x3D;&#x3D;&#x3D;\n\tfunc doAnotherAction() &#123;\n\t\tprint(&quot;또 다른 동작&quot;)\n\t&#125;\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#125;\n\n\n\nclass Ipad: Remote &#123;\n\tfunc turnOn() &#123; print(&quot;아이패드 켜기&quot;) &#125;\n\tfunc doAnotherAction() &#123; print(&quot;아이패드 다른 동작&quot;) &#125;\n&#125;\n\n&#x2F;* \n[Ipad Class의 Virtual Table]\n - func turnOn() - print(&quot;아이패드 켜기&quot;)\n - func turnOff() - print(&quot;리모컨 끄기&quot;) -&gt; 기본 구현\n - func doAnotherAction() - print(&quot;아이패드 다른 동작&quot;)\n*&#x2F;\nlet ipad: Ipad &#x3D; Ipad()\nipad.turnOn() &#x2F;&#x2F; &quot;아이패드 켜기&quot;\nipad.turnOff() &#x2F;&#x2F; &quot;리모컨 끄기&quot; -&gt; 기본 구현\nipad.doAnotherAction() &#x2F;&#x2F; &quot;아이패드 다른 동작&quot;\n\nlet ipad2: Remote &#x3D; Ipad()\nipad2.turnOn() &#x2F;&#x2F; &quot;아이패드 켜기&quot;\nipad2.turnOff() &#x2F;&#x2F; &quot;리모컨 끄기&quot; -&gt; 기본 구현\nipad2.doAnotherAction() &#x2F;&#x2F; &quot;또 다른 동작&quot; -&gt; 기본 구현\n\n확장 제한\nSelf: 타입 자기 자신\n특정 프로토콜을 채택한 타입에만 프로토콜 확장이 가능하도록 제한\n\nprotocol Bluetooth &#123;\n\tfunc blueOn()\n\tfunc blueOff()\n&#125;\n\nextension Bluetooth where Self: Remote &#123;\n\tfunc blueOn() &#123; print(&quot;블루투스 켜기&quot;) &#125;\n\tfunc blueOff() &#123; print(&quot;블루투스 끄기&quot;) &#125;\n&#125;\n\nclass SmartPhone: Remote, Bluetooth &#123;\n\t\n&#125;\nlet smartphone: SmartPhone &#x3D; SmartPhone()\nsmartphone.blueOn() &#x2F;&#x2F; &quot;블루투스 켜기&quot;\nsmartphone.blueOff() &#x2F;&#x2F; &quot;블루투스 끄기&quot;\n\n프로토콜 지향 프로그래밍\n애플은 Swift를 “프로토콜 지향 프로그래밍”이라고 소개하고 있다.\n“객체 지향 프로그래밍”의 단점을 보완\n\n\n\n상속의 관점에서 생각해보는 프로토콜\n여러개의 프로토콜 채택 가능 (다중 상속)\n메모리 구조에 대한 특정 요구사항 없음 (@objc optional)\n모든 타입에서 채택 가능 (값타입도 채택 가능)\n타입으로 사용 가능하여 활용성 ⬆️\n구성&#x2F;재사용성 ⬆️\n애플이 이미 만들어둔 데이터타입도 채택하여 활용 가능 (소급적 적용)\n\n","slug":"Allen/2022-10-11-Allen32","date":"2022-10-10T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"00b2e378bc58cce5d9b436f772921098","title":"12)🍎 Swift - Bounds vs Frame","content":"오늘은 frame과 bounds의 실체와 차이점에 대해 공부해볼거에요.두 친구 모두 코드 상에서 UIView에 변경을 가할 때 자주 보게 되는 용어들이죠.근데 지금까지는 그냥 둘 다 써보고 제가 원하던 프로퍼티가 있으면 사용하곤 했습니다.view.bounds.width = 32.0와 같은 작업들이요.\n그래서 두 가지를 공식 문서에서 찾아보았습니다.\n\n\n우선 눈에 띄는 점은 두 가지 모두 CGRect라는 타입으로 정의되어 있다는 점입니다.CGRect 이 친구도 뭔가 아무 생각없이 사용했었는데 제대로 알아본 적은 없네요.그래서 먼저 CGRect에 대해서 알아보겠습니다.\nCGRect일단 반복된 사용으로 인해서 이 아이가 대충 View의 영역을 표현한다는 점은 알고 있습니다. 제공되는 생성자들을 보면\n\ninit(origin: CGPoint, size: CGSize)\ninit(x: Double, y: Double, width: Double, height: Double)\ninit(x: Int, y: Int, Width: Int, height: Int)\ninit(x: CGFloat, y: CGFloat, width: CGFloat, height: CGFloat)이런 식으로 좌표값과 넓이, 높이를 받고 있거든요.\n\n그리고 이제 애플의 설명을 봅시다.\n\n\n\n\n\n\n\n\n\n\nA structure that contains the location and dimensions of a rectangle.\n우선 CGRect는 다른 기본 타입들과 마찬가지로 구조체인 것을 확인할 수 있습니다. 그리고 사각형의 위치와 크기 정보를 지니는 구조체라고 하네요!\n어느정도 감으로 알던 거의 그대로네요. 그리고 Rect는 사각형을 표현하는 작명이였습니다.\n그러면 이제 다 알아냈어요. CGRect는 어떤 한 기준점(origin) 과 크기(size) 를 갖고 사각형을 표현하는 구조체인 것이죠.\n가장 첫 번째 생성자를 보면 CGPoint 타입의 기준점과 CGSize 타입의 크기를 지정해주는 것을 볼 수 있습니다. \n이 두가지에 대해서도 간략하게 살펴보면,\n\nCGPoint: 좌표를 나타내는 타입\nex: (1, 2)\n\n\nCGSize: 크기를 나타내는 타입\nex: 15(width) * 4(height)\n\n\n\n\n사각형은 도형이기 때문에 그림으로 볼 때 가장 이해가 빠르겠죠?위 사진과 같이 기준점(origin)과 그 기준점을 기준으로 사각형을 그릴 크기(size) 값을 갖는 것이 바로 CGRect인 것입니다.쉽게 말하면 CGRect는 “어디에 어떤 크기로 UI 요소를 그리겠다.”를 사각형 영역으로 지정해 줄 때 사용하는 구조체입니다.\n한 가지만 유의하면 될 것 같습니다.width는 기준점을 기준으로 오른쪽이 positive, height는 기준점을 기준으로 아래쪽이 positive입니다.\nframe, bounds이제 다시 돌아가서 frame과 bounds에 대해서 알아보겠습니다.각각의 설명을 한 번 볼까요?\nframe\n\n\n\n\n\n\n\n\nThe frame rectangle, which describes the view’s location and size in its superview’s coordinate system.\nframe은 superview(상위 view)의 좌표 안에서 view의 위치와 크기를 정의합니다.\nbounds\n\n\n\n\n\n\n\n\nThe bounds rectangle, which describes the view’s location and size in its own coordinate system.\nbounds는 본인의 고유한 좌표 안에서 위치와 크기를 정의합니다.\n아직 뜻은 정확하게 모르겠지만 가장 중요한 차이점이 보입니다.frame은 상위 view의 좌표 안에서 CGRect가 정의된다는 것이고, bounds는 고유한 좌표 안에서 CGRect가 정의된다는 것이죠.\n그래도 감이 조금은 오는 frame부터 확인해보겠습니다. \n\n\nFrame이렇게 생긴 화면 구성이 있다고 가정해봅시다.\n“ SuperView ➡️ ParentView ➡ ChildView “의 계층 구조를 갖고 있습니다. 각각의 하위 view는 상위 view에 nested되어 있습니다.\n지금 이 상태에서 ParentView와 ChildView의 frame을 출력하면 어떤 값이 나오는지 한 번 볼게요.\n\nframe은 상위 View 안에서의 CGRect라고 했습니다. 위 출력은 순서대로 x좌표, y좌표, 너비, 높이였죠?\n\n\nParentView의 CGPoint와 CGSize에 수치를 메겨보았습니다. frame은 어느정도 느낌이 오죠?\nParentView의 기준점(origin)이 상위 뷰인 SuperView의 기준점(origin)에서 (24, 186)만큼 떨어져있고, 크기(size)는 (342, 472)라는 것이죠!\nframe의 설명 그대로 해당 View의 상위 View에 대한 좌표값이라는 것을 알 수 있습니다.\n제대로 이해한 것인지 확인하기 위해서 ParentView의 기준점(origin)을 한번 (0, 0)으로 바꿔보았습니다.동시에 크기(size)도 (320, 380)으로 줄여봅시다.\n\n왼쪽이 변경 전, 오른쪽이 변경 후입니다. 잘 보면, Child View는 변한 게 없습니다.절대적인 위치는 Parent View의 위치가 바뀌었기 때문에 같이 바뀐 것이고, 기준점(origin)이나 크기(size)는 그대로 유지되었습니다.ParentView의 CGRect는 당연하게 변경되었습니다. 기준점(origin)의 좌표가 (0, 0)이 되었고, 크기도 (320, 380)으로 줄어들었습니다.\n이제 확실하게 알 것 같습니다! frame은 상위 View에 대한 좌표값이기 때문에 상위 View의 기준점(origin)이 이동하면 함께 이동하는 것이죠.\nBounds이번엔 설명이 조금 모호한 bounds를 알아보겠습니다. 우선 아까 예시를 그대로 가져와서 bounds 값을 찍어보았습니다.\n\n두 View 모두 기준점(origin) 이 (0, 0)이 나오네요..?? 🤔\n네 그렇습니다.. frame과 다르게 bounds는 “본인의 고유한 좌표”라는 말에서 알 수 있듯이 상위 View와는 아무런 관련 없이 갖는 값입니다.\n자 여기까진 알겠고, 그럼 bounds값에 변형을 줘볼까요?self.parentView.bounds.origin = CGPoint(x: 50, y: 100)이렇게 한 번 Parent View의 bounds를 (50, 100)만큼 이동시켜볼게요.\n\n\n음.. ParentView는 가만히 있고, ChildView가 왼쪽 위로 이동했습니다. 🤔🤔🤔\n전혀 모르겠네요. 왜죠..?\nbounds를 이해하기 위해서는 저 화면을 조금 더 넓게 볼 필요가 있습니다.frame이야 저 사각형의 View 자체를 이동시킨 것이 맞습니다.하지만 bounds의 경우에는 View를 움직이는게 아니라 해당 View 안에서 보이는 공간의 좌표를 바꿔준다는 의미입니다.\n네 어렵죠..? (아닌가요? 저만 어렵나요?)\n그러니까 우리가 사진을 확대해서 볼 때 한 점을 찍고 드래그를 하죠?\n\n요 포인터 있잖아요?\n\n이 포인터로 딱 찍은 그 점이 바로 기준점(origin)이라고 생각하고, 그 점을 누르고 오른쪽 아래(50, 100)로 내린겁니다!\n\n그러면 사진은 어떻게 되나요?왼쪽 위로 올라갑니다.\nParentView는 안에 있는 다른 View들을 담고 있는 하나의 또 다른 화면이라고 생각하면 됩니다. 그 화면에서 드래그를 해서 보고 있는 화면을 옮기는 것이죠.\n근데 저게 화면이면, 밖으로 튀어나오면 안되는 거 아닌가요?맞아요. 그래서 튀어나오지 않도록 해줄 수도 있습니다.clipsToBounds라는 어트리뷰트를 true로 해주면\n\n\n이렇게 화면에서 벗어난 View를 잘라서 표현할 수 있습니다.\n자 그런데 위에서 이해를 돕기 위해서 이미지를 확대해서 드래그하는 상황을 예시로 들었었죠?사실 정확히 이 상황을 사용하는 UI 컴포넌트가 하나 있습니다.바로 ScrollView에요.ScrollView에서 드래그를 할 때 사실은 내부적으로 해당 View의 bounds를 계속해서 바꿔주고 있는 겁니다.이런 사실은 ScrollView의 contentOffset을 출력해보면 확인해볼 수 있습니다.\n그런데 혹시 size는 frame과 bounds에서 별 차이가 없어서 언급이 없는건가요?아닙니다. 상당히 큰 차이가 있어요.지금까지 우리는 기준점(origin) 에 초점을 맞춰서 공부했죠?그도 그럴게 두 예시 모두 크기는 동일하게 나왔거든요.그래서 크기는 frame과 bounds가 동일하냐?하면, 그건 또 아닙니다.\n이 차이는 View를 회전시킬 때 확인할 수 있습니다.\n\n\n위와 같이 View 하나를 45도 돌려보았습니다. 이 때의 frame.size와 bounds.size를 출력해보면,\n\n분명 하나의 View의 size인데 두 값이 다르게 나옵니다.\nframe의 경우 View를 감싸고 있는 사각형의 좌표와 크기를 값으로 갖습니다.왜냐면 상위 View에 대한 상대적 좌표이기 때문에 정확히 사각형의 형태이기 때문이죠.반면 bounds는 회전이 됐다면 된 상태 그 모습 그대로의 좌표와 크기를 값으로 갖습니다.본인만의 고유한 좌표계에 대한 값이기 떄문입니다.\n출처: https://stackoverflow.com/questions/1210047/cocoa-whats-the-difference-between-the-frame-and-the-bounds\n사진으로 보면 이해가 매우 빠를 것 같아서 StackOverflow에서 이미지를 하나 가져왔습니다.\n","slug":"Swift/2022-10-11-Swift12","date":"2022-10-10T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"7d9bf124df9a347102a30538e5c15505","title":"29)🧰 Swift - 상속과 다형성","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n상속과 다형성class Person &#123;\n\tvar id &#x3D; 0\n\tvar name &#x3D; &quot;이름&quot;\n\tvar email &#x3D; &quot;abc@gmail.com&quot;\n\n\tfunc walk() &#123;\n\t\tprint(&quot;사람이 걷는다.&quot;)\n\t&#125;\n&#125;\n\nclass Student: Person &#123;\n\tvar studentId &#x3D; 1\n\n\toverride walk() &#123; &#x2F;&#x2F; 재정의 메서드\n\t\tprint(&quot;학생이 걷는다.&quot;)\n\t&#125;\n\n\tfunc study() &#123;\n\t\tprint(&quot;학생이 공부한다.&quot;)\n\t&#125;\n&#125;\n\nlet person &#x3D; Person()\nperson.walk() &#x2F;&#x2F; &quot;사람이 걷는다.&quot;\n\nlet student: Person &#x3D; Student() &#x2F;&#x2F; 업캐스팅\nstudent.walk() &#x2F;&#x2F; &quot;학생이 걷는다.&quot;\n&#x2F;&#x2F; 업캐스팅한 Person의 walk() 메서드가 실행되지 않고\n&#x2F;&#x2F; 원래의 Student의 walk() 메서드가 실행되었다.\n\n다형성(Polymorphism)에 대한 이해\n스택 영역에 인스턴스를 가리키는 변수나 상수가 있다.\n인스턴스는 힙 공간에 캐스팅 이전의 원래의 형태로 저장되어 있다.\n힙 영역의 인스턴스는 데이터 영역에 있는 본인의 클래스를 가리킨다.\n\n다형성 (Polymorphism)\n하나의 인스턴스가 여러가지 형태로 표현될 수 있다.\n하나의 타입을 여러가지 형태로 해석할 수 있다.\n\n\n다향성의 구현은 클래스의 상속과 깊게 연관되어 있다.\n이후 배울 protocol 또한 연관되어 있음\n\n\n\n","slug":"Allen/2022-10-10-Allen29","date":"2022-10-09T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"ef533afe96035326c780dd33d82b0d35","title":"30)🧰 Swift - Any","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nAny와 AnyObject를 위한 타입 캐스팅Any 타입\n기본 타입들을 포함하여 커스텀 클래스, 옵셔널, 구조체, 열거형, 함수 타입 등 모든 타입을 포함하여 어떤 타입도 표현할 수 있는 타입\n저장된 타입의 메모리 구조를 알 수 없음\n타입 캐스팅이 항상 필요\n\n\n\nvar some: Any &#x3D; &quot;Swift&quot;\nsome &#x3D; 10 &#x2F;&#x2F; 에러가 나지 않음!\nsome &#x3D; 3.2\n\nvar someString &#x3D; some as! String\nsomeString.count\n\nvar someString: Any &#x3D; &quot;Swift&quot;\n(someString2 as! String).count\n\n\n모든 타입을 담을 수 있는 배열을 생성할 수 있다.\n\nlet array: [Any] &#x3D; [5, &quot;Hi&quot;, 3.5, Person(), &#123;(name: String) in return name&#125;]\n(array[1] as! String).count\n\nAnyObject 타입\n클래스 인스턴스만 담을 수 있는 타입\n\nlet objArray: [AnyObject] &#x3D; [Person(), Superman(), NSString()]\n(objArray[0] as! Person).name &#x3D; &quot;최영철&quot;\n\n타입캐스팅에 따른 분기 처리for (index, item) in array.enumerated() &#123;\n\tswitch item &#123;\n\tcase is Int:\n\t\tprint(&quot;Index \\(index): 정수입니다.&quot;)\n\t&#125;\n\tcase let num as Double:\n\t\tprint(&quot;Index \\(index): 소수 \\(num)입니다.&quot;)\n\tcase let person as Person:\n\t\tprint(&quot;Index \\(person): 사람입니다.&quot;)\n\t\tprint(&quot;이름은 \\(person.name)입니다.&quot;)\n\tcase is (String) -&gt; String:\n\t\tprint(&quot;Index \\(index): 클로저 타입입니다.&quot;)\n\tdefault:\n\t\tprint(&quot;Index \\(index): 그 외의 타입입니다.&quot;)\n&#125;\n","slug":"Allen/2022-10-10-Allen30","date":"2022-10-09T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"292d583f42b056cdd5b64c3d16288af9","title":"31)🧰 Swift - 확장 (Extension)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n확장 (Extension)\n현재 존재하는 타입에 기능(메서드)를 추가하여 사용\nSwift에서는 확장에서 정의한 메서드에 대한 재정의 불가\n본체에 대한 재정의도 불가\n\n상속과의 차이점\n상속(Inheritance): 수직 확장\n성격이 비슷한 타입을 새로 만드는 것\n저장속성을 추가하거나\n메서드를 변형시켜 사용\n\n\n\n\n확장(Extension): 수평 확장\n현재 존재하는 타입에 메서드를 추가하는 것\n저장속성의 추가는 불가\n\n\n\n\n\n예시class Person &#123;\n\tvar id &#x3D; 0\n\tvar name &#x3D; &quot;이름&quot;\n\tvar email &#x3D; &quot;123@gmail.com&quot;\n\n\tfunc walk() &#123;\n\t\tprint(&quot;사람이 걷는다.&quot;)\n\t&#125;\n&#125;\n\nclass Student: Person &#123;\n\tvar studentId &#x3D; 1\n\n\toverride func walk() &#123;\n\t\tprint(&quot;학생이 걷는다.&quot;)\n\t&#125;\n&#125;\n\nlet student &#x3D; Student()\nstudent.play() &#x2F;&#x2F; &quot;학생이 논다.&quot;\n&#x2F;&#x2F; extension이 뒤에 있어도 가능\n\nextension Student &#123;\n\tfunc play() &#123;\n\t\tprint(&quot;학생이 논다.&quot;)\n\t&#125;\n&#125;\n\nlet student2 &#x3D; Student()\nstudent2.play() &#x2F;&#x2F; &quot;학생이 논다.&quot;\n\n상속&#x2F;확장과 메모리 구조\n확장은 메서드 테이블 외의 공간에 메서드를 추가하는 동작\n따라서 확장하여 정의된 메서드는 상속은 되지만 재정의는 되지 않는다.\n@objc 키워드를 메서드 앞에 붙이면 재정의도 가능은 하다.\nObj-C에서는 가능하기 때문!\n\n\n\n확장의 장점\n애플이 구현해둔 기능들에  나만의 기능을 추가할 수 있다…!\nInt, UIViewController, UIColor 등\n\nextension Int &#123;\n\tvar squared: Int &#123;\n\t\treturn self * self\n\t&#125;\n&#125;\n\nprint(5.squared) &#x2F;&#x2F; 25\n\n확장 가능한 멤버\n기본적으로 메서드의 형태는 모두 가능하다고 보면 된다.\n\n\n계산 속성\n메서드\n새로운 생성자\n클래스의 경우 편의생성자만 추가 가능, 지정생성자&#x2F;소멸자는 본체에 구현\n\n\n서브스크립트\n새로운 중첩 타입 정의 및 사용\n프로토콜 채택 및 프로토콜 관련 메서드\n\n계산 속성타입 계산 속성 (static)extension Double &#123;\n\tstatic var zero: Double &#123; return 0.0 &#125;\n&#125;\nprint(Double.zero) &#x2F;&#x2F; 0.0\n\n인스턴스 계산 속성extension Double &#123;\n\tvar km: Double &#123; return self * 1000.0 &#125;\n\tvar m: Double &#123; return self &#125;\n\tvar cm: Double &#123; return self &#x2F; 100.0 &#125;\n\tvar mm: Double &#123; return self &#x2F; 1000.0&#125;\n\tvar ft: Double &#123; return self &#x2F; 3.28084 &#125;\n&#125;\n\n10.0.km &#x2F;&#x2F; 10000\n\n메서드타입 메서드 (static)Int.random(in: 1...100)\n\nextension Int &#123;\n\tstatic func prinNumbersFrom1to5() &#123;\n\t\tfor i in 1...5 &#123;\n\t\t\tprint(i)\n\t\t&#125;\n\t&#125;\n&#125;\n\nInt.printNumbersFrom1to5() &#x2F;&#x2F; 1 2 3 4 5\n\n인스턴스 메서드extension String &#123;\n\tfunc printHelloRepetitions(of times: Int) &#123;\n\t\tfor _ in 0..&lt;times &#123;\n\t\t\tprint(&quot;Hello \\(self)!&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\n&quot;Steve&quot;.printHelloRepetitions(of: 4)\n&#x2F;&#x2F; &quot;Hello Steve!&quot;\n&#x2F;&#x2F; &quot;Hello Steve!&quot;\n&#x2F;&#x2F; &quot;Hello Steve!&quot;\n&#x2F;&#x2F; &quot;Hello Steve!&quot;\n\nmutating 인스턴스 메서드extension Int &#123;\n\tmutating func square() &#123;\n\t\tself &#x3D; self * self\n\t&#125;\n&#125;\n\nvar someInt &#x3D; 3\nsomeInt.square()\nprint(someInt) &#x2F;&#x2F; 9\n\n생성자클래스\n클래스의 경우 편의생성자만 추가 가능\n\nUIColor(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)\n\nextension UIColor &#123;\n\tconvenience init(color: CGFloat) &#123;\n\t\tself.init(red: color&#x2F;255, green: color&#x2F;255, blue: color&#x2F;255, alpha: 1)\n\t&#125;\n&#125;\n\nUIColor.init(color: 1)\n\n구조체struct Dog &#123;\n\tvar name: String &#x3D; &quot;&quot;\n\tvar weight: Int &#x3D; 0\n\tvar height: Int &#x3D; 0\n&#125;\n\nextension Dog &#123;\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 3개의 생성자를 사용할 수 있다.\n&#x2F;&#x2F; 원칙적으로 개발자가 생성자를 정의해주었으니\n&#x2F;&#x2F; 아래의 예시처럼\n&#x2F;&#x2F; 기본생성자인 Dog()와 \n&#x2F;&#x2F; 멤버와이즈 생성자인 Dog(name:,weight:,height:)는 제공이 되지 않아야 한다.\nDog()\nDog(name: String)\nDog(name: String, weight: Int, height: Int)\n\nstruct Dog &#123;\n\tvar name: String &#x3D; &quot;&quot;\n\tvar weight: Int &#x3D; 0\n\tvar height: Int &#x3D; 0\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 개발자가 정의한 생성자만 제공된다.\nDog(name: String)\n\n서브스크립트extension Int &#123;\n\t&#x2F;&#x2F; n 자리의 십진수 반환하도록 하는 서브스크립트\n\tsubscript(digitIndex: Int) -&gt; Int &#123;\n\t\tvar decimalBase &#x3D; 1\n\t\tfor _ in 0..&lt;digitIndex &#123;\n\t\t\tdecimalBase *&#x3D; 10\n\t\t&#125;\n\t\treturn (self &#x2F; decimalBase)  % 10\n\t&#125;\n&#125;\n\n746381295[0] &#x2F;&#x2F; 5\n746381295[1] &#x2F;&#x2F; 9\n746381295[2] &#x2F;&#x2F; 2\n746381295[3] &#x2F;&#x2F; 1\n\n중첩 타입 (Nested Types)\n중첩 타입이란?\n연관이 너무 깊은 타입일 경우 하나의 타입 안에 다른 타입을 정의 가능\n\n\n\nclass Day &#123;\n\tenum Weekday &#123;\n\t\tcase mon\n\t\tcase tue\n\t\tcase wed\n\t&#125;\n\n\tvar day: Weekday &#x3D; .mon\n&#125;\n\nvar ddd: Day.Weekday &#x3D; Day.Weekday.mon\n\nextension Int &#123;\n\tenum Kind &#123;\n\t\tcase negative, zero, positive\n\t&#125;\n\n\tvar kind: Kind &#123;\n\t\tswitch self &#123;\n\t\tcase 0:\n\t\t\treturn .zero\n\t\tcase let x where x &gt; 0:\n\t\t\treturn .positive\n\t\tcase let x where x &lt; 0:\n\t\t\treturn .negative\n\t\t&#125;\n\t&#125;\n&#125;\n\nlet a &#x3D; 1\nprint(a.kind) &#x2F;&#x2F; &quot;positive&quot;\n","slug":"Allen/2022-10-10-Allen31","date":"2022-10-09T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"f95356eadf2eace8ae678d705c540cf0","title":"28)🧰 Swift - 타입 캐스팅 (Type Casting)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n타입 캐스팅 (Type Casting)is 연산자 (Type Check Operator)\n타입에 대한 검사를 수행하는 연산자\n[instance] is [type]\n참: true\n거짓: false\n\n\n\nclass Person &#123;\n\tvar id &#x3D; 0\n\tvar name &#x3D; &quot;이름&quot;\n\tvar email &#x3D; &quot;abc@gmail.com&quot;\n&#125;\n\nclass Student: Person &#123;\n\tvar grade &#x3D; 1\n&#125;\n\nclass Undergraduate: Student &#123;\n\tvar major &#x3D; &quot;Alchemy&quot;\n&#125;\n\nlet person &#x3D; Person()\nprint(person is Person) &#x2F;&#x2F; true\nprint(person is Student) &#x2F;&#x2F; false\n\nlet student &#x3D; Student()\nprint(student is Person) &#x2F;&#x2F; true\nprint(student is Student) &#x2F;&#x2F; true\n\n상위 타입의 인스턴스들이 하위 타입의 인스턴스에 포함되는 것을 알 수 있습니다. 상속을 받았기 때문에 당연한 이야기이죠..!\nas 연산자 (Type Cast Operator)\n인스턴스 타입의 메모리 구조에 대한 힌트 정보를 변경하는 연산자\nas, as?, as!\nas: 업캐스팅(Upcasting)\n항상 성공\n상위 클래스의 메모리 구조로 인식\n\n\nas?, as!: 다운캐스팅(Downcasting)\nas?\n성공: Optional 타입으로 리턴\n실패: nil 리턴\n\n\nas!\n성공: Optional 타입을 강제 언래핑하여 리턴\n실패: 런타임 에러\n\n\n\n\n\n\n\nlet person: Person &#x3D; Undergraduate()\nprint(person.id)\nprint(person.name)\nprint(person.email)\nprint(person.grade) &#x2F;&#x2F; Error: Value of &#39;Person&#39; has no member &#39;grade&#39;\nprint(person.major) &#x2F;&#x2F; Error: Value of &#39;Person&#39; has no member &#39;major&#39;\n\n위 예시에서 person 상수는 사실은 5개의 모든 저장속성을 갖고 있습니다. 다만 이 경우에는 Person으로 캐스팅 했기 떄문에 grade와 major 저장속성을 숨겨서 Person의 세 개의 저장속성에만 접근할 수 있습니다.\n그런데 메모리 관점에서 어떻게 저장속성을 숨기느냐..?변수는 스택 영역에 있습니다. 인스턴스는 힙 영역에 있죠. 어떻게 캐스팅을 하던 인스턴스는 처음에 초기화한 형태 그대로 힙 영역에 있습니다.그런데 업캐스팅한 변수를 선언하면, 그 변수는 힙 영역의 캐스팅 하기 전의 온전한 형태를 갖고 있는 인스턴스의 주소를 가리킵니다. 대신 범위를 제한하여 특정 저장속성들을 숨길 수 있는 것입니다.따라서 업캐스팅을 하던 다운캐스팅을 하던 힙 영역의 인스턴스는 동일한 데이터 영역의 클래스 주소를 가리키고 있습니다.\nif let jake &#x3D; person as? Undergraduate &#123; &#x2F;&#x2F; Unbind Optional\n\tjake.name &#x3D; &quot;Jake&quot;\n\tjake.major &#x3D; &quot;Architecture&quot;\n&#125;\n\nlet jane &#x3D; person as! Undergraduate\n\n위 예시의 경우에는 person 상수를 처음에 Undergraduate()로 가장 하위 클래스로 업캐스팅 했기 때문에 반대로 다운캐스팅할 때 에러가 발생하지 않습니다.그런데 let jake = Person()처럼 상위 클래스로 초기화하고 as?나 as!를 사용해서 다운캐스팅을 하면 Student와 Undergraduate 클래스의 저장속성은 지니지 않기 때문에 실패합니다.\nas 연산자의 활용String &lt;-as-&gt; NSString\n\nSwift 언어는 내부적으로는 여전히 Obj-C 기반의 프레임워크를 사용하기 때문에 두 타입은 상호 호환될 수 있도록 설계되어 있다.\n브릿징(Bridging)\n\nlet str: String &#x3D; &quot;Hello&quot;\nlet anotherStr &#x3D; str as NSString\n","slug":"Allen/2022-10-05-Allen28","date":"2022-10-04T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"22daca62ba0b2c7a54e541387d33eedd","title":"27)🧰 Swift - 소멸자(deinit)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n소멸자\n인스턴스가 메모리에서 해제되기 직전 처리되는 내용을 구현하는 메서드\n클래스에는 최대 1개의 소멸자만 정의 가능\n파라미터 사용하지 않음\n소멸자는 모든 속성에 접근할 수 있다.\n기본적으로 Swift는 ARC를 통해 자동으로 소멸자를 호출한다.\n\nclass Aclass &#123;\n\tvar x &#x3D; 0\n\tvar y &#x3D; 0\n\n\tdeinit &#123;\n\t\tprint(&quot;인스턴스 소멸 시점&quot;)\n\t&#125;\n&#125;\n\nvar a: Aclass? &#x3D; Aclass()\na &#x3D; nil &#x2F;&#x2F; &quot;인스턴스 소멸 시점&quot;\n\n상속일 때의 문법\n상위클래스 소멸자는 하위클래스에 의해 상속\n상위클래스 소멸자는 하위클래스 소멸자의 구현이 끝날 때 자동으로 호출\n상위클래스 소멸자는 하위클래스가 자체적인 소멸자를 제공하지 않더라도 항상 호출\n\n","slug":"Allen/2022-10-03-Allen27","date":"2022-10-02T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"b634a4054ae5c0257e715086c4d854c8","title":"26)🧰 Swift - 생성자(Init)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n초기화와 생성자초기화 (Initialization)\n클래스, 구조체, 열거형의 인스턴스를 생성하는 과정\n각 저장 속성에 대한 초기값 설정\n인스턴스를 사용 가능한 상태로 만드는 과정\n\n생성자 (Initializer)\n인스턴스의 모든 저장 속성이 초기값을 갖도록 하는 메서드\n컴파일러는 기본 생성자(init())을 자동으로 생성하지만, 개발자가 직접적으로 생성자를 구현하면 자동으로 생성되지 않는다.\n소멸자\n인스턴스가 해제되게 전에 수행하는 작업들을 정의한 메서드\n\n\n\nclass Color &#123;\n\tlet red: Double\n\tlet green: Double\n\tlet blue: Double\n\n\tinit() &#123; &#x2F;&#x2F; 기본 생성자, 저장 속성의 기본값을 설정하면 자동 구현\n\t\tred &#x3D; 0.0\n\t\tgreen &#x3D; 0.0\n\t\tblue &#x3D; 0.0\n\t&#125;\n\t&#x2F;&#x2F; 저장 속성 기본값 예시) let red: Double &#x3D; 1.0\n\n\t&#x2F;&#x2F; 생성자 오버로딩 가능\n\tinit(white: Double) &#123;\n\t\tred &#x3D; white\n\t\tgreen &#x3D; white\n\t\tblue &#x3D; white\n\t&#125;\n\n\tinit(red: Double, green: Double, blue: Double) &#123;\n\t\tself.red &#x3D; red\n\t\tself.green &#x3D; green\n\t\tself.blue &#x3D; blue\n\t&#125;\n&#125;\n\n초기화의 경우의 수\n저장 속성의 선언과 동시에 값을 저장하여 초기화\n저장 속성을 옵셔널로 선언하여 nil로 초기화\n생성자에서 값을 초기화\n\n멤버와이즈 생성자 (Memberwise Initializer)\n구조체의 특별한 생성자\n저장 속성들이 기본값을 갖고 있더라도 자동으로 제공\n\nstruct Color &#123; &#x2F;&#x2F; No Error\n\tvar red: Double &#x3D; 1.0\n\tvar green: Double &#x3D; 1.0\n\tvar blue: Double\n&#125;\n\nvar b &#x3D; Color(blue: Double)\nvar c &#x3D; Color(red: Double, green: Double, blue: Double)\n\n구조체&#x2F;클래스의 생성자구조체 지정생성자\n코드의 중복 없이 다른 생성자를 호출하여 초기화 가능\n\nstruct Color &#123;\n\tlet red, green, blue: Double\n\n\tinit() &#123;\n\t\t&#x2F;&#x2F; 맨 아래의 init 호출\n\t\tself.init(red: 0.0, green: 0.0, blue: 0.0)\n\t&#125;\n\n\tinit(white: Double) &#123;\n\t\tself.init(red: white, green: white, blue: white)\n\t&#125;\n\n\tinit(red: Double, green: Double, blue: Double) &#123;\n\t\tself.red &#x3D; red\n\t\tself.green &#x3D; green\n\t\tself.blue &#x3D; blue\n\t&#125;\n&#125;\n\n클래스 지정&#x2F;편의 생성자\n지정생성자 (Designated Initializer)\n일반적인 생성자 (init())\n\n\n편의생성자 (Convenience Initializer)\n다른 지정&#x2F;편의생성자를 호출하는 생성자 (convenience init())\n클래스에만 있는 생성자 (상속과 관련됨)\n클래스는 상속을 지원하며 변수가 여러개인 경우가 많다.\n여러 지정생성자의 사용은 개발자의 실수를 유발한다.\n초기화 과정을 간편하게 하는 생성자\n상속 관계에서 개발자가 실수할 가능성을 배제하기 위한 생성자\n\n\n\n\n\nclass Color &#123;\n\tlet red, green, blue: Double\n\n\tconvenience init() &#123;\n\t\tself.init(red: 0.0, green: 0.0, blue: 0.0)\n\t&#125;\n\n\tconvenience init(white: Double) &#123;\n\t\tself.init(red: white, green: white, blue: white)\n\t&#125;\n\n\tinit(red: Double, green: Double, blue: Double) &#123;\n\t\tself.red &#x3D; red\n\t\tself.green &#x3D; green\n\t\tself.blue &#x3D; blue\n\t&#125;\n&#125;\n\n생성자 위임 규칙\n델리게이트 업 (Delegate Up)\n서브 클래스의 지정생성자는 슈퍼 클래스의 지정생성자를 반드시 호출해야 한다.\n\n\n델리게이트 어크로스 (Delegate Across)\n편의생성자는 동일한 클래스의 다른 편의생성자 또는 지정생성자를 호출해야하고, 궁극적으로는 지정생성자를 호출해야 한다.\n\n\n\n상속 관계에서 생성자 호출과정의 메모리 구조\n객체의 초기화 단계에서 convenience init() 편의생성자가 호출된다.\nconvenience init() 편의생성자에서 동일한 클래스의 init() 지정생성자을 호출한다.\ninit() 지정생성자가 슈퍼 클래스의 super.init() 지정생성자를 호출한다.\n생성자의 호출 과정에서 속성 값들은 힙 영역에 빈 공간을 찾아 저장된다.\n해당 과정에 의해 구조체보다 클래스의 초기화에 비교적 오랜 시간이 걸린다.\n\n\n\n클래스 상속 예시class Aclass &#123;\n\tvar x: Int\n\tvar y: Int\n\n\tinit(x: Int, y: Int) &#123;\n\t\tself.x &#x3D; x\n\t\tself.y &#x3D; y\n\t&#125;\n\n\tconvenience init() &#123;\n\t\tself.init(x: 0, y: 0)\n\t&#125;\n&#125;\n\nclass Bclass: Aclass &#123;\n\tvar z: Int\n\n\t&#x2F;&#x2F; 상속 받을 때 있어야하는 지정생성자\n\tinit(x: Int, y: Int, z: Int) &#123;\n\t\tself.z &#x3D; z &#x2F;&#x2F; 새로운 저장 속성값 초기화\n\t\t&#x2F;&#x2F; self.y &#x3D; y &#x2F;&#x2F; Error (생성자 호출 전)\n\t\tsuper.init(x: x, y: y) &#x2F;&#x2F; 상위의 지정생성자 호출\n\t&#125;\n\n\tconvenience init(z: Int) &#123;\n\t\tself.init(x: 0, y: 0, z: z)\n\t&#125;\n\n\tconvenience init() &#123;\n\t\tself.init(z: 0)\n\t&#125;\n\n\tfunc doSomething() &#123;\n\t\tprint(&quot;Do Something&quot;)\n\t&#125;\n&#125;\n\n상속과 재정의 규칙생성자\n생성자는 기본적으로 상속되지 않고 재정의하는 것이 원칙\n재정의: 동일한 이름의 생성자를 구현하는 것\n하위클래스에 최적화가 되어있지 않기 때문\n\n\n상위의 지정생성자와 현재 단계의 저장 속성을 고려해서 구현\n\n상위 생성자에 대한 고려\n상위에 어떤 생성자가 존재하는가?\n상위에 지정생성자가 있다면\n하위 클래스에서 지정생성자로 구현 (재정의)\n하위 클래스에서 편의생성자로 구현 (재정의)\n구현하지 않아도 됨\n\n\n상위에 편의생성자가 있다면\n구현하지 않아도 됨 (호출 불가가 원칙)\n같은 이름의 생성자를 구현했다면 단순하게 새로 정의한 것\n\n\n\n현재 단계의 생성자 구현\n지정생성자 내에서\n현재 단계의 모든 저장 속성을 초기화해야함\n슈퍼 클래스의 지정생성자를 호출해야함\n\n\n편의생성자 내에서\n현재 클래스의 지정생성자를 호출해야함 (편의생성자를 거치는 것은 상관X)\n\n\n\n생성자 상속의 예외사항지정생성자 자동상속\n새 저장 속성이 아예 없거나, 기본값이 설정되어 있다면 지정생성자의 자동 상속\n초기화  과정에서 실패 가능성이 없기 때문\n\n\n\n편의생성자 자동상속\n지정생성자를 자동상속하는 경우\n바로 위의 경우 (지정생성자를 자동상속하는 경우, 편의생성자까지 함께 자동상속)\n\n\n상위 지정생성자를 모두 재정의하여 구현\n초기화 과정에서 실패 가능성이 없기 때문\n\n\n\nclass Food &#123;\n\tvar name: String\n\n\tinit(name: String) &#123; &#x2F;&#x2F; 지정생성자\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tconvenience init() &#123; &#x2F;&#x2F; 편의생성자\n\t\tself.init(name: &quot;[Unnamed]&quot;)\n\t&#125;\n&#125;\n\nlet namedMeat &#x3D; Food(name: &quot;Bacon&quot;)\nlet mysteryMeat &#x3D; Food()\n\nclass RecipeIngredient: Food &#123;\n\tvar quantity: Int\n\n\tinit(name: String, quantity: Int) &#123;\n\t\tself.quantity &#x3D; quantity\n\t\tsuper.init(name: name)\n\t&#125;\n\n\t&#x2F;&#x2F; 상위 지정생성자를 편의생성자로 재정의\n\toverride convenience init(name: String) &#123;\n\t\tself.init(name: name, quantity: 1)\n\t&#125;\n\n\t&#x2F;&#x2F; convenience init() &#123; &#125; &#x2F;&#x2F; 자동 상속\n\n\t&#x2F;&#x2F; convenience init() -&gt; override convenience init(name: String) -&gt; init(name: String, quantity: Int)\n&#125;\n\nclass ShoppingListItem: RecipeIngredient &#123;\n\tvar purchased &#x3D; false &#x2F;&#x2F; 기본값\n\n\tvar subtitle: String &#123;\n\t\tvar output &#x3D; &quot;\\(quantity) x \\(name)&quot;\n\t\toutput +&#x3D; purchased ? &quot;✔&quot; : &quot;✖️&quot;\n\t\treturn output\n\t&#125;\n\n\t&#x2F;&#x2F; 지정생성자 모두 자동 상속\n\t&#x2F;&#x2F; init(name: String, quantity: Int) &#123; &#125;\n\n\t&#x2F;&#x2F; 편의생성자도 모두 자동 상속\n\t&#x2F;&#x2F; convenience init(name: String) &#123; &#125;\n\t&#x2F;&#x2F; convenience init() &#123; &#125;\n&#125;\n\n예시1class Aclass &#123;\n\tvar x &#x3D; 0\n&#125;\n\nclass Bclass: Aclass &#123;\n\tvar y: Int\n\n\t&#x2F;&#x2F; 지정생성자로 재정의\n\toverride init()\n\t\tself.y &#x3D; 0\n\t\tsuper.init() &#x2F;&#x2F; super.init\n\t&#125;\n\n\t&#x2F;&#x2F; 서브클래스에서 편의생성자로 구현\n\toverride convenience init() &#123;\n\t\tself.init(y: 0) &#x2F;&#x2F; self.init\n\t&#125;\n\n\t&#x2F;&#x2F; 재정의하지 않을 수 있음\n\n\t&#x2F;&#x2F; 현재 단계의 생성자 구현\n\tinit(y: Int) &#123;\n\t\tself.y &#x3D; y\n\t\tsuper.init()\n\t&#125;\n&#125;\n\nclass Cclass: Bclass &#123;\n\tvar z: Int\n\n\toverride init() &#123;\n\t\tself.z &#x3D; 0\n\t\tsuper.init()\n\t&#125;\n\n\toverride init(y: Int) &#123;\n\t\tself.z &#x3D; 0\n\t\tsuper.init(y: y)\n\t&#125;\n\n\tinit(z: Int) &#123;\n\t\tself.z &#x3D; z\n\t\tsuper.init()\n\t&#125;\n&#125;\n\n예시2class Vehicle &#123;\n\tvar numberOfWheels &#x3D; 0\n\n\tvar subtitle: String &#123;\n\t\treturn &quot;\\(numberOfWheels) wheel(s)&quot;\n\t&#125;\n\n\t&#x2F;&#x2F; init() &#123; &#125;\n&#125;\n\nclass Bicycle: Vehicle &#123;\n\toverride init() &#123;\n\t\tsuper.init()\n\t\tnumberOfWheels &#x3D; 2\n\t&#125;\n&#125;\n\nclass Hoverboard: Vehicle &#123;\n\tvar color: String\n\n\toverride var subtitle: String &#123;\n\t\treturn &quot;\\(super.subtitle) in a beautiful \\(color)&quot;\n\t&#125;\n\n\t&#x2F;&#x2F; 저장속성이 있기 때문에 지정생성자 필수\n\tinit(color: String) &#123;\n\t\tself.color &#x3D; color\n\t\tsuper.init()\n\t&#125;\n&#125;\n\n필수생성자\nrequired\n하위생성자는 반드시 필수생성자를 구현해야 한다.\n하위 클래스에서 필수생성자를 구현할 때는 override 키워드 대신 required 키워드로 대체\n필수생성자 자동 상속 조건\n다른 지정생성자를 구현하지 않으면 자동 상속\n\n\n\nclass Aclass &#123;\n\tvar x: Int\n\n\trequired init(x: Int) &#123;\n\t\tself.x &#x3D; x\n\t&#125;\n&#125;\n\nclass Bclass: Aclass &#123;\n\t&#x2F;&#x2F; 자동 상속\n\t&#x2F;&#x2F; required init(x: Int) &#123;\n\t&#x2F;&#x2F; \tself.x &#x3D; x\n\t&#x2F;&#x2F; &#125;\n&#125;\n\nclass Cclass: Aclass &#123;\n\t&#x2F;&#x2F; 생성자를 구현하려면\n\tinit() &#123;\n\t\tsuper.init(x: 8)\n\t&#125;\n\n\t&#x2F;&#x2F; 필수생성자를 구현해야한다.\n\trequired init(x: Int) &#123;\n\t\tsuper.init(x: x)\n\t&#125;\n&#125;\n\n사용 예시\n필수생성자는 보통 애플이 만들어놓은 프레임워크를 개발자가 사용할 때 이용된다.\n\nUIViewclass AView: UIView &#123;\n\trequired init?(coder: NSCoder) &#123; &#x2F;&#x2F; 구현을 안해도 자동 상속\n\t\tfatalError(&quot;init(coder:) has not been implemented&quot;)\n\t&#125;\n&#125;\n\nclass BView: UIView &#123;\n\toverride init(frame: CGRect) &#123;\n\t\tsuper.init(frame: frame)\n\t&#125;\n\n\trequired init?(coder: NSCoder) &#123;\n\t\tfatalError(&quot;init(coder:) has not been implemented&quot;)\n\t&#125;\n&#125;\n\n실패가능 생성자 (Failable)\n인스턴스 생성에 실패할 수도 있는 가능성을 가진 생성자\n실패가 나서 앱이 먹통되는 것보단 예외처리를 하는 편이..\n\n\n동일한 파라미터를 취급하는 생성자는 실패가능 생성자 단 하나여야 한다!\ninit?()\n\nstruct Animal &#123;\n\tlet species: String\n\n\tinit?(species: String) &#123; &#x2F;&#x2F; &#x3D;&#x3D; -&gt; Animal?\n\t\tif species.isEmpty &#123; &#x2F;&#x2F; 문자열이 비어있는 경우 &#x3D;&#x3D; &quot;&quot;\n\t\t\treturn nil\n\t\t&#125;\n\t\tself.species &#x3D; species\n\t&#125;\n&#125;\n\nlet a &#x3D; Animal(species: &quot;Giraffe&quot;)\nlet b &#x3D; Animal(species: &quot;&quot;)\n\n열거형의 실패가능 생성자 활용\n원시값을 통해서 구현하는 것과 유사\n\nenum TemperatureUnit &#123;\n\tcase kelvin\n\tcase celsius\n\tcase fahrenheit\n\n\tinit?(symbol: Character) &#123;\n\t\tswitch symbol &#123;\n\t\tcase &quot;K&quot;:\n\t\t\tself &#x3D; TemperatureUnit.kelvin\n\t\tcase &quot;C&quot;:\n\t\t\tself &#x3D; TemperatureUnit.celsius\n\t\tcase &quot;F&quot;:\n\t\t\tself &#x3D; TemperatureUnit.fahrenheit\n\t\tdefault:\n\t\t\treturn nil\n\t\t&#125;\n\t&#125;\n&#125;\n\nlet c: TemperatureUnit &#x3D; TemperatureUnit.celsius\nlet f: TemperatureUnit? &#x3D; TemperatureUnit(symbol: &quot;F&quot;)\n\n초기화 실패의 전달 (호출관계)\n실패가능 생성자는 다른 실패가능 생성자를 호출할 수 없다.\n\n동일단계 (Delegate Across)\n실패가능 생성자는 실패불가능 생성자를 호출할 수 있다.\n반대로 실패불가능 생성자는 실패가능 생성자를 호출할 수 없다.\n실패가능 생성자는 nil을 포함하기 때문에 실패불가능 생성자보다 범위가 크기 때문!\n\nstruct Item &#123;\n\tvar name &#x3D; &quot;&quot;\n\n\t&#x2F;&#x2F; 1. 실패가능 생성자가 실패불가능 생성자 호출\n\tinit() &#123;\n\t&#125;\n\n\tinit?(name: String) &#123;\n\t\tself.init()\n\t&#125;\n\n\t&#x2F;&#x2F; 2. 실패불가능 생성자가 실패가능 생성자 호출 \n\t&#x2F;&#x2F; Error: Non-failable initializer cannot delegate to failable initializer &#39;init(name:)&#39; written with &#39;init?&#39;\n\tinit() &#123;\n\t\tself.init(name: &quot;하이&quot;)\n\t&#125;\n\n\tinit?(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\nclass Product &#123;\n\tlet name: String\n\tinit?(name: String) &#123;\n\t\tif name.isEmpty &#123; return nil &#125;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\nclass CartItem: Product &#123;\n\tlet quantity: Int\n\tinit?(name: String, quantity: Int) &#123;\n\t\tif quantity &lt; 1 &#123; return nil &#125;\n\t\tself.quantity &#x3D; quantity\n\t\tsuper.init(name: name)\n\t&#125;\n&#125;\n\nif let twoSocks &#x3D; CartItem(name: &quot;sock&quot;, quantity: 2) &#123;\n\tprint(&quot;아이템: \\(twoSocks.name), 수량: \\(twoSocks.quantity)&quot;)\n&#125;\nif let zeroShirts &#x3D; CartItem(name: &quot;shirt&quot;, quantity: 0) &#123;\n\tprint(&quot;아이템: \\(zeroShirt.name), 수량: \\(zeroShirt.quantity)&quot;)\n&#125; else &#123;\n\tprint(&quot;zero shirts를 초기화 불가 (개수가 없음)&quot;)\n&#125;\n\n상속관계 (Delegate Up)\n실패불가능 생성자에서 상위 클래스의 실패가능 생성자를 호출할 수 없다.\n실패가능 생성자에서 상위 클래스의 실패불가능 생성자를 호출하는 것은 가능하다.\n\n상속관계에서 재정의하기\n상위에서 실패가능 생성자를 하위에서 실패불가능 생성자로 재정의하는 것은 가능하다.\n강제 언래핑 또한 사용 가능하다.\n\n\n상위에서 실패불가능 생성자를 하위에서 실패가능 생성자로 재정의하는 것은 불가능하다.\n마찬가지로 실패가능 생성자가 실패불가능 생성자보다 넓은 범위이기 때문!\n\nclass Document &#123;\n\tvar name: String?\n\n\tinit() &#123; &#125;\n\n\tinit?(name: String) &#123;\n\t\tif name.isEmpty &#123; return nil &#125;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\nclass AutomaticallyNamedDocument: Document &#123;\n\toverride init() &#123;\n\t\tsuper.init()\n\t\tself.name &#x3D; &quot;[Untitled]&quot;\n\t&#125;\n\n\t&#x2F;&#x2F; 실패가능 -&gt; 실패불가능 재정의\n\toverride init(name: String) &#123;\n\t\tsuper.init() &#x2F;&#x2F; init?(name:)이 아닌 init()을 호출\n\t\tif name.isEmpty &#123;\n\t\t\tself.name &#x3D; &quot;[Untitled]&quot;\n\t\t&#125; else &#123;\n\t\t\tself.name &#x3D; name\n\t\t&#125;\n\t&#125;\n&#125;\n\nclass UntitledDocument: Document &#123;\n\toverride init() &#123; &#x2F;&#x2F; 구조적으로 실패 가능하지 않으므로!\n\t\tsuper.init(name: &quot;[Untitled]&quot;)! &#x2F;&#x2F; 강제 언래핑 (!)\n\t&#125;\n&#125;","slug":"Allen/2022-10-03-Allen26","date":"2022-10-02T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"ed9964861ab21bcd20187bc915c28720","title":"25)🧰 Swift - 클래스(Class)의 상속","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n클래스의 상속과 재정의클래스의 상속 (Inheritance)상속의 기본 개념\n성격이 비슷한 타입을 새로 만들어 데이터(저장속성)를 추가하거나 기능(메서드)을 변형시켜 사용하는 것\n\n하위 클래스는 상위 클래스의 멤버를 일단 상속\n\n이후 저장 속성을 추가하거나 메서드를 변형\n\n\n기본(Base) 클래스 ➡️  상속 클래스\n\n부모(Parent) 클래스, 슈퍼(Super) &#x2F; 상위 클래스\n자식(Child) 클래스, 서브(Sub) &#x2F; 하위 클래스\n\n\n상속 저장 속성을 상속할 때 복사해오지 않는다.\n\n상속받은 클래스는 상위 클래스의 저장 속성을 소유하지 않는다.\n따라서 상위 클래스의 저장 속성의 구조에 대한 권한이 없다.\n\n\n하지만 메서드를 상속할 때는 새로운 테이블로 복사해온다.\n\n메서드의 메모리 주소로 이루어진 배열의 형태\n따라서 override를 이용해 재정의가 가능하다.\n\n\n\nclass Person &#123;\n\tvar id &#x3D; 0\n\tvar name &#x3D; &quot;이름&quot;\n\tvar email &#x3D; &quot;abc@gmail.com&quot;\n&#125;\n\nclass Student: Person &#123; &#x2F;&#x2F; Person의 child class\n\tvar studentId &#x3D; 0\n&#125;\n\nclass Undergraduate: Student &#123; &#x2F;&#x2F; Student의 child class\n\tvar major &#x3D; &quot;전공&quot;\n&#125;\n\nvar uGraduate &#x3D; Undergraduate()\nprint(uGraduate.name) &#x2F;&#x2F; &quot;이름&quot;\n\n저장 속성 상속의 메모리 동작\n하위 클래스는 본인이 소유한 저장 속성의 값을 메모리에 추가한다.\n붕어빵을 “살짝” 찍는다!\n\n\n상위 클래스의 상속 받은 저장 속성에 대한 권한은 없기에 상위 클래스에 저장 속성 값 추가를 요청한다.\n상위 클래스는 마찬가지로 본인이 소유한 저장 속성의 값을 메모리에 추가한다.\n붕어빵을 또 “살짝” 찍는다..!\n\n\n한 단계 더 상위 클래스가 있다면 위 과정을 반복한다.\n붕어빵 완성! (분업 완료)\n\n\n\n잠깐!\n\n\n\n\n\n\n\n\n그러면 베이스 클래스만 데이터 영역에 있고 나머지 하위 클래스들은 힙 영역에 있나요?\n아닙니다. 모든 클래스들은 데이터 영역에 존재합니다. 힙 영역에는 저장 속성의 “값”을 저장하는 것이지 저장 속성은 저장하지 않습니다.보통 메서드와 헷갈릴 때 이렇게 생각할 수 있는데, 메서드와 저장 속성은 별개로 놓고 생각해야합니다!\n\nfinal\n클래스 상속 금지 키워드\n멤버 앞에 붙일 수도 있다.\n해당 멤버의 재정의를 금지\n\n\n\n\n\nfinal class Student: Person &#123;\n\tvar studentId &#x3D; 0\n&#125;\n\nclass Undergraduate: Student &#123; &#x2F;&#x2F; Error: Inheritance from a final class\n&#125;\n\n\noverride\n상위 클래스의 멤버를 재정의하고 싶을 때\n저장 속성의 경우에는 불가능\n메서드에 주로 사용\n\n\n\n상속의 방향\n하나의 클래스는 여러 하위 클래스를 가질 수 있다.\n하지만 Swift에서 다중 상속은 불가능하다.\n하나의 클래스는 상위의 두 가지 클래스는 상속받을 수 없다.\n다른 언어에서는 가능한 경우도 있다\n\n\n\n잠깐!\n\n\n\n\n\n\n\n\n앱을 만들 때를 보면 이런 것들도 있던데, 이거 다중 상속 아닌가요..?\nclass HomeViewController: UIViewController, UICollectionViewFlowDelegate &#123;\n\n\toverride func viewDidLoad() &#123;\n\t\tsuper.viewDidLoad()\n\t&#125;\n&#125;\n\n이 경우에서 HomeViewController 클래스의 뒤에 붙어 있는 친구들은 class가 아닙니다. 위 예시는 protocol을 사용한 경우입니다. 그리고 위 경우에는 대표적으로 Delegate 패턴을 사용한 경우인데, 이후 포스트에서 두 가지 모두 자세하게 다뤄볼 예정입니다.\n재정의 (Overriding)참고오버로딩(overloading) vs 오버라이딩 (overriding)\n오버로딩(overloading): 하나의 이름에 대해 여러 함수를 대응하는 것\n오버라이딩(overriding): 상위 클래스의 속성과 메서드를 재정의하는 것\n\n재정의 대상\n속성\n저장 속성 X\n계산 속성 O (메서드이기 때문에)\n\n\n메서드 (메서드, 서브 스크립트, 생성자)\n\nclass One &#123;\n\tfunc doSomething() &#123;\n\t\tprint(&quot;Do Something&quot;)\n\t&#125;\n&#125;\n\nclass Two: One &#123;\n\toverride func doSomething() &#123;\n\t\tsuper.doSomething() &#x2F;&#x2F; &quot;Do Something&quot;\n\t\tprint(&quot;Do another job&quot;) &#x2F;&#x2F; &quot;Do another job&quot;\n\t\tsuper.doSomething() &#x2F;&#x2F; &quot;Do Something&quot;\n\t&#125;\n&#125;\n\n재정의 기본 문법class SomeSuperClass &#123;\n\tvar aValue &#x3D; 0\n\n\tfunc doSomething() &#123;\n\t\tprint(&quot;Do Something&quot;)\n\t&#125;\n&#125;\n\nclass SomeSubClass: SomeSuperclass &#123;\n\t&#x2F;&#x2F; 저장 속성의 재정의 불가\n\toverride var aValue &#x3D; 3 &#x2F;&#x2F; Error\n\n\t&#x2F;&#x2F; 계산 속성으로서 재정의 가능 (메서드 형태로 변형)\n\toverride var aValue: Int &#123;\n\t\tget &#123;\n\t\t\treturn 1\n\t\t&#125;\n\t\tset &#123;\n\t\t\tsuper.aValue &#x3D; newValue\n\t\t&#125;\n\t&#125;\n\n\toverride func doSomething() &#123;\n\t\tsuper.doSomething()\n\t\tprint(&quot;Do Something 2&quot;)\n\t&#125;\n&#125;\n\n재정의 방식속성의 재정의\n저장 속성의 재정의\n원칙적으로 불가능하다. (메모리 공간은 유지해야한다.)\n저장 속성은 고유의 메모리 공간이 있으므로 하위 클래스에서 수정 불가능\n\n\n메서드 형태로 추가하는 방식의 재정의는 가능하다.\n읽기&#x2F;쓰기 가능한 계산 속성으로 재정의 가능\n읽기 전용의 계산 속성으로는 재정의 불가능 (축소 불가능)\n\n\n속성 감시자 추가 가능\n\n\n\n\n계산 속성(메서드)의 재정의\n메서드이기 때문에 재정의 가능\n기능 축소의 형태는 마찬가지로 불가능\n\n\n읽기 전용 계산 속성\n읽기&#x2F;쓰기 가능한 속성으로 재정의 가능 (확장 가능)\n속성 감시자 추가 불가능 (읽기 전용이기 때문에 값이 변할 일이 없음)\n\n\n읽기&#x2F;쓰기 계산 속성\n읽기만 가능한 속성으로 재정의 불가능 (축소 불가능)\n속성 감시자 추가 재정의 가능\n\n\n\n\n\n메서드의 재정의\n상위 클래스 인스턴스 메서드 또는 타입 메서드 상관없이 기능 추가 가능\n상위 기능 무시하고 새롭게 구현하는 것도 가능\n\n재정의 예시\n속성 재정의\n\nclass Vehicle &#123;\n\tvar currentSpeed &#x3D; 0.0 &#x2F;&#x2F; 저장 속성\n\n\tvar halfSpeed: Double &#123; &#x2F;&#x2F; 계산 속성\n\t\tget &#123;\n\t\t\treturn currentSpeed &#x2F; 2\n\t\t&#125;\n\t\tset &#123;\n\t\t\tcurrentSpeed &#x3D; newValue * 2\n\t\t&#125;\n\t&#125;\n&#125;\n\nclass Bicycle: Vehicle &#123;\n\t&#x2F;&#x2F; 저장 속성 추가\n\tvar hasBasket &#x3D; false\n\n\t&#x2F;&#x2F; 저장 속성 currentSpeed를 계산 속성으로 재정의\n\toverride var currentSpeed: Double &#123;\n\t\tget &#123;\n\t\t\treturn super.currentSpeed\n\t\t&#125;\n\t\tset &#123;\n\t\t\tsuper.currentSpeed &#x3D; newValue\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 저장 속성에 속성 감시자 추가 가능\n\toverride var currentSpeed: Double &#123;\n\t\twillSet &#123;\n\t\t\tprint(&quot;값이 \\(currentSpeed)에서 \\(newValue)로 변경 예정&quot;)\n\t\t&#125;\n\t\tdidSet &#123;\n\t\t\tprint(&quot;값이 \\(oldValue)에서 \\(currentSpeed)로 변경 예정&quot;)\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 계산 속성 재정의 가능\n\toverride var halfSpeed: Double &#123;\n\t\tget &#123;\n\t\t\treturn super.currentSpeed &#x2F; 2\n\t\t&#125;\n\t\tset &#123;\n\t\t\tsuper.currentSpeed &#x3D; newValue * 2\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 계산 속성을 재정의 하면서 속성 감시자 추가 가능\n\toverride var halfSpeed: Double &#123;\n\t\twillSet &#123;\n\t\t\tprint(&quot;값이 \\(halfSpeed)에서 \\(newValue)로 변경 예정&quot;)\n\t\t&#125;\n\t\tdidSet &#123; \n\t\t\tprint(&quot;값이 \\(oldValue)에서 \\(halfValue)로 변경 예정&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n메서드 재정의\n\nclass Vehicle &#123;\n\tvar currentSpeed &#x3D; 0.0\n\tvar datas &#x3D; [&quot;1&quot;,&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]\n\n\tfunc makeNoise() &#123;\n\t\tprint(&quot;경적을 울린다.&quot;)\n\t&#125;\n\n\tsubscript(index: Int) -&gt; String &#123;\n\t\tget &#123;\n\t\t\tif index &gt; 4 &#123;\n\t\t\t\treturn &quot;0&quot;\n\t\t\t&#125;\n\t\t\treturn datas[index]\n\t\t&#125;\n\t\tset &#123;\n\t\t\tdatas[index] &#x3D; newValue\n\t\t&#125;\n\t&#125;\n&#125;\n\nclass Bicycle: Vehicle &#123;\n\t&#x2F;&#x2F; 상위에서 하위 호출 가능\n\toverride func makeNoise() &#123;\n\t\tsuper.makeNoise() &#x2F;&#x2F; 상위 호출 가능\n\t\tprint(&quot;자전거가 지나간다고 소리친다.&quot;)\n\t\tsuper.makeNoise() &#x2F;&#x2F; 나중에 호출도 가능\n\t&#125;\n\n\t&#x2F;&#x2F; 상위 메서드를 무시하고 재정의도 가능\n\toverride func makeNoise() &#123;\n\t\tprint(&quot;경적을 울리고, 자전거가 지나간다고 소리친다.&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; 서브 스크립트 재정의 가능\n\toverride subscript(index: Int) -&gt; String &#123;\n\t\tget &#123;\n\t\t\tif index &gt; 4 &#123;\n\t\t\t\treturn &quot;777&quot;\n\t\t\t&#125;\n\t\t\treturn super[index] &#x2F;&#x2F; super &#x3D; 상위 클래스의 서브스크립트 호출\n\t\t&#125;\n\t\tset &#123;\n\t\t\tsuper[index] &#x3D; newValue\n\t\t&#125;\n\t&#125;\n&#125;\n","slug":"Allen/2022-10-01-Allen25","date":"2022-09-30T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"f43f96db698ca2fadca27d4600f204fb","title":"24)🧰 Swift - 접근제어와 싱글턴","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n접근 제어 (Access Control)class SomeClass &#123;\n\tvar name &#x3D; &quot;이름&quot;\n\n\tfunc nameChange(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\nvar s &#x3D; SomeClass()\n\n위 예시는 아무런 제한자가 없기 때문에 name 속성의 값을 두 가지 방법 모두로 수정할 수 있습니다.\n\ns.name = &quot;홍길동&quot;\ns.nameChange(name: &quot;홍길동&quot;)\n\nclass SomeClass &#123;\n\tprivate var name &#x3D; &quot;이름&quot;\n\n\tfunc nameChange(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\nvar s &#x3D; SomeClass()\n\n위 예시에서는 name 속성 앞에 private이라는 키워드가 붙었습니다. 이것이 바로 Swift에서의 은닉화 기능입니다.private 키워드는 객체 외부에서 해당 속성에 접근할 수 없도록 숨겨주는 기능을 합니다.\n이런 기능이 필요한 이유는 다음과 같습니다.\n\n감추고 싶은 데이터를 감출 수 있음\n코드의 영역을 분리시켜 효율적으로 관리할 수 있음\n컴파일러가 변수의 사용 범위를 알게되어 컴파일 시간이 줄어듦\n\n접근 제어 키워드에는 private 외에도 몇 가지가 더 있지만, 후에 더 자세하게 다뤄보도록 하겠습니다!\n싱글톤 패턴 (Singleton Pattern)\n메모리 상 유일하게 단 1개만 존재하는 객체\n한 번 생성된 싱글톤 객체는 앱이 종료될 때까지 유일한 객체로서 메모리에 상주\n힙 공간에 상주\n\n\nlazy하게 작동\n\n싱글톤 패턴의 문법적 이해\n객체 자기 자신을 생성\nstatic let shared = Singleton()\n\n\nprivate init()을 통해 새로운 객체 생성 방지\n\nclass Singleton &#123;\n\t&#x2F;&#x2F; 타입 상수 프로퍼티로 선언\n\tstatic let shared &#x3D; Singleton() &#x2F;&#x2F; 자기 자신을 생성 (문법)\n\tvar useInfoId &#x3D; 12345\n&#125;\n\nSingleton.shared &#x2F;&#x2F; 초기화 (생성)\n\nlet object &#x3D; Singleton.shared\nobject.userInfoId &#x3D; 12347\n\nprint(Singleton.shared.userInfoId) &#x2F;&#x2F; 12347\n\nlet object2 &#x3D; Singleton.shared\nprint(object2.userInfoId) &#x2F;&#x2F; 12347\n\nlet object3 &#x3D; Singleton() &#x2F;&#x2F; 이건 새로운 객체를 생성한 것\nprint(object3.userInfoId) &#x2F;&#x2F; 12345\n\n&#x2F;&#x2F; 새로운 객체를 만들 지 못하도록 방지하는 방법\nclass Singleton &#123;\n\tstatic let shared &#x3D; Singleton()\n\tvar userInfoId &#x3D; 12345\n\n\tprivate init() &#123;&#125; &#x2F;&#x2F; private init\n&#125;\n\n실제 사용 예시let screen &#x3D; UIScreen.main &#x2F;&#x2F; 화면을 관리하는 유일한 객체\nlet userDefaults &#x3D; UserDefaults.standard &#x2F;&#x2F; 유저 디폴트 객체\nlet application &#x3D; UIApplication.shared &#x2F;&#x2F; 앱 객체\nlet fileManager &#x3D; FileManager.default &#x2F;&#x2F; 파일 관리 객체\nlet notification &#x3D; NotificationCenter.default &#x2F;&#x2F; 알림 관리 객체\n","slug":"Allen/2022-09-30-Allen24","date":"2022-09-29T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"142b77ed1f32b84f0b8d08fde4f6ac05","title":"23)🧰 Swift - 메서드(Method)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n구조체와 클래스의 메서드메서드의 메모리 동작\n코드 영역에서 bori.sit()과 같은 접근연산자를 사용한 메서드를 마주친다.\n스택 영역의 bori 변수에 찾아간다.\nbori 변수는 힙 영역의 보리 객체를 가리키고 있다.\n\n\n힙 영역의 bori 객체에 찾아간다.\nbori의 메서드는 데이터 영역의 클래스 타입에 저장되어 있다.\n\n\n데이터 영역의 Dog(bori의 상위 클래스) 클래스 타입에 찾아간다.\n클래스 타입의 메서드는 실제로는 코드 영역의 주소값을 테이블 형태로 지닌다.\n\n\n코드 영역의 sit() 함수를 찾아 실행한다.\n\n잠깐!\n\n\n\n\n\n\n\n\n아니 왜 이렇게 복잡하게 실행하는거에요..?\n우선 메서드의 개수가 많아질 경우에는 힙 영역에 메서드를 전부  복사할 경우, 메모리의 누수가 굉장히 많아집니다.또한 클래스의 상속 기능을 지원하기 위해서입니다. 이후 상속 포스트에서 자세하게 다뤄볼겁니다!\n실제로 구조체(struct)의 경우에는 상속을 지원하지 않기 때문에 위와 같은 복잡한 메모리 접근 구조가 필요가 없습니다. 때문에 구조체의 메서드는 호출 하는 부분의 코드 영역에 메서드의 코드 영역 메모리 주소를 직접 명시해버립니다. 이를 Direct Dispatch라고 부릅니다.\n인스턴스 메서드 (Instance Methods)\n가장 기본적인 메서드\n\nclass Dog &#123;\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n\n\tfunc sit() &#123;\n\t\tprint(&quot;\\(name)가 앉았습니다.&quot;)\n\t&#125;\n\n\tfunc layDown() &#123;\n\t\tprint(&quot;\\(name)가 누웠습니다.&quot;)\n\t&#125;\n\n\tfunc play() &#123;\n\t\tprint(&quot;열심히 놉니다.&quot;)\n\t&#125;\n\n\tfunc training() &#123;\n\t\tsit()\n\t\tself.sit()\n\t\tself.sit()\n\t&#125;\n\n\tfunc changeName(newName name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\nlet bori &#x3D; Dog(name: &quot;보리&quot;, weight: 20.0)\nbori.sit()\nbori.layDown()\nbori.play()\n\nbori.changeName(newName: &quot;말썽쟁이 보리&quot;)\nprint(bori.name) &#x2F;&#x2F; &quot;말썽쟁이 보리&quot;\n\n구조체의 인스턴스 메서드\n값타입에서는 기본적으로 인스턴스 메서드 내에서 속성을 수정할 수 없다.\nmutating 키워드를 붙이면 속성 수정이 가능하다.\n\nstruct Dog &#123;\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n\n\tfunc sit() &#123;\n\t\tprint(&quot;\\(name)가 앉았습니다.&quot;)\n\t&#125;\n\n\tmutating func changeName(newName name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n&#125;\n\n잠깐!\n\n\n\n\n\n\n\n\n아니 왜 mutating이라는 키워드까지 붙여서  속성을 바꿔야 하나요? 그냥 바꾸게 두면 안돼요?\n구조체는 값타입입니다. 값타입의 데이터는 값을 바꾸게 되면 해당 데이터의 값을 바꾸는 것이 아니라, 바꿀 데이터를 가진 새로운 데이터를 만들어버립니다. 그 이유는 스택 메모리의 특성 상 새로운 데이터를 만드는 것이 더 빠르고, 목적 또한 그렇게 사용하기 위함이였기 때문입니다.\n그래서 dog.name = &quot;Doggie&quot;와 같이 값을 변경하면, 내부적으로는 &quot;Doggie&quot;의 값을 갖는 새로운 Dog() 객체를 생성하고, 원래 있던 오래된 객체를 pop시킵니다.\nmutating은 이런 현상을 막기 위해 주어지는 키워드입니다. mutating 키워드가 주어지면, 값타입 데이터의 값에 변경이 일어날 때 새로운 데이터를 만드는 대신 해당 속성의 주소값에 접근하여 값 자체를 수정합니다. 이는 Swift의 inout 방식과 동일하고, C언어의 포인터와 같은 기능이라고 볼 수 있겠습니다.\n겉으로 보기에는 같은 기능이지만, 내부적으로는 전혀 다른 동작 방식이였던 것이죠! 조금 더 나아가서 생각해보면, class는 참조타입이기 때문에 mutating 키워드를 사용할 필요가 전혀 없습니다. 때문에 XCode도 에러를 발생시키죠!\n오버로딩 (Overloading)struct Dog &#123;\n\tfunc sit() &#123;\n\t\tprint(&quot;앉았습니다.&quot;)\n\t&#125;\n\n\tfunc sit(a: String) &#123;\n\t\tprint(&quot;\\(a)가 앉았습니다.&quot;)\n\t&#125;\n&#125;\n\n타입 메서드 (Type Method)\n타입 속성과 비슷하게 타입에 종속\n내&#x2F;외부에서 Type.method()로 접근\n\n\n\nclass Dog &#123;\n\tstatic var species &#x3D; &quot;Dog&quot;\n\n\tstatic func letMeKnow() &#123;\n\t\tprint(&quot;종은 항상 \\(species)입니다.&quot;)\n\t&#125;\n&#125;\n\n클래스를 사용한 상속\nstatic 대신  class 키워드를 사용하여 상속할 때 override 가능\n\nclass Dog &#123;\n\tclass func someTypeMethod() &#123;\n\t\tprint(&quot;타입과 관련된 공통된 기능의 구현&quot;)\n\t&#125;\n&#125;\n\nclass Dog2: Dog &#123;\n\toverride class func someTypeMethod() &#123;\n\t\tprint(&quot;타입과 관련된 공통된 기능의 구현 (업데이트)&quot;)\n\t&#125;\n&#125;\n\n서브 스크립트 (Subscripts)\n[](대괄호)는 사실 특별한 형태의 메서드 호출 역할\narray[0], dictionary[&quot;A&quot;]\n\n\n\nclass myData &#123;\n\tvar datas &#x3D; [&quot;Apple&quot;, &quot;Swift&quot;, &quot;iOS&quot;, &quot;Hello&quot;]\n\n\tsubscript(index: Int) -&gt; String &#123;\n\t\tget &#123;\n\t\t\treturn datas[index]\n\t\t&#125;\n\t\tset(parameterName) &#123;\n\t\t\tdatas[index] &#x3D; parameterName\n\t\t&#125;\n\t&#125;\n&#125;\n\nvar data &#x3D; myData()\n\n&#x2F;&#x2F; subsript 추가 전\nprint(data[3]) &#x2F;&#x2F; Error\nprint(data.datas[3]) &#x2F;&#x2F; &quot;Hello&quot;\n\n&#x2F;&#x2F; subscript 추가 후\nprint(data[0]) &#x2F;&#x2F; &quot;Apple&quot;\ndata[0] &#x3D; &quot;AAA&quot;\nprint(data[0]) &#x2F;&#x2F; &quot;AAA&quot;\n\n사용 예시struct TimesTable &#123;\n\tlet multiplier: Int &#x3D; 3\n\n\tsubscript(index: Int) -&gt; Int &#123;\n\t\treturn multiplier * index\n\t&#125;\n&#125;\n\nlet threeTimesTable &#x3D; TimesTable()\nprint(&quot;6에 3배를 하면 숫자 \\(threeTimesTable[6])이 나옵니다.&quot;) &#x2F;&#x2F; 18\n\n타입 서브 스크립트 (Type Subscripts)enum Planet: Int &#123;\n\tcase mercury &#x3D; 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n\n\tstatic subscript(n: Int) -&gt; Planet &#123; &#x2F;&#x2F; or Planet 대신 Self\n\t\treturn Planet(rawValue.n)!\n\t&#125;\n&#125;\n\nlet mars &#x3D; Planet[4]\nprint(mars) &#x2F;&#x2F; mars\n\n참고여기까지 이해했다면 이제  Int나 String 등의 타입의 구조를 이해할 수 있습니다.이런 타입은 구조체로 구현되어 있습니다. 그리고 타입 메서드들을 사용하여 개발자들에게 사용할 수 있도록 제공하는 형태입니다.\nstruct Int &#123;\n\tstatic func random(in range: Range&lt;Int&gt;) -&gt; Int &#123; ... &#125;\n&#125;\n\nInt.random(1...10)\n","slug":"Allen/2022-09-30-Allen23","date":"2022-09-29T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"5debd5cacf7147ae1106516b70388c0b","title":"20)🧰 Swift - Class & Struct","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n클래스와 구조체클래스와 구조체를 알아보기 전에!객체 지향 프로그래밍클래스(틀) ➡️  객체(실제 데이터)ex) 강아지 ➡️  보리, 초코\n클래스와 구조체class Dog &#123;\n\t&#x2F;&#x2F; 속성 (property)\n\tvar name &#x3D; &quot;강아지&quot;\n\tvar weight &#x3D; 0.0\n\n\t&#x2F;&#x2F; 메서드 (method)\n\tfunc sit() &#123;\n\t\tprint(&quot;앉았습니다.&quot;)\n\t&#125;\n\n\tfunc layDown() &#123;\n\t\tprint(&quot;누웠습니다.&quot;)\n\t&#125;\n&#125;\n\nvar bori &#x3D; Dog()\nprint(bori.name) &#x2F;&#x2F; &quot;강아지&quot;\nbori.name &#x3D; &quot;보리&quot;\nprint(bori.name) &#x2F;&#x2F; &quot;보리&quot;\nvar choco &#x3D; Dog()\nprint(bori.name) &#x2F;&#x2F; &quot;강아지&quot;\n\nstruct Bird &#123;\n\tvar name &#x3D; &quot;새&quot;\n\tvar weight &#x3D; 0.0\n\n\tfunc fly() &#123;\n\t\tprint(&quot;날아갑니다.&quot;)\n\t&#125;\n&#125;\n\nvar aBird &#x3D; Bird()\nprint(aBird.name) &#x2F;&#x2F; &quot;새&quot;\naBird.name &#x3D; &quot;참새&quot;\nprint(aBird.name) &#x2F;&#x2F; &quot;참새&quot;\n\n\n인스턴스: 실제로 메모리에 할당되어 구체적 실체를 갖춘 것\nSwift에서 클래스의 인스턴스를 객채(object) 라고 부름\n클래스의 인스턴스 &#x3D; 객체\n구조체의 인스턴스\n열거형의 인스턴스\n\n\n\n클래스와 구조체의 차이는?\n메모리 저장 방식의 차이!\n\n구조체\n값 형식 (Value Type)\n인스턴스 데이터를 모두 스택에 저장\n값을 전달할 때마다 복사본을 생성 (다른 메모리 공간 생성)\n스택의 공간에 저장, 스택 프레임 종료 시 메모리에서 자동 제거\n멤버와이즈 생성자 제공\n메서드 내에서 속성 변경 원칙적으로 불가능\nmutating 키워드를 사용하여 가능\n\n\n소멸자 없음\n상속 불가능\n\n클래스\n참조 형식 (Reference Type)\n인스턴스 데이터를 힙에 저장, 해당 힙을 가리키는 변수는 스택에 저장\n스택에 메모리 주소값 저장\n\n\n값을 전달할 때 값 자체가 아니라 저장된 주소를 전달\n힙의 공간에 전달, ARC 시스템을 통해 메모리 관리\n편의 생성자 존재\n메서드 내에서 속성 변경 가능\n소멸자 있음\n상속 가능: 클래스의 유일한 특성\n\n클래스와 구조체의 메모리class Person &#123;\n\tvar name &#x3D; &quot;사람&quot;\n&#125;\n\nstruct Animal &#123;\n\tvar name &#x3D; &quot;동물&quot;\n&#125;\n\nvar p &#x3D; Person()\nvar a &#x3D; Animal()\n\nprint(p.name) &#x2F;&#x2F; &quot;사람&quot;\nprint(a.name) &#x2F;&#x2F; &quot;동물&quot;\n\nvar p2 &#x3D; p\np.name &#x3D; &quot;혜리&quot;\nprint(p.name) &#x2F;&#x2F; &quot;혜리&quot;\nprint(p2.name) &#x2F;&#x2F; &quot;혜리&quot;\n\n클래스와 구조체의 let과 var\n구조체의 경우 let으로 선언하면, 스택 영역에 저장되어 있기 때문에 프로퍼티가 모두 let으로 선언된다.\n클래스의 경우 스택에는 메모리 주소만 담겨있기 때문에, 다른 클래스를 가리킬 수 없게 될 뿐, 프로퍼티 값들은 힙 영역에 있기 때문에 변경 가능하다.\n\nclass PersonClass &#123;\n\tvar name &#x3D; &quot;사람&quot;\n\tvar age &#x3D; 0\n&#125;\n\nstruct AnimalStruct &#123;\n\tvar name &#x3D; &quot;동물&quot;\n\tvar age &#x3D; 0\n&#125;\n\nlet pclass &#x3D; PersonClass()\nlet astruct &#x3D; AnimalStruct()\n\npclass.name &#x3D; &quot;사람1&quot; &#x2F;&#x2F; Error 발생 X, 값이 변함!\nastruct.name &#x3D; &quot;동물1&quot; &#x2F;&#x2F; Error: Cannot assign to property\n\n접문법 &#x2F; 명시적 멤버 표현식 (Explicit Member Expression)의 정확한 의미\n내부의 요소(클래스&#x2F;구조체의 인스턴스 멤버)에 접근한다.\n멤버는 속성 혹은 메서드\n\naBird.name\naBird.fly()\n\n주의!\n\n\n\n\n\n\n\n\n클래스의 내부에는 직접 메서드 실행문이 올 수 없다.\n\n메서드 실행문은 메서드 정의 내부에서만 가능하다!\n\n초기화의 의미var bori &#x3D; Dog()\nbori.name &#x3D; &quot;보리&quot;\nbori.weight &#x3D; 15.0\n\n매번 위처럼 값을 넣어주기란 정말 귀찮을 수 있습니다. 프로퍼티가 많을수록 더욱 힘들어집니다.선언할 때 값을 동시에 넣어줄 수는 없을까요?당연히 됩니다! 생성자(init) 을 사용한다면요.\nclass Dog &#123;\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123; &#x2F;&#x2F; Initializer\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125; &#x2F;&#x2F; self: 실제 인스턴스의 값\n\n\tfunc sit() &#123;\n\t\tprint(&quot;앉았습니다.&quot;)\n\t&#125;\n&#125;\n\nvar bori &#x3D; Dog(n: &quot;보리&quot;, w: 15.0)\n\nself\n클래스&#x2F;구조체 내부에서 해당 인스턴스를 가리킴\n인스턴스 내에서 동일한 변수명, 상수명을 사용할 때 사용\n가리키는 것을 명확하게 하기 위해\n\n\n\n생성자의 특징\n모든 속성(변수)를 초기화 해야한다.\n생성자 실행 종료 시점에는 모든 속성의 초기값이 저장되어 있어야 한다.\n\n\n클래스, 구조체, 열거형은 모두 설계도일 뿐이다.\n실제 속성과 메서드를 사용하기 위해서는 초기화가 반드시 필요하다.\n\n\n오버로딩을 지원한다.\n다양한 파라미터의 조합으로 생성자를 여러개 구현할 수 있다.\n\n\n\n속성이 옵셔널 타입일 경우\n속성을 nil로 초기화할 수 있다.\n\nclass Dog() &#123;\n\tvar name: String?\n\tvar weight: Int\n\n\tinit(weight: Int) &#123;\n\t\tself.name &#x3D; &quot;강아지&quot;\n\t\tself.weight &#x3D; weight\n\t&#125;\n&#125;\n\nvar dog &#x3D; Dog(weight: 10)\n\nif let name &#x3D; dog.name &#123;\n\tprint(name)\n&#125;\n\n기본값(default) 부여 가능class Dog() &#123;\n\tvar name: String\n\tvar weight: Int\n\n\tinit(name: String &#x3D; &quot;보리&quot;, weight: Int) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n&#125;\n\nvar dog1 &#x3D; Dog(name: &quot;아리&quot;, weight: 15)\nvar dog2 &#x3D; Dog(weight: 16)\n\n식별연산자 (Identity Operator)\n두 개의 참조가 같은 인스턴스를 가리키고 있는지를 비교하는 연산자\n===, !==\n\nprint(dog1 &#x3D;&#x3D;&#x3D; dog2)\nprint(dog1 !&#x3D;&#x3D; dog2)\n","slug":"Allen/2022-09-29-Allen20","date":"2022-09-28T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"5c94070a5d9f5427f6f278ddea8ab0ba","title":"21)🧰 Swift - 클래스와 구조체 사용 이유","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n클래스&#x2F;구조체를 사용하는 이유\n사용하려는 모델의 설계\nData Transfer Object (DTO): 관련 데이터를 한 곳에 담는 역할\n의미 있는 데이터의 묶음\n\n\nData Access Object (DAO): 데이터 처리 (비즈니스 로직)\nHelper Object: 유틸리티\n\n\n\n\nDTO 예시\n\nclass Book &#123;\n\tvar name: String\n\tvar price: Int\n\tvar company: String\n\tvar author: String\n\tvar pages: Int\n\n\tinit(name: String, price: Int, company: String, author: String, pages: Int) &#123;\n\t\tself.name &#x3D; name\n\t\tself.price &#x3D; price\n\t\tself.company &#x3D; company\n\t\tself.author &#x3D; author\n\t\tself.pages &#x3D; pages\n\t&#125;\n&#125;\n\nvar book &#x3D; Book(name: &quot;스위프트&quot;, price: 30000, company: &quot;애플&quot;, author: &quot;잡스&quot;, pages: 300)\n\n\n애플이 설계해 놓은 클래스&#x2F;구조체들을 잘 사용하기 위해 (프레임워크)\n\n언제 클래스 &#x2F; 구조체를 사용해야 하는가?\n변수&#x2F;상수 ➡️  구조체 ➡️  클래스\n변수&#x2F;상수\n구조체: 메모리에 오래 저장하지 않음 &#x2F; 상속X\n클래스: 메모리에 오랫동안 저장 &#x2F; 상속\n\n\n애플은 상속이 필요하지 않을 경우, 구조체의 사용을 권장한다.\n\n구조체를 사용해야 하는 경우\n연관된 데이터들을 단순히 캡슐화할 때는 구조체\n캡슐화한 데이터들을 참조하는 것보다 복사하는 것이 효율적일 때 구조체\n구조체에 저장된 저장 속성들이 값타입이며 참조하는 것보다 복사하는 것이 합당할 때 구조체\n\n클래스를 사용해야 하는 경우\n데이터에서 상속의 구조가 필요하면 클래스\n해당 모델을 serialize해서 전송하거나 파일로 저장할 경우 클래스\n\n","slug":"Allen/2022-09-29-Allen21","date":"2022-09-28T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"eacada52d699b737f1657882de6f024e","title":"19)🧰 Swift - Foundation & UIKit","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nFoundation\nSwift 언어만 가지고는 할 수 있는 것이 거의 없다.\n기초적인 기능들은 Foundation 라이브러리를 import해야 한다.\n\n어떤 기능들이 있을까요?\nObj-C 관련 기능 &#x2F; 타입 &#x2F; 클래스 &#x2F; 컬렉션 …\n멀티 쓰레드 &#x2F; 네트워크 &#x2F; JSON &#x2F; Selector &#x2F; 런루프 &#x2F; NSData 등\n\niOS의 프레임워크 계층\n4개의 계층으로 구성\n\n\nCocoa Touch Framework\nUIKit &#x2F; GameKit &#x2F; MapKit &#x2F; NotificationCenter &#x2F; …\n앱의 겉모습에 관련된 기능 (사용자와 관련)\n\n\nMedia Framework\nCoreGraphics &#x2F; AVFoundation\n미디어 기능 구현 필요 기능\n\n\nCore Services Framework\nFoundation\n시스템 서비스 제공\n\n\nCore OS Framework\nCoreBluetooth &#x2F; LocalAuthentication &#x2F; Security\n보안 &#x2F; 하드웨어 연동\n\n\n\n","slug":"Allen/2022-09-29-Allen19","date":"2022-09-28T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"5947096696ce0c574876d193148e2ccd","title":"22)🧰 Swift - 속성(Property)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n구조체와 클래스의 속성저장 속성 (Stored Properties)저장 속성 (Stored Properties)\n값이 저장되는 일반적인 속성(변수)\n특정한 메모리 공간을 가지고 그 안에 값을 저장할 수 있는 속성\n\nstruct Bird &#123;\n\t&#x2F;&#x2F; 저장 속성\n\tvar name: String\n\tvar weight: Double\n\n\tfunc fly() &#123;\n\t\tprint(&quot;날아갑니다.&quot;)\n\t&#125;\n&#125;\n\n주의점\nlet과 var로 선언 가능\n각 속성 자체가 고유의 메모리 공간을 가짐\n초기화 이전에 값을 가지고 있거나 생성자를 통해 값을 초기화해주어야 한다.\n\n지연 저장 속성 (Lazy Stored Properties)\n해당 속성의 초기화를 지연시킨다.\n인스턴스가 초기화되는 시점에 해당 속성을 초기화하지 않고, 해당 속성에 접근할 때 개별적으로 초기화된다.\n\n\n상수(let)으로의 선언이 불가능 (lazy var로만 가능)\n초기화 시점을 늦췄기 때문에 init에서 초기화하면 제 기능을 못한다.\n접근될 때 초기화되더라도 그 시점에 초기값은 필요하기에 기본값이 설정되어야 한다.\n\n\n\nstruct Bird &#123;\n\tvar name: String\n\tlazy var weight: Double &#x3D; 0.2 &#x2F;&#x2F; 지연 저장 속성\n\n\tinit(name: String) &#123;\n\t\tself.name &#x3D; name\n\t&#125;\n\n\tfunc fly() &#123;\n\t\tprint(&quot;날아갑니다.&quot;)\n\t&#125;\n&#125;\n\nvar aBird &#x3D; Bird(name: &quot;새&quot;)\naBird.weight &#x2F;&#x2F; 해당 시점에 weight 속성 초기화\n\n주의점\n기본값으로는 값을 넣거나 표현식을 넣을 수 있다.\n함수 호출 코드, 계산 코드, 클로저 코드\nreturn 타입만 일치한다면!\n\n\n\n지연 저장 속성을 사용하는 이유?\n메모리를 많이 사용할 때\n다른 속성을 이용해야 할 때\n모든 속성들은 동시에 초기화된다.\n따라서 다른 속성에 의존하는 속성일 경우, 초기화가 제대로 되지 않을 가능성이 있다.\n\n\n\nclass AView &#123;\n\tvar a: Int\n\n\tlazy var view &#x3D; UIImageView()\n\n\tlazy var b: Int &#x3D; &#123;\n\t\treturn a * 10 &#x2F;&#x2F; 속성 a가 필요\n\t&#125;()\n\n\tinit(num: Int) &#123;\n\t\tself.a &#x3D; num\n\t&#125;\n&#125;\n\n계산 속성 (Computed Properties)\n속성의 형태를 가진 실질적 메서드\n인스턴스에 메모리 공간이 할당되어 있지 않음 (메서드이기 때문)\n\n\nget, set\nget만 선언할 경우 읽기전용(read-only) 계산 속성\nset은 선택적으로 구현\nnewValue 사용 시 유용\n\n\n\n\n\n예시1class Person &#123;\n\tvar birth: Int &#x3D; 0\n\n\tvar age: Int &#123; &#x2F;&#x2F; 계산 속성\n\t\tget &#123; &#x2F;&#x2F; get-block (getter)\n\t\t\treturn 2021 - birth\n\t\t&#125;\n\t\t&#x2F;&#x2F; 1. set default\n\t\tset(age) &#123; &#x2F;&#x2F; set-block (setter)\n\t\t\tself.birth &#x3D; 2021 - age\n\t\t&#125;\n\t\t&#x2F;&#x2F; 2. set using newValue\n\t\tset &#123;\n\t\t\tself.birth &#x3D; 2021 - newValue\n\t\t&#125;\n\t&#125;\n&#125;\n\nvar p1 &#x3D; Person()\np1.birth &#x3D; 2000\nprint(p1.age) &#x2F;&#x2F; 21 (get)\np1.age &#x3D; 20 &#x2F;&#x2F; (set)\nprint(p1.birth) &#x2F;&#x2F; 2001\n\n예시2\n계산 속성이 아닌 방식으로 구현\n\nclass Person &#123;\n\tvar name: String &#x3D; &quot;사람&quot;\n\tvar height: Double &#x3D; 160.0\n\tvar weight: Double &#x3D; 60.0\n\n\tfunc calculateBMI() -&gt; Double &#123;\n\t\tlet bmi &#x3D; weight &#x2F; (height * height) * 10000\n\t\treturn bmi\n\t&#125;\n&#125;\n\nlet p &#x3D; Person()\np.height &#x3D; 165\np.weight &#x3D; 65\n\np.calculateBMI()\n\n\n계산 속성으로 구현\n\nclass Person &#123;\n\tvar name: String &#x3D; &quot;사람&quot;\n\tvar height: Double &#x3D; 160.0\n\tvar weight: Double &#x3D; 60.0\n\n\tvar bmi: Double &#123;\n\t\tget &#123;\n\t\t\tlet result &#x3D; weight &#x2F; (height * height) * 10000\n\t\t\treturn result\n\t\t&#125;\n\t\tset &#123; &#x2F;&#x2F; 키는 변하지 않는다는 가정 하에\n\t\t\tweight &#x3D; newValue * height * height &#x2F; 10000\n\t\t&#125;\n\t&#125;\n&#125;\n\nlet p &#x3D; Person()\np.height &#x3D; 165\np.weight &#x3D; 65\nprint(p.bmi) &#x2F;&#x2F; 23.875...\n\n장점\n관련이 있는 두 가지 메서드를 한 번에 구현\n외부에서 보기에 속성 이름으로 설정\n\n주의점\n항상 변하는 값이므로 var로 선언\n자료형을 반드시 선언 (형식 추론 불가)\nget은 필수, set은 선택\n\n타입 속성 (Type Properties)\n인스턴스에 속한 속성이 아닌 타입 자체에 속한 속성\n데이터 공간에 고정된 모든 인스턴스들이 공유하는 속성\n\n저장 타입 속성\n생성자(init)가 없다. 타입 자체에 속한 속성\n기본값 필요\n\n\n지연 속성의 성격을 갖는다.\n참고: 여러 스레드에서 동시에 접근해도 한 번만 초기화 (Thread-Safe)\n\n\nstatic\n\nclass Dog &#123;\n\tstatic let species: String &#x3D; &quot;Dog&quot; &#x2F;&#x2F; 저장 타입 속성\n\n\tvar name: String\n\tvar weight: Double\n\n\tinit(name: String, weight: Double) &#123;\n\t\tself.name &#x3D; name\n\t\tself.weight &#x3D; weight\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 타입 자체에 접근해야한다.\nprint(Dog.species) &#x2F;&#x2F; &quot;Dog&quot;\n\nclass Circle &#123;\n\tstatic let pi: Double &#x3D; 3.14\n\tstatic var count: Int &#x3D; 0\n\n\tvar radius: Double\n\n\tvar diameter: Double &#123;\n\t\tget &#123;\n\t\t\treturn radius * 2\n\t\t&#125;\n\t\tset &#123;\n\t\t\tradius &#x3D; newValue &#x2F; 2\n\t\t&#125;\n\t&#125;\n\n\tinit(radius: Double) &#123;\n\t\tself.radius &#x3D; radius\n\t\tCircle.count +&#x3D; 1\n\t&#125;\n&#125;\n\nvar circle &#x3D; Circle(radius: 2)\nprint(Circle.count) &#x2F;&#x2F; 1\nvar circle2 &#x3D; circle(radius: 3)\nprint(Circle.count) &#x2F;&#x2F; 2\n\nprint(Circle.pi) &#x2F;&#x2F; 3.14\n\n주의점\nlet과 var 둘 다 가능\n인스턴스에 속한 속성이 아니기 때문에 인스턴스를 통해서는 접근 불가\n\n계산 타입 속성class Circle &#123;\n\tstatic let pi: Double &#x3D; 3.14\n\tstatic var count: Int &#x3D; 0\n\n\tstatic var multiPi: Double &#123; &#x2F;&#x2F; 계산 타입 속성\n\t\treturn pi * 2 &#x2F;&#x2F; Circle.pi\n\t&#125;\n\n\tvar radius: Double\n\n\tinit(radius: Double) &#123;\n\t\tself.radius &#x3D; radius\n\t&#125;\n&#125;\n\nlet b &#x3D; Circle.multiPi\nprint(b) &#x2F;&#x2F; 6.28\n\n어떤 경우에 타입 속성을 사용할까?\n모든 인스턴스가 동일하게 가져야 하는 속성\n모든 인스턴스가 공유해야하는 성격에 가까운 값\n상속에서 재정의\n저장 타입 속성: 하위 클래스에서 재정의 불가능 (class 키워드 불가)\n계산 타입 속성: 상위 클래스에서 class 키워드를 붙인 경우 재정의 가능\n\n\nclass 키워드\n상속이 있는 경우, 계산 타입 속성에서는 static 대신  class 사용\n\n\n\n속성 감시자 (Property Observer)\n(저장) 속성 감시자\n메서드의 형태로서 저장 속성을 감시한다.\n저장 속성의 값이 바뀔 때 실행되는 메서드\nwillSet, didSet\nwillSet: 바뀌기 전에 실행\ndidSet: 바뀐 후에 실행\n\n\n\nclass Profile &#123;\n\tvar name: String &#x3D; &quot;이름&quot;\n\n\tvar statusMessage: String &#x3D; &quot;기본 상태 메시지&quot; &#123;\n\t\twillSet(message) &#123;\n\t\t\tprint(&quot;메시지가 \\(statusMessage)에서 \\(message)로 변경될 예정입니다.&quot;)\n\t\t\tprint(&quot;상태 메시지 업데이트 준비&quot;)\n\t\t&#125;\n\t\tdidSet(message) &#123;\n\t\t\tprint(&quot;메시지가 \\(message)에서 \\(statusMessage)로 이미 변경되었습니다.&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\nlet p &#x3D; Profile()\n\nprint(p.statusMessage) &#x2F;&#x2F; &quot;기본 상태 메시지&quot;\np.statusMessage &#x3D; &quot;행복해&quot;\n&#x2F;&#x2F; &quot;메시지가 기본 상태 메시지에서 행복해로 변경될 예정입니다.&quot;\n&#x2F;&#x2F; &quot;상태 메시지 업데이트 준비&quot;\n&#x2F;&#x2F; willSet 구문 실행\n\n\noldValue, newValue\n\nclass Profile &#123;\n\tvar name: String &#x3D; &quot;이름&quot;\n\n\tvar statusMessage &#x3D; &quot;기본 상태 메시지&quot; &#123;\n\t\twillSet &#123;\n\t\t\tprint(&quot;메시지가 \\(statusMessage)에서 \\(newValue)로 변경될 예정입니다.&quot;)\n\t\t&#125;\n\t\tdidSet &#123;\n\t\t\tprint(&quot;메시지가 \\(oldValue)에서 \\(statusMessage)로 변경되었습니다.&quot;)\n\t\t&#125;\n\t&#125;\n&#125;\n\n주의점\n저장 속성\n저장 속성에만 가능하다고 생각하는게 편하다!\n\n\n계산 속성 (상속해서 재정의하는 경우에만 가능)\n억지로 쓴다고 봐야…\nsetter에서 처리하는 것이 훠얼씬 편리하다.\n\n\n실제로 수치적인 값이 변경되는 것이 아니라도, 값을 set하는 과정이 있다면 호출된다.\n\n","slug":"Allen/2022-09-29-Allen22","date":"2022-09-28T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"aea8aabe27f9653e7cb5727da120f0b0","title":"18)🧰 Swift - Enumeration","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n열거형 (Enumeration)\n타입 자체를 한정된 사례(case) 안에서 정의할 수 있는 타입\n연관된 상수들을 하나의 이름으로 묶음\n\nenum Weekday &#123;\n\tcase monday\n\tcase tuesday\n\tcase wednesday\n\tcase thursday\n\tcase friday\n\tcase saturday\n\tcase sunday\n&#125;\n\nenum CompassPoint &#123;\n\tcase north, south, east, west\n&#125;\n\n\n한정된 사례 안에서 정의되는 경우에 매우 유용!\nex) 월화수목금토일, 동서남북, 왼쪽가운데오른쪽, 남여, 가위바위보\n\n\n코드의 가독성과 안정성 ⬆️\n명확한 분기 처리 가능\n\n\n\n열거형은 타입이다!var today: Weekday &#x3D; Weekday.monday\ntoday &#x3D; .wednesday &#x2F;&#x2F; Weekday 생략 (타입이 명확할 때)\n\nif today &#x3D;&#x3D; .sunday &#123;\n\tprint(&quot;오늘은 일요일입니다.&quot;)\n&#125; else if today &#x3D;&#x3D; .monday &#123;\n\tprint(&quot;오늘은 월요일입니다.&quot;)\n&#125;\n\nswitch todya &#123;\ncase .monday:\n\tprint(&quot;오늘은 월요일입니다.&quot;)\ncase .tuesday:\n\tprint(&quot;오늘은 화요일입니다.&quot;)\n\t...\ncase .sunday:\n\tprint(&quot;오늘은 일요일입니다.&quot;)\n&#125;\n\n열거형의 원시값과 연관값원시값 (Raw Value)\n매칭되는 기본값을 정하여 열거형을 좀 더 쉽게 활용 가능할 수 있도록 돕는 값\n원시값은 Hashable한 타입은 모두 가능하다.\n하지만 일반적으로 Int와 String 타입을 사용한다.\n\n\n\nenum Alignment: Int &#123; &#x2F;&#x2F; Int 타입 원시값\n\tcase left\n\tcase center\n\tcase right\n&#125;\n\nenum Alignment2: String &#123; &#x2F;&#x2F; String 타입 원시값\n\tcase left\n\tcase center &#x3D; &quot;C&quot;\n\tcase right\n&#125;\n\n\nInt 타입 원시값위의 경우처럼 원시값을 따로 지정해주지 않으면, 앞에서부터 순서대로 0, 1, 2, …가 원시값으로 부여됩니다.부분적으로 설정해준다면, 설정된 다음의 원시값 또한 자동으로 1씩 증가되며 부여됩니다.\n\nex) 0, 2(설정), 3, 4 , …\n\n\nString 타입 원시값원시값을 따로 지정해주지 않으면, case의 이름을 그대로 가져다 부여됩니다.\n\nex) left, center, right\n\n\n\nlet align &#x3D; Alignment(rawValue: 0) &#x2F;&#x2F; Optional (해당 rawValue를 지니지 않을 수도 있기 때문에)\nlet leftValue &#x3D; Alignment.center.rawValue &#x2F;&#x2F; 1\n\n활용enum RpsGame: Int &#123;\n\tcase &quot;Rock&quot;, &quot;Scissor&quot;, &quot;Paper&quot;\n&#125;\n\nlet number &#x3D; Int.random(in: 0...100) % 3\nprint(RpsGame(rawValue: number)!)\n\n연관값 (Associative Value)\n구체적인 추가 정보를 저장하기 위해 사용\n\nenum Computer &#123;\n\tcase cpu(core: Int, ghz: Double)\n\tcase ram(Int, String)\n\tcase hardDisk(gb: Int)\n&#125;\n\nvar chip &#x3D; Computer.cpu(core: 8, ghz: 3.1)\n\nswitch chip &#123;\ncase .cpu(let a, let b):\n\tprint(&quot;CPU ](a)코어 \\(b)GHZ입니다.&quot;)\ncase let .ram(a, _):\n\tprint(&quot;램 \\(a) 기가램입니다.&quot;)\n&#125;\n\n잠깐! 이제 Optional을 정확하게 이해할 수 있다!\nOptional 타입의 내부는 열거형이다.\n결국 Optional 타입은 값이 없을 때 에러가 나지 않도록 임시로 열거형 타입의 값을 넣어두는 것..!\n\nenum Optional&lt;Wrapped&gt; &#123;\n\tcase some(Wrapped)\n\tcase none &#x2F;&#x2F; nil\n&#125;\n\n열거형과 switch문\n열거형은 switch문과 함께 사용했을 때 사용성이 높아진다!\n열거형은 한정된 사례로 만든 타입이고, 스위치문은 표현식에 대한 분기 처리에 최적화되어 있기 때문에, 서로 잘 맞는다.\n\n\n\nenum LoginProvider: String &#123;\n\tcase email\n\tcase facebook\n\tcase google\n&#125;\n\nlet userLogin &#x3D; LoginProvider.email\n\nswitch userLogin &#123;\ncase .email:\n\tprint(&quot;이메일 로그인&quot;)\ncase .facebook:\n\tprint(&quot;페이스북 로그인&quot;)\ncase .google:\n\tprint(&quot;구글 로그인&quot;)\n&#125;\n\n옵셔널 열거형과 switch문enum SomeEnum &#123;\n\tcase left\n\tcase right\n&#125;\n\nlet x: SomeEnum? = .left // Optional은 열거형\n// 열거형 안에 열거형이 있는 형태\n\n// 따라서 원칙적으로는 아래와 같이 처리해야 한다.\nswitch x &#123;\ncase .some(let value):\n\tswitch value &#123;\n\tcase .left:\n\t\tprint(\"왼쪽으로 돌기\")\n\tcase .right:\n\t\tprint(\"오른쪽으로 돌기\")\n\t&#125;\ncase .none:\n\tprint(\"계속 전진\")\n&#125;\n\n// 하지만 너무 불편하다.\n// 편의적 장치가 당연히 마련되어 있다.\nswitch x &#123;\ncase .some(.left):\n\tprint(\"왼쪽으로 돌기\")\ncase .some(.right):\n\tprint(\"오른쪽으로 돌기\")\ncase .none:\n\tprint(\"계속 전진\")\n&#125;\n\n// 조금 더 편하게!\nswitch x &#123;\ncase .left:\n\tprint(\"왼쪽으로 돌기\")\ncase .right:\n\tprint(\"오른쪽으로 돌기\")\ncase nil:\n\tprint(\"계속 전진\")\n&#125;\n\n열거형에 연관값이 있는 경우의 활용\n열거형 case 패턴\ncase Enum.case(let 변수이름):\ncase let Enum.case(변수이름):\n\n\n특이하게도 이 패턴은 if / guard / for-in / while에서도 사용 가능하다.\n\nif case Computer.hardDisk(gb: let gB) &#x3D; chip &#123;\n\tprint(&quot;\\(gB)기가 바이트 하드디스크&quot;)\n&#125;\n\n원래는 switch문에서 시작되었다.\n한 가지 값만 체크하고 싶을 때도 switch문을 사용해야하는 불편함\n\n\n\n열거형 케이스 패턴 (for)let arrays: [Int?] &#x3D; [nil, 2, 3, nil, 5]\n\nfor case let .some(number) in arrays &#123;\n\tprint(&quot;Found a \\(number)&quot;)\n&#125;\nfor case .some(let number) in arrays &#123;\n\tprint(&quot;Found a \\(number)&quot;)\n&#125;\n\n옵셔널 패턴 (Optional Pattern)\n옵셔널 타입에서 열거형 케이스 패턴을 더 간소화\n\nlet a: Int? &#x3D; 1\n\n&#x2F;&#x2F; 열거형 케이스 패턴\nswitch a &#123;\ncase .some(let z):\n\tprint(z)\ncase .none:\n\tprint(&quot;nil&quot;)\n&#125;\n\n&#x2F;&#x2F; 옵셔널 패턴\nswitch a &#123;\ncase let z?: &#x2F;&#x2F; .some 간소화\n\tprint(z)\ncase nil: &#x2F;&#x2F; &#x3D;&#x3D; .none\n\tprint(&quot;nil&quot;)\n&#125;\n\nlet arrays: [Int?] &#x3D; [nil, 2, 3, nil, 5]\n\n&#x2F;&#x2F; 열거형 케이스 패턴\nfor case .some(let number) in arrays &#123;\n\tprint(&quot;Found a \\(number)&quot;)\n&#125;\n\n&#x2F;&#x2F; 옵셔널 패턴\nfor case let number? in arrays &#123;\n\tprint(&quot;Found a \\(number)&quot;)\n&#125;\n\n@unknown\n열거형 케이스가 늘어난다면 올바른 처리를 하고 있는 것일까?\n\n아래 에시는 열거형 타입을 switch문으로 사용하고 있다. 이 때 열거형 LoginProvider에 case가 추가되었을 경우, 아래의 switch문에서 매번 제대로 처리를 할 수 있을까?default문에 의해 개발자가 캐치하지 못할 수 있다. 이 때 에러 처리를 할 수 있는 방법이 있다면, 발견하기 어려웠던 에러를 처리하기 쉬워질 것이다.\nenum LoginProvider: String &#123;\n\tcase email\n\tcase facebook\n\tcase google\n\tcase kakaotalk\n&#125;\n\nlet userLogin &#x3D; LoginProvider.email\n\nswitch userLogin &#123;\ncase .email:\n\tprint(&quot;이메일 로그인&quot;)\ncase .facebook:\n\tprint(&quot;페이스북 로그인&quot;)\ncase .google:\n\tprint(&quot;구글 로그인&quot;)\ncase .kakaotalk:\n\tprint(&quot;카카오톡 로그인&quot;)\n@unknown default:\n\tprint(&quot;그 외 로그인&quot;)\n&#125;\n\ndefault의 앞에 @unknown 키워드를 추가함으로서 열거형의 모든 case를 다루지 않았음을 경고로서 알려준다.\n","slug":"Allen/2022-09-28-Allen18","date":"2022-09-27T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"bc8ee1187329b643d5f24f6ff5a92ac2","title":"17)🧰 Swift - Collection","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n컬렉션 (Collection)스위프트의 컬렉션\n컬렉션: 여러개의 데이터를 한꺼번에 다루는 바구니 타입\n데이터를 효율적으로 관리하기 위한 자료형(타입)****\n배열(Array), 딕셔너리(Dictionary), 세트(Set)\n\n\n\n배열 (Array)\n데이터를 순서대로 저장하는 컬렉션\nlet numsArray: Array&lt;Int&gt; = [1, 2, 3, 4, 5]\nArray&lt;Int&gt; &#x3D;&#x3D; [Int]\n\n\n\n배열의 규칙\n배열의 인덱스는 0부터 자동으로 순서가 지정\n배열의 데이터는 중복 가능 (순서가 있기 때문에)\n한 개의 배열에는 동일한 데이터 타입만 담을 수 있음\n\nvar numsArray &#x3D; [1, 2, 3, 4, 5]\nlet numsArray1 &#x3D; [20, 2, 6, 5, 9, 7, 6]\nvar stringArray &#x3D; [&quot;Apple&quot;, &quot;Swift&quot;, &quot;iOS&quot;, &quot;Cocoa&quot;]\n\n배열의 타입 표기\n정식 문법: Array&lt;String&gt;\n단축 문법: [String]\n\n빈 배열의 생성let emptyArray: [Int] &#x3D; []\nlet emptyArray2 &#x3D; Array&lt;Int&gt;() &#x2F;&#x2F; (): 생성자\nlet emptyArray3 &#x3D; [Int]()\n\n배열의 기본 기능\ncount: 배열의 원소 개수\nisEmpty: 배열이 비어있는가?\ncontains([element]): 파라미터로 받은 값을 지니는가?\nrandomElement(): 랜덤한 원소\nswapAt([index1], [index2]): index1과 index2의 원소를 교환\n\n배열의 각 요소에 대한 접근\n[]: 서브스크립트 문법\n인덱스: 메모리 주소\n배열의 시작 주소로부터 단위 공간만큼 얼마나 뒤의 주소인가?\n\n\n\nvar numsArray: [Int] &#x3D; [1, 2, 3, 4, 5]\nprint(numsArray[0]) &#x2F;&#x2F; 1\nprint(numsArray[1]) &#x2F;&#x2F; 2\nprint(numsArray[2]) &#x2F;&#x2F; 3\nprint(numsArray[3]) &#x2F;&#x2F; 4\nprint(numsArray[4]) &#x2F;&#x2F; 5\n\nprint(numsArray.first) &#x2F;&#x2F; Optional(1) - 배열이 비어있을 수 있다.\nprint(numsArray.last) &#x2F;&#x2F; Optional(5)\nprint(numsArray.startIndex) &#x2F;&#x2F; 0\nprint(numsArray.endIndex) &#x2F;&#x2F; 5\nprint(numsArray[numsArray.endIndex - 1]) &#x2F;&#x2F; 5\n\n\n5개의 원소를 갖는 배열\n(n): 인덱스\nstartIndex(0) ◼️ (1) ◼️ (2) ◼️ (3) ◼️ (4) ◼️ endIndex(5)\n\n\n\nnumsArray.firstIndex(of: 3) &#x2F;&#x2F; 앞에서부터 찾았을 때 3이 처음 발견되는 인덱스\nnumsArray.lastIndex(of: 3) &#x2F;&#x2F; 뒤에서부터 찾았을 때 3이 처음 발견되는 인덱스\n&#x2F;&#x2F; 왜 있죠?\n&#x2F;&#x2F; 배열은 같은 값의 원소를 가질 수 있기 때문에!\n\nif let index &#x3D; numsArray.firstIndex(of: 2) &#123;\n\tprint(index)\n\tprint(numsArray[index])\n&#125;\n&#x2F;&#x2F; return 값이 Optional이기 때문에 if let을 활용하는 경우가 많다.\n\n배열 조물딱하기삽입 (insert)var alphabet &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]\nalphabet.insert(&quot;H&quot;, at: 0) &#x2F;&#x2F; index 0의 위치에(맨앞)\nalphabet.insert([&quot;H&quot;, &quot;I&quot;], at: 7) &#x2F;&#x2F; contentsOf: 는 사실 배열을 받는다.\n\n교체 (replace)alphabet[0] &#x3D; &quot;a&quot; &#x2F;&#x2F; 인덱스 0 자리의 원소를 교체\nalphabet[0...2] &#x3D; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] &#x2F;&#x2F; 범위 교체\n\nalphabet[0...1] &#x3D; [] &#x2F;&#x2F; 범위 삭제\n\nalphabet.replaceSubrange(0...2, with: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) &#x2F;&#x2F;  지원하는 함수 역시 당연히 있다.\n\n추가 (append)alphabet.append(&quot;H&quot;) &#x2F;&#x2F; 마지막 끝에 추가\nalphabet.append(contentsOf: [&quot;H&quot;, &quot;I&quot;])\nalphabet.append(7) &#x2F;&#x2F; Error: TypeError\n\n삭제 (remove)alphabet[0...2] &#x3D; []\nalphabet.remove(at: 2) &#x2F;&#x2F; 인덱스 2 위치의 원소 삭제\nalphabet.removeSubrange(0...2) &#x2F;&#x2F; 인덱스 범위 0~2 위치의 원소 삭제\n\nalphabet.removeFirst() &#x2F;&#x2F; 맨 앞의 원소 삭제하고 삭제된 원소 return\nalphabet.removeFirst(2) &#x2F;&#x2F; 맨 앞의 두 원소 삭제하고 삭제된 원소들 return\nalphabet.removeLast() &#x2F;&#x2F; 맨 뒤의 원소 삭제하고 삭제된 원소 return\nalphabet.removeLast(2) &#x2F;&#x2F; 맨 뒤의 두 원소 삭제하고 삭제된 원소들 return\n\nalphabet.removeAll() &#x2F;&#x2F; 원소 전부 삭제\nalphabet.removeAll(keepingCapacity: true) &#x2F;&#x2F; 저장 공간을 일단은 보관 (데이터만 삭제)\n\n그외alphabet.sort() &#x2F;&#x2F; 배열 자체를 정렬 (오름차순)\nalphabet.sorted() &#x2F;&#x2F; 정렬된 배열을 return (오름차순) - 원래의 배열을 변경하지는 않음\n\nalphabet.reverse() &#x2F;&#x2F; 배열을 거꾸로 정렬\nalphabet.reversed()\n\nalphabet.shuffle() &#x2F;&#x2F; 원소의 순서 랜덤하게 섞섞\nalphabet.shuffled()\n\nalphabet.sorted().reversed() &#x2F;&#x2F; 여러개 겹쳐서 사용 가능\n\n배열의 비교let a &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]\nlet b &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n\na &#x3D;&#x3D; b &#x2F;&#x2F; false\na !&#x3D; b &#x2F;&#x2F; true\n\n활용 예시var puppy &#x3D; [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;]\n\nif let lastIndexOfP &#x3D; puppy.lastIndex(of: &quot;p&quot;) &#123;\n\tpuppy.remove(at: lastIndexOfP)\n&#125; &#x2F;&#x2F; 마지막 &quot;p&quot; 삭제\n\nif !puppy.isEmpty &#123;\n\tprint(&quot;\\(puppy.count) element(s)&quot;)\n&#125; else &#123;\n\tprint(&quot;Empty Array&quot;)\n&#125;\n\nvar data &#x3D; [[1, 2, 3],\n\t\t    [4, 5, 6],\n\t\t    [7, 8, 9]]\ndata[0][2] &#x2F;&#x2F; 2\n\n반복문과의 결합\nenumerate: 열거하다.\nenumerated(): 열거된 것들을 named tuple 형태로 한 개씩 전달\nindex와 값을 차례대로 함께 꺼내서 사용할 일들이 있을 때 사용\n\n\n\nvar nums &#x3D; [1, 2, 3, 4, 5, 6, 7]\n\nfor i in nums &#123;\n\tprint(i)\n&#125;\n\nfor tuple in nums.enumerated() &#123;\n\tprint(tuple) &#x2F;&#x2F; (offset: 0, element: 1), ...\n\tprint(&quot;\\(tuple.0) - \\(tuple.1)&quot;) &#x2F;&#x2F; &quot;0 - 1&quot;, ...\n&#125;\n\nfor (index, word) in nums.enumerated() &#123;\n\tprint(&quot;\\(index) - \\(word)&quot;) &#x2F;&#x2F; &quot;0 - 1&quot;, &quot;1 - 2&quot;, ...\n&#125;\n\nfor (index, word) in nums.enumerated().reversed() &#123;\n\tprint(&quot;\\(index) - \\(value)&quot;) &#x2F;&#x2F; &quot;6 - 7&quot;, &quot;5 - 6&quot;, ...\n&#125;\n\n딕셔너리 (Dictionary)\n데이터를 키와 값으로 하나의 쌍으로 만들어 관리하는 컬렉션\n“키”: “값”\n\n\nlet dic: Dictionary&lt;String, String&gt; = [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;]\n\n규칙\n키 값은 유일해야함 (중복 불가능), 밸류값은 중복 가능\n동일한 타입의 쌍만 데이터로 담을 수 있음\n딕셔너리의 값에 딕셔너리&#x2F;배열을 사용하여 중첩적 사용 가능\n[String: [String]] ➡️ [&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]]\n\n\n딕셔너리의 키 값은 Hashable 해야함\n\nHash &#x2F; HashValue &#x2F; Hashable\nHash 함수: 고정된 길이의 숫자 or 글자이면서 유일한 값이 결과로 나온다.\nex) “steve”, “cook”, “musk”  ➡️ Hash Function ➡️ 1234, 8492, 3284\n\n\n특정 입력에 대해서는 항상 출력(HashValue)가 같다.\n다른 입력값으로는 해당 출력(HashValue)를 절대 얻지 못한다.\n\n\n보통 Hash Table을 만들어 사용\n\nHashTable과 딕셔너리\ncontain을 사용하면, 배열의 경우 모든 값을 확인한다.\n속도가 매우 느림\n\n\n딕셔너리의 경우 HashTable을 사용하여 검색 속도가 빠르다.\n\nHashable?\nHash 함수에 input으로서 쓰일 수 있는 타입\n\nHashable 프로토콜 채택\nSwift의 기본 타입은 모두 Hashable\n\n\n그래서 결론은\n\n\n\n\n\n\n\n\n\n딕셔너리의 키 값은 Hashable 해야한다!\n\n\n딕셔너리의 타입 표기var words: [String: String] &#x3D; [:] &#x2F;&#x2F; 단축 문법\nlet words: Dictionary&lt;Int, String&gt; &#x2F;&#x2F; 정식 문법\n\n빈 딕셔너리의 생성let emptyDic1: Dictionary&lt;Int, String&gt; &#x3D; [:]\nlet emptyDic2 &#x3D; Dictionary&lt;Int, String&gt;()\nlet emptyDic3 &#x3D; [Int: String]()\n\n딕셔너리의 기본 기능dict &#x3D; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;, &quot;C&quot;: &quot;City&quot;]\n\ndict.count\ndict.isEmpty\n\ndict.randomElement()\n\n딕셔너리의 각 요소에 대한 접근\n딕셔너리는 기본적으로 서브스크립트([])를 이용한 문법을 주로 사용한다.\n\ndict &#x3D; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;, &quot;C&quot;: &quot;City&quot;]\nprint(dict[&quot;A&quot;]) &#x2F;&#x2F; Optional(&quot;Apple&quot;)\ndict[&quot;Q&quot;] &#x2F;&#x2F; nil일 가능성이 있다.\ndict[&quot;Q&quot;, default: &quot;Empty&quot;] &#x2F;&#x2F; String 타입 return, &quot;Empty&quot;\n\nprint(dict.keys) &#x2F;&#x2F; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] key만 묶어서\nprint(dict.values) &#x2F;&#x2F; [&quot;Apple&quot;, &quot;Banana&quot;, &quot;City&quot;] value만 묶어서\n\n업데이트 (update)\n배열의 삽입, 교체, 추가 대신 업데이트 사용\n딕셔너리는 순서가 없기 때문에 세분화할 필요가 없다.\n\n\n\nwords &#x3D; [:]\nwords[&quot;A&quot;] &#x3D; &quot;Apple&quot;\nwords[&quot;B&quot;] &#x3D; &quot;Banana&quot;\nwords[&quot;B&quot;] &#x3D; &quot;Blue&quot;\nprint(words) &#x2F;&#x2F; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Blue&quot;]\n\nwords.updateValue(&quot;City&quot;, forKey: &quot;C&quot;)\n&#x2F;&#x2F; update를 하면서 새로운 값이 들어가면 nil return,\n&#x2F;&#x2F; 원래 있던 값을 교체할 때는 원래 있던 값을 return\n\n삭제 (remove)dict &#x3D; [&quot;A&quot;: &quot;Apple&quot;, &quot;B&quot;: &quot;Banana&quot;, &quot;C&quot;: &quot;City&quot;]\ndict[&quot;B&quot;] &#x3D; nil\ndict.removeValue(forKey: &quot;A&quot;)\ndict.removeAll()\ndict.removeAll(keepingCapacity: true)\n\n집합 (Set)\n순서가 없는 컬렉션\nlet set: Set&lt;Int&gt; = [1, 1, 2, 3]\n\n규칙\n생성 시 타입 선언\n중복된 원소를 넣어도, 중복 저장이 되지 않음\n각 요소는 유일한 값 (Hashable)\n\n\n\nvar set: Set &#x3D; [1, 1, 2, 3, 2, 2, 4, 3]\nprint(set) &#x2F;&#x2F; [2, 3, 1, 4]\n\n용도\nHashable에 집중해야한다.\n정렬 순서보다 검색 속도가 더 중요할 때 사용\n집합의 수학적 개념을 이용할 필요가 있을 때\nex) 합집합, 차집합, 여집합, …\n\n\n\n빈 Set의 생성let emptySet: Set&lt;Int&gt; &#x3D; []\nlet emptySet1 &#x3D; Set&lt;Int&gt;()\n\nSet의 기본 기능set.count\nset.isEmpty\n\nset.contains(1)\nset.randomElement()\n\n업데이트 (update)\n마찬가지로 순서가 없기 때문에 업데이트로 통합\n\nset.update(with: 1)\nset.update(with: 7)\n&#x2F;&#x2F; update를 하면서 새로운 값이 들어가면 nil return,\n&#x2F;&#x2F; 원래 있던 값을 교체할 때는 원래 있던 값을 return\n\n삭제 (remove)var stringSet: Set&lt;String&gt; &#x3D; [&quot;Apple&quot;, &quot;Banana&quot;, &quot;City&quot;]\nstringSet.remove(&quot;Apple&quot;)\n&#x2F;&#x2F; 삭제할 값이 없으면 nil return\n&#x2F;&#x2F; 있다면 삭제한 원소를 return\nstringSet.removeAll()\nstringSet.removeAll(keepingCapacity: true)\n\nSet의 활용부분집합 &#x2F; 상위집합 &#x2F; 서로소a &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\nb &#x3D; [1, 3, 5, 7, 9]\nc &#x3D; [2, 4, 6, 8, 10]\nd &#x3D; [1, 7, 5, 9, 3]\n\nb.isSubset(of: a) &#x2F;&#x2F; 부분집합인가? true\nb.isStrictSubset(of: a) &#x2F;&#x2F; 진부분집합인가? false\n\na.isSuperset(of: b) &#x2F;&#x2F; 상위집합인가? true\na.isStrictSuperset(of: b) &#x2F;&#x2F; 진상위집합인가? false\n\nd.isDisjoint(with: c) &#x2F;&#x2F; 서로소인가? true\n\n합집합var unionSet &#x3D; b.union(c)\nb.formUnion(c) &#x2F;&#x2F; 원본 변경\n\n교집합var interSet &#x3D; a.intersection(b)\na.formIntersection(b) &#x2F;&#x2F; 원본 변경\n\n차집합var subSet &#x3D; a.subtracting(b)\na.subtract(b) &#x2F;&#x2F; 원본 변경\n\n대칭차집합var symmetricSet &#x3D; a.symmetricDifference(b)\na.formSymmetricDifference(b) &#x2F;&#x2F; 원본 변경\n\n유의점\nSet에  sorted를 사용할 수 있다.\n하지만 return 값의 타입은 Array이다.\n\n\n\nvar newArray: Array &#x3D; newSet.sorted()\n\nKeyValuePairs\n딕셔너리와 유사한 형태이지만 배열처럼 순서가 있는 컬렉션\nSwift 5.2에 새롭게 등장한 컬렉션\nkey 값이 Hashable하지 안하도 됨\nkey 값이 동일한 것도 가능\nlet introduct: KeyValuePairs = [&quot;first: &quot;Hellow&quot;, &quot;second&quot;: &quot;My Name&quot;, &quot;third&quot;: &quot;is&quot;]\n\n그렇게 많이 사용되지는 않고 있기 때문에 이런게 있다 정도만 알고 넘어갑시다!\n","slug":"Allen/2022-09-27-Allen17","date":"2022-09-26T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"678abc472084fa82fc126653c5a66c11","title":"16)🧰 Swift - Optional","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n옵셔널 (Optional)우선 옵셔널 타입의 필요성을 느껴보기 위해 다음과 같은 상황을 살펴봅시다.\nvar yourName: String\nprint(yourName)\n\n위의 코드를 실행하면 print(yourName) 부분은 변수 yourName에 값을 저장하지 않았기 때문에 에러가 발생합니다.옵셔널 타입은 이런 상황에 대응하기 위해 소개되었습니다.\n옵셔널 타입 (Optional Type)\n메모리에 공간을 할당하여 변수를 선언하였지만, 실제로 값은 부여하지 않았을 경우 발생하는 에러에 대응하기 위한 타입\n일반적으로 사용하는 타입 뒤에 ?(물음표)를 붙이면 옵셔널 타입이 된다.\nex) Int?, String?\n\n\n\nnil옵셔널을 이해하기 위해서는 nil에 대해서 먼저 알아야합니다.nil은 값이 비어있음을 나타내는 키워드입니다. 다른 언어에서는 null로도 표현되곤 합니다.\n그런데 잠깐!\n\n\n\n\n\n\n\n\n편의상으로는 nil과 null을 동일하다고 생각해도 되지만, 사실 둘은 다른 개념입니다. null은 메모리에 해당 값이 “없음” 을 표현하는 키워드이지만, nil은 아닙니다! Swift에서 nil은 비어있지 않고, 임시 열거형 타입의 값을 실제로 가집니다. \nnil 값에 접근해야하는 위험이 있을 때, 직접적으로 메모리의 해당 공간에 접근하는 것이 아니라 임시적인 타입을 넣어두어 한 번 걸러주면 어떨까요?\n따라서 옵셔널 타입은 엄연히 새로운 타입입니다.Int 타입과 Int? 타입은 다른 타입인 것이죠.옵셔널 타입은 원래의 타입 범위에 nil 값을 추가한 범위라고 정의할 수 있습니다.\n\nInt\n…, -4, -3, -2, -1, 0, 1, 2, 3, 4, …\n\n\nInt?\n…, -4, -3, -2, -1, 0, 1, 2, 3, 4, … + nil\n\n\n\n옵셔널 타입 선언의 기본 규칙\nnil값을 대입할 수 있다.\n값을 넣어주지 않으면 자동으로 nil로 초기화된다.\n\n정식 표기 문법\n위에서 Int?와 같이 사용한다고 했지만, 이는 편의를 위한 간편 표기법이다.\nOptional&lt;Int&gt;가 정식 문법\n\n사용해보기var optionalNum: Int? &#x3D; nil\noptionalNum &#x3D; 10\n\nprint(optionalNum) &#x2F;&#x2F; Optional(10)\n&#x2F;&#x2F; Optional(10) !&#x3D; 10\n\n\nNon-Optional 타입의 값을 Optional 타입의 변수에 대입할 수는 있다.\n대신 타입은 Non-Optional로 변환되어 들어간다.\n\nvar a: Int? &#x3D; 7\nvar c: Int &#x3D; 5\na &#x3D; c\nprint(a) &#x2F;&#x2F; Optional(5)\n\n\n옵셔널 타입의 연산은 어떨까요?\n\nvar numA: Int? &#x3D; 3\nvar numB: Int? &#x3D; 4\nnumA + numB &#x2F;&#x2F; Error: Binary operator &#39;+&#39; cannot be applied to two &#39;Int?&#39; operands\n\n\n불가능한 것을 알 수 있다.\n\n옵셔널 타입에 대한 이해옵셔널 타입은 크게 보면 enum 형태의 타입입니다.Non-Optional 타입과 nil 타입의 케이스로 나누어 처리하는 방식입니다.\n옵셔널 타입의 연산위에서 우선 옵셔널 타입끼리의 연산은 불가능하다는 것을 확인하였습니다.옵셔널 타입의 변수를 사용하기 위해서는 nil 값을 제외한 값을 추출하는 과정이 필요합니다.\n옵셔널 값 추출 방법 4가지var num: Int?\nvar str: String? &#x3D; &quot;Hello!&quot;\n\n강제 추출 (Forced Unwrapping)\n값이 있다는 것이 확실할 때 사용\n강제 추출 연산자 ! 사용\n\n\n\nprint(str!) &#x2F;&#x2F; &quot;Hello!&quot;\nprint(num!) &#x2F;&#x2F; Error\n\nif문을 사용하여 nil 값이 아니라는 것을 확인 후, 강제 추출\n값이 있는지 확실하지 않다면, 확인한 후 강제 추출을 하면 된다.\n\nif str !&#x3D; nil &#123;\n\tprint(str!) &#x2F;&#x2F; &quot;Hello!&quot;\n&#125;\n\n옵셔널 바인딩 (if let)\n바인딩이 된다면, 특정 작업을 수행한다.\n조건을 만족하면, 메모리 영역에서 새로운 공간의 새로운 상수를 만들어 값을 추출해 복사하고 해당 상수를 사용한다.\n\nif let s &#x3D; str &#123; &#x2F;&#x2F; s라는 상수에 값이 담긴다면,\n\t&#x2F;&#x2F; 해당 스코프의 코드 실행\n\tprint(s) &#x2F;&#x2F; &quot;Hello!&quot;\n&#125;\n\n\n실전에서 굉장히 많이 사용\n\nfunc doSomething(name: String?) &#123;\n\tguard let n &#x3D; name else &#123; return &#125;\n\tprint(n)\n&#125;\n\n잠깐!\nif let은 알겠어요. 근데 if var는 안되나요?\n\n\n\n\n\n\n\n\n아뇨 됩니다. 다만 보통의 경우 Optional 타입의 값을 추출한 뒤에 해당 값을 바로 사용하기 때문에 거의 사용되지 않는 방식입니다.\n\n\n닐 코얼레싱 (Nil-Coalescing) 연산자 사용\ncoalesce: 더 큰 덩어리로 합치다.\n옵셔널 타입에 대해 default 값을 제시할 수 있을 때 사용\n\nvar serverName: String? &#x3D; &quot;Jake&quot;\nvar userName &#x3D; serverName ?? &quot;Auth Fail&quot;\n\nvar str: String?\nprint(&quot;안녕하세요&quot; + (str ?? &quot;Hi&quot;)) &#x2F;&#x2F; &quot;안녕하세요 Hi&quot;\nstr &#x3D; &quot;Hello&quot;\nprint(&quot;안녕하세요&quot; + (str ?? &quot;Hi&quot;)) &#x2F;&#x2F; &quot;안녕하세요 Hello&quot;\n\n옵셔널 체이닝 (Optional Chaining)\n옵셔널 타입에 접근연산자를 사용할 때 사용하는 문법\n접근연산자를 사용할 때 ?를 붙여서 앞의 타입이 nil 값을 가질 수 있음을 표기\n메모리 관점에서 힙 영역을 통해 .\n\nclass Dog &#123;\n\tvar name: String?\n\tvar weight: Int\n\n\tfunc sit() &#123;\n\t\tprint(&quot;앉았습니다.&quot;)\n\t&#125;\n&#125;\n\nvar choco: Dog? &#x3D; Dog()\nchoco?.name &#x3D; &quot;Choco&quot;\nprint(choco?.name) &#x2F;&#x2F; Optional(&quot;Choco&quot;)\nchoco?.sit() &#x2F;&#x2F; &quot;앉았습니다.&quot;\n\n옵셔널 체이닝의 특징\n옵셔널 체이닝의 결과는 항상 옵셔널 타입이다.\n옵셔널 체이닝의 값 중에서 하나라도 nil을 return한다면, 이어지는 표현식들은 평가하지 않고 무조건 nil을 return한다.\n\nIUO (Implicitly Unwrapped Optionals) 타입\n타입 선언시에 !가 붙어있는 타입\nOptional을 벗겨낼 준비가 되어있는 타입\nNon-Optional 타입 변수에 담을 때, 자동으로 Optional을 벗겨내며 담김\n\n\n\nvar number: Int! &#x3D; 7\nprint(number) &#x2F;&#x2F; Optional(7)\n&#x2F;&#x2F; 실제로 사용시에 벗겨지는 건 아니다...!\n\nvar number2: Int &#x3D; number &#x2F;&#x2F; 다른 변수에 담길 때 벗겨짐\nprint(number2) &#x2F;&#x2F; 7\n\nvar number3 &#x3D; number &#x2F;&#x2F; 형식 추론을 사용할 때는 자동으로 벗겨지지 않음\nprint(number3) &#x2F;&#x2F; Optional(7)\n\nvar number4 &#x3D; number! &#x2F;&#x2F; 강제로 벗기는 건 가능\nprint(number4) &#x2F;&#x2F; 7\n\nvar name: String! &#x3D; &quot;Jake&quot;\nname.count &#x2F;&#x2F; 값이 nil이 아닌 경우, 옵셔널 체이닝을 생략할 수 있지만, 값이 nil일 경우에는 Error가 발생한다.\n\nIUO… 왜 알아야할까..?\nStoryboard에서 IBOutlet을 코드에 연결할 때, 다음과 같이 자동으로 선언된다.\n\nvar label: UILabel!\n\n\nAPI에서 IUO 타입으로 return이 이루어질 때가 있다.\n\n어렵게 생각하지 말자!\n\n사용은 일반적인 옵셔널(?)과 동일하다!\n\n\n\n사용 예시class MyViewController: UIViewController &#123;\n\t@IBOutlet weak var imageView: UIImageView!\n\t@IBOutlet weak var mainLabel: UILabel!\n\n\toverride func viewDidLoad() &#123;\n\t\tsuper.viewDidLoad()\n\t&#125;\n\n\timageView.image &#x3D; UIImage(systemName: &quot;pencil&quot;)\n\tmainLabel.font &#x3D; UIFont.boldSystemFont(ofSize: 18.0)\n&#125;\n\n위의 예시에서 연결된 IBOutlet들은 IUO 타입이기 때문에 imageView.image와 같이 사용할 때 옵셔널 체이닝이 필요 없었습니다.만약 IUO 타입이 아니라면 코드는 다음과 같이 작성되어야 합니다.\nimageView?.image &#x3D; UIImage(systemName: &quot;pencil&quot;)\n","slug":"Allen/2022-09-27-Allen16","date":"2022-09-26T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"989a634ef691c286f5536c37d3f65d2d","title":"9)🧰 Swift - 반복문","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n반복문for문\n특정 조건을 만족하는 동안 반복\nfor [item] in [범위 / 컬렉션] &#123; [반복될 코드] &#125;\n\nfor index in 1...5 &#123;\n\tprint(&quot;\\(index)번째 반복 중&quot;)\n&#125;\n\n주의!\nfor문에서 선언하는 변수는 상수이다!\n반복 상수 (임시 상수)\n\n\n\n&#x2F;&#x2F; 변수로 사용하고 싶다면?\nfor a in 1...10 &#123;\n\tvar b &#x3D; a &#x2F;&#x2F; 따로 선언해서 저장해야함\n&#125;\n\nvar name &#x3D; &quot;홍길동&quot;\nfor name in 1...5 &#123;\n\tprint(name, terminator: &quot; &quot;)\n&#125;\n&#x2F;&#x2F; 1 2 3 4 5\nfor n in 1...5 &#123;\n\tprint(name, terminator: &quot; &quot;)\n&#125;\n&#x2F;&#x2F; 홍길동 홍길동 홍길동 홍길동 홍길동\n\n\nfor문에서 선언한 상수는 외부에서 사용할 수 없다!\n\nfor a in 1...10 &#123;\n\tprint(a)\n&#125;\n\nprint(a) &#x2F;&#x2F; Error : Cannot find &#39;a&#39; in scope\n\n와일드 카드 패턴\n언더바의 등장\n_: 생략을 의미\n\nfor _ in 0...10 &#123;\n\tprint(&quot;Hello!&quot;)\n&#125;\n&#x2F;&#x2F; 위 예시는 반복을 사용하지만 변수를 사용하지 않는다.\n&#x2F;&#x2F; 따라서 굳이 변수를 생성해 줄 필요가 없으니 _(언더바)를 사용!\n\n범위연산자를 거꾸로 쓰고 싶을 때\nreversed\n\nlet a &#x3D; (1...10).reversed()\nprint(a) &#x2F;&#x2F; 10 9 8 ... 2 1\n\n반복문은 컬렉션 타입에서도 사용할 수 있다!\n컬렉션에서 각 아이템을 차례대로 뽑아내서 사용할 때 활용 가능\n\nlet list &#x3D; [&quot;Swift&quot;, &quot;Programming&quot;, &quot;Language&quot;]\n\nfor str in list &#123;\n\tprint(str)\n&#125; \n&#x2F;&#x2F; &quot;Swift&quot;\n&#x2F;&#x2F; &quot;Programming&quot;\n&#x2F;&#x2F; &quot;Language&quot;\n\nfor chr in &quot;Hello&quot; &#123;\n\tprint(chr, terminator: &quot; &quot;)\n\t&#x2F;&#x2F; terminator: \\n 대신 사용\n&#125;\n&#x2F;&#x2F; H e l l o\n\n반복문의 조건범위에 사용 가능한 특수 함수들reversed\n역순으로\n\nfor number in (1...5).reversed() &#123;\n\tprint(number, terminator: &quot; &quot;)\n&#125;\n&#x2F;&#x2F; 5 4 3 2 1\n\nstride\n건너뛰며 뽑아내기\nstride(from: 1, to: 15, by: 2) &#x3D;&#x3D; [1, 3, 5, 7, 9, 11, 13]\nto 에 해당되는 값은 해당되지 않는다.\n\n\nStrideTo&lt;Int&gt;.Type, StrideThrough&lt;Int&gt;.Type\n\nfor number in stride(from: 1, to: 15, by: 2) &#123;\n\tprint(number, terminator: &quot; &quot;)\n&#125;\n&#x2F;&#x2F; 1 3 5 7 9 11 13\n\nwhile문\n마찬가지로 조건을 만족하는 동안 반복\nwhile [조건] &#123; [코드] &#125;\nfor문과 다른 점은 조건을 만족하는 동안 무한히 반복한다.\n따라서 반복되는 코드 안에서 조건의 변화가 이루어져야 한다!\n\n\n\nvar num &#x3D; 0\nwhile num &lt;&#x3D; 50 &#123;\n\tprint(num)\n&#125; &#x2F;&#x2F; 무한 루프..!\n\nwhile num &lt;&#x3D; 50 &#123;\n\tprint(num)\n\tnum +&#x3D; 1\n&#125; &#x2F;&#x2F; 0..&lt;50 반복\n\nrepeat-while문\nrepeat &#123; [코드] &#125; while [조건]\nwhile문과의 차이점\n일단은 한 번 실행하고 나서 조건을 판단\n조건 판별의 시점 (while: 반복코드 전에, repeat-while: 반복코드 후에)\n\n\n다른 언어에서는 do-while문이라고 불린다.\n\nvar i &#x3D; 1\nrepeat &#123;\n\tprint(&quot;\\(3) * \\(i) &#x3D; \\(3 * i)&quot;)\n\ti +&#x3D; 1\n&#125; while i &lt;&#x3D; 9\n\n제어전송문 (Control Transfer Statement)continue\n이번 반복은 넘어가고, 다음 반복문으로 진행시킨다.\n\nfor num in 1...20 &#123;\n\tif num % 2 &#x3D;&#x3D; 0 &#123;\n\t\tcontinue\n\t&#125;\n\tprint(num, terminator: &quot; &quot;)\n&#125;\n&#x2F;&#x2F; 1 3 5 ... 19\n\nbreak\n반복문을 중단하고 탈출한다.\n\nfor num in 1...20 &#123;\n\tif num % 2 &#x3D;&#x3D; 0 &#123;\n\t\tbreak\n\t&#125;\n\tprint(num, terminator: &quot; &quot;)\n&#125;\n&#x2F;&#x2F; 1\n\n주의\n중첩 사용 시의 적용 범위\n인접한 반복문에만 적용된다!\n\n\n\nfor i in 0...3 &#123;\n    print(&quot;OUTER \\(i)&quot;)\n    for j in 0...3 &#123;\n        if i &gt; 1 &#123;\n            print(&quot;  j :&quot;, j)\n            continue\n            &#x2F;&#x2F;break\n        &#125;\n        print(&quot;  INNER \\(j)&quot;)\n    &#125;\n&#125;\n\nOUTER 0\n  INNER 0\n  INNER 1\n  INNER 2\n  INNER 3\nOUTER 1\n  INNER 0\n  INNER 1\n  INNER 2\n  INNER 3\nOUTER 2\n  j : 0\n  j : 1\n  j : 2\n  j : 3\nOUTER 3\n  j : 0\n  j : 1\n  j : 2\n  j : 3\n\nLabeled Statements\nLabel이 매겨진 문장과 continue, break의 사용\n반복문에 Label을 매겨 제어전송문을 제어\n\nOUTER: for i in 0...3 &#123;\n    print(&quot;OUTER \\(i)&quot;)\n    INNER: for j in 0...3 &#123;\n        if i &gt; 1 &#123;\n            print(&quot;  j :&quot;, j)\n            continue OUTER\n            &#x2F;&#x2F;break OUTER\n        &#125;\n        print(&quot;  INNER \\(j)&quot;)\n    &#125;\n&#125;\n\nOUTER 0\n  INNER 0\n  INNER 1\n  INNER 2\n  INNER 3\nOUTER 1\n  INNER 0\n  INNER 1\n  INNER 2\n  INNER 3\nOUTER 2\n  j : 0\nOUTER 3\n  j : 0\n","slug":"Allen/2022-09-26-Allen09","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"4c6c15ee400822c4be937fe358a91dd0","title":"10)🧰 Swift - 함수.01","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n함수\n\n\n\n\n\n\n\n\n입력 ➡️ 함수 ➡️ 출력\n\n프로그래밍에서의 함수: 어떤 기능을 하는 코드의 모음\n명령어들에 이름을 붙여 묶어둔 것!\nthreeAndFour:\nMOV (A, B)\nMOV (C, B)\nADD (A, C)\n\n\n\n\n\n\nfunc [함수 이름]() &#123; [코드] &#125;\n\n함수의 기본 개념\n함수는 2단계에 걸쳐 실행된다.\n정의\n호출(실행)\n\n\n함수는 왜 사용할까?\n반복되는 동작을 단순화하여 재사용\n논리적 단위로 구분\n길이가 긴 코드를 단순화\n미리 주어진 코드의 기능을 개발자는 사용만 하면 된다.\n\n\n\n함수의 형태함수에 인풋이 있는 경우\n인자(parameter) &#x3D; 매개변수 &#x3D; 인풋(input)\n함수의 정의에 입력값으로 사용되는 상수\n\n\n인수(argument): 함수의 호출에 사용되는 실제 값\nfunc [함수 이름]([인자]: [인자 타입]) &#123; [코드] &#125;\n\nfunc saySomething(name: String) &#123;\n\tprint(name)\n&#125;\nsaySomething(name: &quot;Steve&quot;) &#x2F;&#x2F; &quot;Steve&quot;\n\n함수에 아웃풋이 있는 경우\n아웃풋 앞에 return 키워드 사용\nfunc [함수 이름]() -&gt; [아웃풋 타입] &#123; [코드] &#125;\n\nfunc sayYes() -&gt; String &#123;\n\treturn &quot;Yes&quot;\n&#125;\nvar isYes &#x3D; sayYes()\nprint(isYes) &#x2F;&#x2F; &quot;Yes&quot;\n\n함수에 인풋과 아웃풋 둘 다 있는 경우\nfunc [함수 이름]([인자]: [인자 타입]) -&gt; [아웃풋 타입] &#123; [코드] &#125;\n\nfunc sayHello(cnt: Int) -&gt; String &#123;\n\tfor _ in 0..&lt;cnt &#123;\n\t\tprint(&quot;Hello&quot;)\n\t&#125;\n\treturn &quot;Swift&quot;\n&#125;\nprint(sayHello(cnt: 3))\n&#x2F;&#x2F; &quot;Hello&quot; \\n &quot;Hello&quot; \\n &quot;Hello&quot; \\n &quot;Swift&quot;\n\nVoid Type이란?\n아웃풋이 없는 경우\n\nfunc foo() &#123;\n\tprint(&quot;Something&quot;)\n&#125;\n\n위 코드는 아래와 같다.\nfunc foo() -&gt; () &#123;\n\tprint(&quot;Something&quot;)\n&#125;\n\nfunc foo() -&gt; Void &#123;\n\tprint(&quot;Something&quot;)\n&#125;\n\n\n사실은 Void 타입이 생략되어 있는 것.\n\n함수의 파라미터와 아규먼트아규먼트 레이블 (Argument Label)\n겉에서 볼 때의 파라미터 이름과 안에서 사용할 때의 파라미터 이름을 각각 설정\n\nfunc printName(first name: String) &#123;\n\tprint(&quot;나의 이름은 \\(name) 입니다.&quot;)\n&#125;\n&#x2F;&#x2F; 밖에서 볼 때는 &#96;first&#96;, 안에서 사용할 떄는 &#96;name&#96;\n\nprintName(first: &quot;Alex&quot;)\n\n장점\n함수를 사용할 때 더 명확하게 요구하는 바를 개발자에게 알려줄 수 있다.\nfunc someFunction(yourFirstNumber a: Int) &#123; print(a) &#125;\nsomeFunction(yourFirstNumber: 12)\n\n\n\n아규먼트 레이블을 생략하는 것도 가능 (와일드카드)func addPrintFunction(_ firstNumber: Int, _ secondNumber: Int) &#123;\n\tprint(firstNumber + secondNumber)\n&#125;\naddPrintFunction(1, 2) &#x2F;&#x2F; 3\n\n가변 파라미터 (Variadic Parameters)\n함수의 파라미터에 정해지지 않은 여러가지 값을 대입\n하나의 파라미터로 2개 이상의 아규먼트 전달\n아규먼트는 배열의 형태로 전달\n가변 파라미터는 개별 함수마다 하나씩만 선언 가능\n가변 파라미터는 기본값을 가질 수 없다.\n\n\nType...\n\nfunc arithmeticAverage(_ numbers: Double...) -&gt; Double &#123;\n\tvar total &#x3D; 0.0\n\tfor number in numbers &#123;\n\t\ttotal +&#x3D; number\n\t&#125;\n\treturn total &#x2F; Double(numbers.count)\n&#125;\n\narithmeticAverage(2.5, 1.5) &#x2F;&#x2F; 2.0\n\n함수의 파라미터에 기본값(default) 부여 가능func someFunction(num1: Int, num2: Int &#x3D; 5) -&gt; Int &#123;\n\tvar result &#x3D; num1 + num2\n\treturn result\n&#125;\nprint(someFunction(num1: 3)) &#x2F;&#x2F; 8\nprint(someFunction(num1: 3, num2: 4)) &#x2F;&#x2F; 7\n\n\n애플이 만들어둔 함수에는 기본값이 포함되어 있는 경우가 매우 많다!\nex) print(): seperator: &quot;&quot;, terminator: &quot;\\n&quot;\n\n\n\n함수 사용 시의 주의점함수의 파라미터에 대한 정확한 이해\n함수의 파라미터는 함수 안에서 상수이다.\n\nfunc someAdd(a: Int) -&gt; Int &#123;\n\ta +&#x3D; 1 &#x2F;&#x2F; Error: &#39;a&#39; is a &#39;let&#39; constant\n\treturn a\n&#125;\n\n함수 내의 변수의 Scope(범위)\n함수 내에서 선언한 변수의 범위는 해당 함수 안이다.\n\nfunc sumOfNum(a: Int) -&gt; Int &#123;\n\tvar sum &#x3D; 0\n\tsum +&#x3D; a\n\treturn sum\n&#125;\nsum +&#x3D; 1 &#x2F;&#x2F; Error: cannot find &#39;sum&#39; in a scope\n\nreturn 키워드의 정확한 이해\n리턴 타입이 있는 함수의 경우\n리턴 키워드 다음의 표현식을 평가한 후에 그 결과를 리턴하며 함수를 벗어남\n\n\n리턴 타입이 없는 함수의 경우\n함수의 실행을 중지하고 함수를 벗어남\n\n\n\nfunc numberPrint(n num: Int) &#123;\n\tif num &gt;&#x3D; 5 &#123;\n\t\tprint(&quot;숫자가 5 이상입니다.&quot;)\n\t\treturn\n\t&#125;\n\tprint(&quot;숫자가 5 미만입니다.&quot;)\n&#125;\nnumberPrint(n: 6) &#x2F;&#x2F; &quot;숫자가 5 이상입니다.&quot;\n&#x2F;&#x2F; return이 없다면?\n&#x2F;&#x2F; 함수를 아직 벗어나지 않았기 때문에 뒤에 있는\n&#x2F;&#x2F; &quot;숫자가 5 미만입니다.&quot; 도 출력됨\n\nreturn 타입이 있는 경우, 함수의 실행문의 의미\nreturn 타입이 있는 함수를 호출하는 경우, 함수를 호출하는 것은 표현식\n\nfunc nameString() -&gt; String &#123;\n\treturn &quot;Steve&quot;\n&#125;\nvar yourName: String &#x3D; nameString()\nif nameString() &#x3D;&#x3D; &quot;Steve&quot; &#123;\n\tprint(&quot;이름이 일치합니다.&quot;)\n&#125;\n\n중첩 함수 (Nested Function)\n함수 안에 함수 정의도 가능\n\nfunc chooseStepFunction(backward: Bool, value: Int) -&gt; Int &#123;\n\tfunc stepForward(input: Int) -&gt; Int &#123;\n\t\treturn input + 1\n\t&#125;\n\tfunc stepBackward(input: Int) -&gt; Int &#123;\n\t\treturn input - 1\n\t&#125;\n\n\tif backward &#123;\n\t\treturn stepBackward(input: value)\n\t&#125; else &#123;\n\t\treturn stepForward(input: value)\n\t&#125;\n&#125;\n\nprint(chooseStepFunction(backward: true, value: 3)) &#x2F;&#x2F; 2","slug":"Allen/2022-09-26-Allen10","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"b526b3fe16c3f21f0c4b3f9796c6f8f3","title":"8)🧰 Swift - 삼항연산자와 범위연산자","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n삼항연산자와 범위연산자삼항연산자 (Ternary Conditional Operator)\nif문보다 제한적인 조건문\n하지만 용도는 확실!\n[조건] ? [참일때의 결과] : [거짓일때의 결과]\n\nvar a &#x3D; 10\n\nif a &gt; 0 &#123;\n\tprint(&quot;Positive&quot;)\n&#125; else &#123;\n\tprint(&quot;Negative&quot;)\n&#125;\n&#x2F;&#x2F; 위 예시는 아래와 같다.\na &gt; 0 ? print(&quot;Positive&quot;) : print(&quot;Negative&quot;) &#x2F;&#x2F; Positive\n\nlet result &#x3D; score &gt;&#x3D; 70 ? &quot;Pass&quot; : &quot;Fail&quot;\n\n\n조건에 따라 선택이 두 가지일 경우, 삼항연산자가 유용하다!\n\n범위연산자 &#x2F; 패턴매칭연산자범위연산자\n제한된 숫자의 범위를 표기하기 위한 연산자\n자체가 특별한 타입\n\n\n1...10: 1 ~ 10\n\n규칙\n내림차순 형식 표기 불가능\n실수 형식 범위 가능\n\n폐쇄범위연산자 (Closed Ranged Operator)\n1...10: 1 이상 10 이하, ClosedRange&lt;Int&gt;.Type\n1...: 1 이상, PartialRangeFrom&lt;Int&gt;.Type\n...10: 10 이하, PartialRangeThrough&lt;Int&gt;.Type\n\n반폐쇄범위연산자 (Half-Open Range Operator)\n1..&lt;10: 1 이상 10 미만, Range&lt;Int&gt;.Type\n..&lt;10: 10 미만, PartialRangeUpTo&lt;Int&gt;.Type\n\n활용\nfor문과 함께 사용\n\nfor index in 1...5 &#123;\n\tprint(&quot;\\(index) times 5 is \\(index * 5)&quot;)\n&#125;\n\nlet names &#x3D; [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brute&quot;, &quot;Carner&quot;]\nlet count &#x3D; names.count\nfor i in 0..&lt;count &#123;\n\tprint(&quot;Person \\(i + 1) is called \\(names[i])&quot;)\n&#125;\n\n\n배열의 서브스크립트 문법과 함께 사용\n\nnames[...2]\nnames[..&lt;1]\n\n\nswitch문의 케이스에서 사용\n\n\n패턴 매칭\n\nvar num &#x3D; 23\nswitch num &#123;\ncase 10...19:\n\tprint(&quot;10대&quot;)\ncase 20...29:\n\tprint(&quot;20대&quot;)\ncase 30...39:\n\tprint(&quot;30대&quot;)\ndefault:\n\tprint(&quot;그 외&quot;)\n&#125;\n\n패턴매칭연산자 (~=)\n숫자가 범위 내에 있는 지 확인하는 연산자\n범위연산자와 함께 쓰인다.\n\n\na...b ~= age\n오른쪽에 있는 표현식이 왼쪽의 범위에 포함되면 true, 아니라면 false\n\nvar n &#x3D; 20\n\nif n &gt;&#x3D; 10 &amp;&amp; n &lt;&#x3D; 100 &#123;\n\tprint(&quot;10 이상, 100 이하입니다.&quot;)\n&#125;\n&#x2F;&#x2F; 위 예시는 아래와 같다!\nif 10...100 ~&#x3D; n &#123;\n\tprint(&quot;10 이상, 100 이하입니다.&quot;)\n&#125;\n","slug":"Allen/2022-09-26-Allen08","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"c199cfdb25ec28891e8df6d1d782d568","title":"11)🧰 Swift - 함수.02","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n함수함수 표기법(지칭), 함수의 타입 표기함수 지칭func doSomething() &#123;\n\tprint(&quot;Hi!&quot;)\n&#125;\n\n\n파라미터가 없는 경우, ()를 삭제\nex) doSomething\n\n\n\nvar some &#x3D; doSomething\nsome() &#x2F;&#x2F; Hi!\n\n\n아규먼트 레이블이 있는 경우, 아규먼트 레이블까지 함수의 이름\nex) numberPrint(n:)\n\n\n파라미터가 여러개인 경우, 콤마(,) 없이 아규먼트 이름과 콜론을 표기\nex) chooseStepFunction(backward:value:)\n\n\n아규먼트 레이블이 생략된 경우, 언더바와 같이 표기\nex) addPrintFunction(_:_:)\n\n\n\n함수 타입의 표기\n함수에도 Type이 있다…!\n\nvar function1: (Int) -&gt; () &#x3D; numberPrint(n:)\nvar function2: (Int, Int) -&gt; Void &#x3D; addPrintFunction(_:_:)\n\n함수의 오버로딩 (overloading)\n오버로드(overload): 과적하다.\n같은 이름의 함수에 여러 개의 함수를 대응시키는 것\n\nfunc doSomething(value: Int) &#123;\n\tprint(value)\n&#125;\n\nfunc doSomething(value: Double) &#123;\n\tprint(value)\n&#125;\n\nfunc doSomething(value: String) &#123;\n\tprint(value)\n&#125;\n\nfunc doSomething(value1: String, value2: Int) &#123;\n\tprint(value1, value2)\n&#125;\n\n왜 이런 기능이 필요할까?\n같은 기능을 제공하는 함수이지만, 파라미터마다 값을 다르게 처리해야하는 경우가 있다.\n이름을 통일시키고, 처리는 구별해서 하는 것이 좋다!\n\n\n애플이 제공하는 함수들에도 이런 함수가 매우 많다.\nex) print ➡️ 자동 완성 기능을 살펴보면 같은 이름의 오버로딩된 함수가 많은 것을 확인할 수 있다.\n\n\n\n범위(scope)에 대한 이해\n범위(scope)\n\n밖에서 중괄호 내의 변수로 접근은 불가능\n중괄호 안에서 밖의 변수로는 접근 가능\n\n\n변수는 코드에서 선언이 되어야 그 때부터 접근 가능\n\n상위 스코프에 선언된 변수와 상수에 접근 가능, 하위 스코프에는 접근 불가\n\n동일한 스코프 안에서는 이름 중복 불가, 다른 스코프에서는 가능\n\n단, 가장 인접한 스코프의 변수&#x2F;상수로 접근\n\n\n\n","slug":"Allen/2022-09-26-Allen11","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"8550bee1cb2a0f386ea1b6c87fe12317","title":"12)🧰 Swift - 함수.03","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n함수함수와 메모리\n함수는 특정 메모리 주소에 위치하고, 함수의 내용이 순차적으로 위치한다.\n(0x01234): threeAndFour\n모든 프로그래밍 언어에서 가장 처음 실행되는 main() 함수가 존재한다.\nplayground에는 main 함수가 없으니 main 함수 영역내라고 가정하고 연습해보자!\n\n\n\n예시로 알아보자예시1func addTwoNumbers(a: Int, b: Int) -&gt; Int &#123;\n\tvar c &#x3D; a + b\n\treturn c\n&#125;\n\nvar num1 &#x3D; 5\nvar num2 &#x3D; 3\nvar num3 &#x3D; addTwoNumbers(a: num1, b: num2)\nprint(num3)\n\n위 과정은 컴퓨터의 입장에서 다음과 같은 코드로 변환됩니다. 또한 이 코드들은 메모리의 코드 공간에 저장됩니다.\n\naddTwoNumbers\n임시 공간을 만든다.\na라는 상수에 Int 타입 값을 저장한다.\nb라는 상수에 Int 타입 값을 저장한다.\nc 변수 공간을 만든다.\na + b를 더해서 임시 값을 갖는다.\n임시값을 c에 저장한다.\nc를 return한다. (CPU의 제어권과 반환값을 동시에 돌려준다.)\n\n\nMAIN\nnum1이라는 변수 공간에 5를 저장한다.\nnum2라는 변수 공간에 3을 저장한다.\nnum3 변수 공간을 만든다.\naddTwoNumbers 함수를 실행한다.\n결과값을 num3 공간에 저장한다.\nprint 함수를 실행한다.\n\n\n\n함수의 실행 시에는 함수 실행에 필요한 공간만큼의 스택 메모리 영역을 할당받습니다. 이러한 공간을 스택프레임이라고 합니다. 함수의 실행이 완료되면 해당 스택프레임은 pop되어 사라집니다.\n예를 들어 addTwoNumbers와 MAIN의 스택 구조는 다음과 같습니다.\n\naddTwoNumbers\n함수 내 변수&#x2F;상수 공간\nc\n\n\n파라미터 공간 (상수)\nb (3)\na (5)\n\n\n함수값&#x2F;임시값\n복귀주소 (이 경우에는 MAIN의 addTwoNumbers 호출 주소)\n\n\nMAIN\nnum3\nnum2 (3)\nnum1 (5)\n\n\n\n예시2코드var total: Int &#x3D; 0    &#x2F;&#x2F; 실제 전역변수라면 (데이터영역)\n\nfunc square(_ i: Int) -&gt; Int &#123;     &#x2F;&#x2F; x 제곱\n    return i * i\n&#125;\n\nfunc squareOfSum(_ x: Int, _ y: Int) -&gt; Int &#123;    &#x2F;&#x2F; (x + y)(x + y)\n    var z &#x3D; square(x + y)\n    return z\n&#125;\n\nfunc startFunction() &#123;\n    var a &#x3D; 4\n    var b &#x3D; 8\n    total &#x3D; squareOfSum(a, b)\n&#125;\n\nstartFunction()\n\n데이터\ntotal (전역 변수)\n\n힙스택\nsquare\n파라미터 공간 (상수)\ni (12)\n\n\n임시값 (return)\n복귀주소\n\n\nsquareOfSum\n함수 내 상수&#x2F;변수 공간\nz\n\n\n파라미터 공간 (상수)\nx (4)\ny (8)\n\n\n임시값 (return)\n복귀주소 (startFunction)\n\n\nstartFunction\n함수 내 scope 공간\na (4)\nb (8)\n\n\n복귀주소 (MAIN)\n\n\nMAIN\n\n","slug":"Allen/2022-09-26-Allen12","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"907ebb93ed2d00147c1adf0375c818e2","title":"15)🧰 Swift - discardableResult","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n@어트리뷰트 키워드\n선언에 추가 정보 제공\nex) @available(iOS 10.0)\n\n\n타입에 추가정보 제공\nex) @escaping\n\n\n\n@discardableResult\n함수의 return 값을 활용하지 않는 경우\n\nfunc sayHelloString() -&gt; String &#123;\n\tprint(&quot;Hi!&quot;)\n\treturn &quot;Hello&quot;\n&#125;\nsayHelloString() &#x2F;&#x2F; 함수의 print 부분만 원한다면..?\n\n위 예시의 경우 sayHelloString 함수를 호출하는 과정에서 개발자는 print 함수의 기능만을 원할 수 있지만 return 값이 있기 때문에 경고 표시가 뜬다.그래서 보통 어떤 방식으로 쓰느냐..?_ = sayHelloString()이렇게 썼습니다.\n하지만 Swift 5.2에서 새로운 기능이 출시되었습니다. 바로 @discardableResult 기능이죠! 함수의 결과값을 사용하지 않을 수도 있다는 간단한 기능을 제공합니다.사용법은 파이썬의 데코레이터와 같이 함수의 앞에 붙여주면 끝입니다.\n@discardableResult\nfunc sayHello() -&gt; String &#123;\n\tprint(&quot;Hi!&quot;)\n\treturn &quot;Hello&quot;\n&#125;\nsayHello()\n","slug":"Allen/2022-09-26-Allen15","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"38be23634e3acf27a2fda05d6da26d00","title":"13)🧰 Swift - inout","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\ninout 파라미터\n함수 내의 파라미터는 기본적으로 값 타입이고, 임시 상수이기 때문에 변경이 불가하다.\n\nvar num1 &#x3D; 123\nvar num2 &#x3D; 456\n\nfunc swap(a: Int, b: Int) &#123;\n\tvar temp &#x3D; a\n\ta &#x3D; b\n\tb &#x3D; temp\n&#125;\nswap(a: num1, b: num2)\n\n그렇다면 참조 타입으로는 값을 전달하지 못할까요? 그럴리가요.. 여기서 inout 파라미터가 등장합니다.\nvar num1 &#x3D; 123\nvar num2 &#x3D; 456\n\nfunc swapNumbers(a: inout Int, b: inout Int) &#123;\n\tvar temp &#x3D; a\n\ta &#x3D; b\n\tb &#x3D; temp\n&#125;\nswapNumbers(a: &amp;num1, b: &amp;num2) &#x2F;&#x2F; &amp;: 주소값\nprint(num1, num2) &#x2F;&#x2F; 456, 123\n\n주의점\n상수나 리터럴을 전달하는 것은 불가능\n파라미터의 기본값 선언을 허용하지 않음\n가변 파라미터로 선언하는 것 또한 불가능\n\n","slug":"Allen/2022-09-26-Allen13","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"fcc4ea6cb65a4817ace3b8347337d562","title":"14)🧰 Swift - guard","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nguard문\nguard [조건] else &#123; return &#125;\n\nif문의 불편함\n조건을 여러 개 나열할때, if문 내로 지속적으로 들여쓰기를 해야해서 코드의 가독성이 저하된다.\n\nguard문의 특징\nelse문을 먼저 배치 ➡️ 조건을 먼저 판별하여 조기 종료\n조건을 만족할 경우 다음 줄로 진행되어 계속 실행\nguard문에서 선언된 변수를 동일한 scope로 취급\n\nif문을 사용했을 경우func checkNumbersOf(password: String) -&gt; Bool &#123;\n\tif password.count &gt;&#x3D; 6 &#123;\n\t\t&#x2F;&#x2F; login function\n\t\treturn true\n\t&#125; else &#123;\n\t\treturn false\n\t&#125;\n&#125;\n\nguard문을 사용했을 경우func checkNumbersOf(password: String) -&gt; Bool &#123;\n\tguard password.count &gt;&#x3D; 6 else &#123; return false &#125;\n\t&#x2F;&#x2F; login function\n\treturn true\n&#125;\n\n\n쓰다보면 편해서 알아서 쓰게 된다!\n부담없이 사용하고 싶을 때 사용하기 시작할 것..!\n\n\n주로 Optional 타입의 변수들을 안전하게 사용하기 위해 사용된다.\n\n","slug":"Allen/2022-09-26-Allen14","date":"2022-09-25T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"9d635dcd0c3ed76f44738069253806e9","title":"7)🧰 Swift - 튜플(Tuple)","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n튜플(Tuple)튜플 기본\n\n\n\n\n\n\n\n\n(여러가지로 이루어진) 연관된 데이터를 어떻게 저장할까?    - 홍길동(String), 20세(Int), 서울(String)\n\n튜플: 원하는 연관된 데이터의 조합으로 어떤 조합이던 만들 수 있는 타입\n(&quot;홍길동&quot;, 20, &quot;서울&quot;)\n\n\n\nlet twoNumbers &#x3D; (1, 2)\nlet threeNumbers: (Int, Int, Int) &#x3D; (1, 2, 5)\n\nvar threeValues &#x3D; (&quot;홍길동&quot;, 20, &quot;서울&quot;)\ntype(of: threeValues) &#x2F;&#x2F; (String, Int, String).Type\nthreeValues &#x3D; (&quot;임꺽정&quot;, 30, &quot;부산&quot;)\n&#x2F;&#x2F; threeValues &#x3D; (&quot;임꺽정&quot;, &quot;부산&quot;) 얘는 불가능\n\n튜플의 각각의 데이터의 접근threeValues.0 &#x2F;&#x2F; &quot;임꺽정&quot;\nthreeValues.1 &#x2F;&#x2F; 30\nthreeValues.2 &#x2F;&#x2F; &quot;부산&quot;\n\n이름이 매겨진 튜플 (Named Tuple)\n튜플 사용 시의 가독성을 높일 수 있다.\n\nlet iOS &#x3D; (language: &quot;Swift&quot;, version: &quot;5&quot;)\n\niOS.language &#x2F;&#x2F; &quot;Swift&quot;\niOS.version &#x2F;&#x2F; &quot;5&quot;\n\n튜플의 분해 (Decomposition)\n튜플의 각 원소를 하나씩 분해해 상수나 변수에 대입할 수 있다.\n\nlet (first, second, third) &#x3D; threeValues\nfirst &#x2F;&#x2F; &quot;임꺽정&quot;\nsecond &#x2F;&#x2F; 30\nthird &#x2F;&#x2F; &quot;부산&quot;\n\ntypealias profile &#x3D; (String, Int, String) &#x2F;&#x2F; typealias도 사용 가능\n\n튜플값의 비교\n튜플의 비교는 가장 왼쪽 값을 비교한다. \n가장 왼쪽 값이 같다면 그 오른쪽 값을 비교한다.\n\n(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) &#x2F;&#x2F; true\n(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;) &#x2F;&#x2F; true\n(4, &quot;dog&quot;) &#x3D;&#x3D; (4, &quot;dog&quot;) &#x2F;&#x2F; true\n(&quot;blue&quot;, false) &lt; (&quot;purple&quot;, true) &#x2F;&#x2F; Error (bool 값은 대소비교가 불가능)\n\n튜플의 활용튜플과 switch문튜플의 매칭let iOS &#x3D; (language: &quot;Swift&quot;, version: &quot;5&quot;)\n\nif iOS.0 &#x3D;&#x3D; &quot;Swift&quot; &amp;&amp; iOS.1 &#x3D;&#x3D; &quot;5&quot; &#123;\n\tprint(&quot;Swift 버전 5입니다.&quot;)\n&#125;\nif iOS &#x3D;&#x3D; (&quot;Swift&quot;, &quot;5&quot;) &#123;\n\tprint(&quot;Swift 버전 5입니다.&quot;)\n&#125;\n\nswitch iOS &#123;\ncase (&quot;Swift&quot;, &quot;5&quot;):\n\tprint(&quot;Swift 버전 5입니다.&quot;)\ncase (&quot;Swift&quot;, &quot;4&quot;):\n\tprint(&quot;Swift 버전 4입니다.&quot;)\ndefault:\n\tbreak\n&#125;\n\n튜플의 바인딩\n(0, let distance) = (0, 10): 앞이 0일경우, distance에 10 바인딩\n\nvar coordinate &#x3D; (9, 0)\n\nswitch coordinate &#123;\ncase (let distance, 0), (0, let distance):\n\tprint(&quot;X 또는 Y축 위에 위치하며, \\(distance)만큼의 거리가 떨어져 있음.&quot;)\ndefault:\n\tprint(&quot;축 위에 있지 않음&quot;)\n&#125;\n&#x2F;&#x2F; coordinate &#x3D; (0, 7) : distance &#x3D;&#x3D; 7\n&#x2F;&#x2F; coordinate &#x3D; (5, 5) : 축 위에 있지 않음\n\n튜플의 where절 활용\nswitch문 안에서 where절을 활용하여 분리시켜 사용도 가능하다.\n\ncoordinate &#x3D; (1, -1)\n\nswitch coordinate &#123;\ncase let (x, y) where x &#x3D;&#x3D; y:\n\tprint(&quot;(\\(x), \\(y))의 좌표는 y &#x3D; x 1차함수 그래프 위에 있다.&quot;)\ncase let (x, y) where x &#x3D;&#x3D; -y:\n\tprint(&quot;(\\(x), \\(y))의 좌표는 y &#x3D; -x 1차함수 그래프 위에 있다.&quot;)\ncase let (x, y):\n\tprint(&quot;(\\(x), \\(y))의 좌표는 y &#x3D; x, 또는 y &#x3D; -x 그래프가 아닌 임의의 지점에 있다.&quot;)\n&#125;\n\n튜플을 사용하는 이유\n함수는 return값이 하나만 존재하기 때문에 여러 개의 값을 반환할 수 없지만, 튜플을 사용하면 가능하다.\nvar a: (Int, String) &#x3D; foo(a: String)\nex) (404, &quot;Not Found&quot;)\n\n\n\n","slug":"Allen/2022-09-25-Allen07","date":"2022-09-24T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"d591ebb33a3135eef19922f17d0ad553","title":"6)🧰 Swift - 프로그래밍 기본 원리와 조건문","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n프로그래밍의 기본 원리모든 프로그램은 세 가지 논리로 이루어진다.\n\n순차\n조건\n반복\n\n\n\n데이터\n\n\n\n순차\n개발자가 정한 규칙에 따라 순서대로 실행한다.\n\nprint(&quot;1&quot;)\nprint(&quot;2&quot;)\nprint(&quot;3&quot;)\n\n\n\n\n\n\n\n\n\n\n“1”“2”“3” \n조건조건문 (if문)\n참(true) 또는 거짓(false)의 특정 조건에 따라 특정 코드만 실행하게 할 수 있는 문장\n\nif\n\n\nvar number &#x3D; 5\nif number &lt; 7 &#123;\n\tprint(&quot;7보다 작다.&quot;)\n&#125;\n\n\nif - else\n\nnumber &#x3D; 20\nif number &lt;&#x3D; 10 &#123;\n\tprint(&quot;10보다 작거나 같다.&quot;)\n&#125; else &#123;\n\tprint(&quot;10보다 크다.&quot;)\n&#125;\n\n\nif - else if - else\n\nnumber &#x3D; 40\nif number &lt;&#x3D; 10 &#123;\n\tprint(&quot;10보다 작거나 같다.&quot;)\n&#125; else if number &gt;&#x3D; 30 &#123;\n\tprint(&quot;30보다 크거나 같다.&quot;)\n&#125; else &#123;\n\tprint(&quot;10보다 크고 30보다 작거나 같다.&quot;)\n&#125;\n\n\nif - else if\n\nnumber &#x3D; 72\nif number &lt;&#x3D; 10 &#123;\n\tprint(&quot;10보다 작거나 같다.&quot;)\n&#125; else if number &gt;&#x3D; 30 &#123;\n\tprint(&quot;30보다 크거나 같다.&quot;)\n&#125;\n\nif문에서 논리적인 구조 및 조건의 순서가 중요하다.논리적 오류\n잘못된 예시\n\nvar num &#x3D; 8\n\nif num &gt;&#x3D; 0 &#123;\n\tprint(&quot;0 또는 양수입니다.&quot;)\n&#125; else if num % 2 &#x3D;&#x3D; 0 &#123;\n\tprint(&quot;양의 짝수입니다.&quot;)\n&#125; else if num % 2 &#x3D;&#x3D; 1 &#123;\n\tprint(&quot;양의 홀수입니다.&quot;)\n&#125; else &#123;\n\tprint(&quot;음수입니다.&quot;)\n&#125;\n&#x2F;&#x2F; 0 또는 양수입니다. (아래의 조건들 확인 X)\n\n\n올바르게 수정한 예시\n\nif num &gt;&#x3D; 0 &#123;\n\tif num % 2 &#x3D;&#x3D; 0 &#123;\n\t\tprint(&quot;양의 짝수입니다.&quot;)\n\t&#125; else if num % 2 &#x3D;&#x3D; 1 &#123;\n\t\tprint(&quot;양의 홀수입니다.&quot;)\n\t&#125;\n&#125; else &#123;\n\tprint(&quot;음수입니다.&quot;)\n&#125;\n\n조건의 확인 순서\n잘못된 예시\n\nvar score &#x3D; 100\n\nif score &gt;&#x3D; 70 &#123;\n    print(&quot;70점이상입니다.&quot;)\n&#125; else if score &gt;&#x3D; 80 &#123;\n    print(&quot;80점이상입니다.&quot;)\n&#125; else if score &gt;&#x3D; 90 &#123;\n    print(&quot;90점이상입니다.&quot;)\n&#125; else &#123;\n    print(&quot;70점미만입니다.&quot;)\n&#125;\n&#x2F;&#x2F; 70점이상입니다.\n\n\n올바르게 수정한 예시\n\nif score &gt;&#x3D; 90 &#123; &#x2F;&#x2F; 범위가 작은 조건이 먼저 와야함\n    print(&quot;90점이상입니다.&quot;)\n&#125; else if score &gt;&#x3D; 80 &#123;\n    print(&quot;80점이상입니다.&quot;)\n&#125; else if score &gt;&#x3D; 70 &#123;\n    print(&quot;70점이상입니다.&quot;)\n&#125; else &#123;\n    print(&quot;70점미만입니다.&quot;)\n&#125;\n\n조건을 &amp;&amp;, ||로 연결하는 것도 가능var email &#x3D; &quot;a@gmail.com&quot;\nvar password &#x3D; &quot;1234&quot;\n\nif email &#x3D;&#x3D; &quot;a@gmail.com&quot; &amp;&amp; password &#x3D;&#x3D; &quot;1234&quot; &#123;\n    print(&quot;메인페이지로 이동&quot;)\n&#125;\n\nif email !&#x3D; &quot;a@gmail.com&quot; || password !&#x3D; &quot;1234&quot; &#123;\n    print(&quot;경고메세지 띄우기&quot;)\n    print(&quot;이메일주소 또는 패스워드가 올바르지 않습니다.&quot;)\n&#125;\n\n조건문 (switch문)\n표현식&#x2F;변수를 매칭시켜 분기처리할 때 사용하는 조건문\nif문 보다 한정적인 상황에서 사용\n\nvar choice: String &#x3D; &quot;가위&quot;\n\nswitch choice &#123;\ncase &quot;가위&quot;:\n\tprint(&quot;가위입니다.&quot;)\ncase &quot;바위&quot;:\n\tprint(&quot;바위입니다.&quot;)\ncase &quot;보&quot;:\n\tprint(&quot;보입니다.&quot;)\ndefault:\n\tbreak\n&#125;\n\nswitch의 특징\nswitch문에서 case의 ,(콤마)는 “또는”의 의미로 하나의 케이스에 여러 조건을 넣을 수 있다.\nswitch문은 값의 가능한 모든 경우의 수를 다루어야 한다.\nexhaustive\n모든 사례를 다루지 않을 경우, default가 반드시 있어야 한다.\n\n\n각 case에는 문장이 최소 하나 이상 있어야 한다.\n실행하지 않으려면 break를 반드시 입력해야 한다.\n\n\n\nfallthrough\n매칭된 값에 상관없이 무조건 다음 블럭을 실행한다.\n\nvar num &#x3D; 10\n\nswitch num &#123;\ncase ..&lt;10:\n\tprint(&quot;1&quot;)\n\tfallthrough\ncase 10:\n\tprint(&quot;2&quot;)\n\tfallthrough\ndefault:\n\tprint(&quot;3&quot;)\n&#125;\n\n\n\n\n\n\n\n\n\n\n23\n패턴 매칭 연산자\n~=\ntrue &#x2F; false\n\nvar num &#x3D; 30\n0...50 ~&#x3D; num &#x2F;&#x2F; true\n\nswitch num &#123;\ncase 0...50: &#x2F;&#x2F; 0...50 ~&#x3D; 30 내부적으로 패턴매칭으로 확인\n    print(&quot;숫자의 범위: 0 ~ 50&quot;)\ncase 51...100:\n    print(&quot;숫자의 범위: 51 ~ 100&quot;)\ndefault:\n    print(&quot;그 외의 범위&quot;)\n&#125;\n\n밸류 바인딩 (Value Binding)\n바인딩: 다른 새로운 변수&#x2F;상수 식별자로 할당\n\nvar num &#x3D; 6\n\nswitch num &#123;\ncase let a: &#x2F;&#x2F; let a &#x3D; num\n\tprint(&quot;숫자: \\(a)&quot;)\ndefault:\n\tbreak\n&#125;\n\nnum &#x3D; 7\n\nswitch num &#123;\n&#x2F;&#x2F; case num % 2 &#x3D;&#x3D; 0: 으로 하고 싶지만 얘는 결과가 true&#x2F;false\ncase let x where x % 2 &#x3D;&#x3D; 0:\n\tprint(&quot;짝수 숫자: \\(x)&quot;)\ncase let x where x % 2 !&#x3D; 0:\n\tprint(&quot;홀수 숫자: \\(x)&quot;)\ndefault:\n\tbreak\n&#125;\n\nswitch num &#123;\ncase var x where x &gt; 5: &#x2F;&#x2F; var로 선언할 경우 내부에서 변형도 가능\n\tx &#x3D; 7\n\tprint(x)\ndefault:\n\tprint(num)\n&#125;\n","slug":"Allen/2022-09-24-Allen06","date":"2022-09-23T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"7027a84620c87c923c1bc04e73937f59","title":"5)🧰 Swift - 기본연산자","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n기본연산자연산자연산자(Operator) 기초\na + b\n\na, b: 피연산자(operand)\n+: 연산자(operator)\n\n\n단항연산자: 단일 대상의 바로 앞&#x2F;뒤에 위치\n\n+a,  -b, !a\n\n\n이항연산자: 두 개의 대상 가운데 위치\n\na + b, a &gt;= b\n\n\n삼항연산자: 세 개의 대상 가운데 위치\n\na ? b : c\n\n\n연산자 사이의 공백 규칙\n\n단항연산자는 공백 없이 붙여서 사용\n이항&#x2F;삼항 연산자는 일반적으로 양쪽에 공백 1칸씩 추가하여 사용\n\n\n\n기본연산자할당 연산자 (Assignment Operator)\n오른쪽의 값을 왼쪽에 대입\n\nlet num2 &#x3D; 10\nvar num1 &#x3D; 5\n\n산술 연산자 (Arithmetic Operator)\n기본적으로 Swift에 내장되어 있는 연산\n+: 더하기\n-: 빼기\n*: 곱하기\n/: 나누기\n%: 모듈러 (나머지)\n\n\n\nvar a &#x3D; 456\nvar b &#x3D; 123\n\na + b\na - b\na * b\nb &#x2F; a\nb % a\n\n모듈러(%)의 사용var watchingTime: Int &#x3D; 70\n\nvar hour &#x3D; watchingTime &#x2F; 60\nvar minute &#x3D; watchingTime % 60\nprint(&quot;당신은 \\(watchingTime)분. 즉, 총 \\(hour)시간 \\(minute)분을 시청하셨습니다.&quot;)\n\nvar num &#x3D; 7\nvar array &#x3D; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]\narray[0]\narray[num % 3]\n\n나누기의 사용은 항상 주의a &#x3D; 4\nb &#x3D; 5\n\nvar newResult: Double\nnewResult &#x3D; Double(a &#x2F; b) &#x2F;&#x2F; 0.0\nnewResult &#x3D; Double(a) &#x2F; Double(b) &#x2F;&#x2F;0.8\n\n\n복합 할당 연산자 (Compound Assignment Operators)value +&#x3D; 10 &#x2F;&#x2F; value &#x3D; value + 10\nvalue -&#x3D; 5 &#x2F;&#x2F; value &#x3D; value - 5\n\n비교 연산자 (Comparison Operator)\n결과적으로 문장의 평가값은 참&#x2F;거짓으로 도출\n\na &#x3D; 456\nb &#x3D; 123\n\na &#x3D;&#x3D; b &#x2F;&#x2F; False\na !&#x3D; b &#x2F;&#x2F; True\na &gt; b\na &gt;&#x3D; b\n\n논리 연산자 (Logical Operator)\n!: Logical NOT Operator\n&amp;&amp;: Logical AND Operator\n||: Logical OR Operator\n\n접근 연산자\n.: 하위 개념에 접근\n\nInt.random(in: 1...3)\nvar number &#x3D; Int.random(in: 1...5)\n\nvar name &#x3D; &quot;Steve&quot;\nprint(name.count) &#x2F;&#x2F; 5\n\n연산의 우선순위\n*, /, % (곱하기 &#x2F; 나누기)\n+, - (더하기 &#x2F; 빼기)\n&lt;=, &gt;, ==, != (비교)\n&amp;&amp;, || (논리)\n삼항연산자\n=, += (할당, 복합 할당)\n\n","slug":"Allen/2022-09-23-Allen05","date":"2022-09-22T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"35531fd2e0969aee64527c9e13566622","title":"11)🍎 Swift - View Controller의 Life Cycle","content":"오늘은 면접을 볼 일이 하나 있었는데요.. 대답을 제대로 못해서 끝나자마자 황급하게 공부하려고 작성해둔 목록들을 열어보았습니다. 전부 다 있더라고요.. ㅎㅎ;;공부를 좀 더 열심히 했으면 답 할 수 있었을텐데 아쉽네요..\n그래서 오늘은 그 중에 하나였던 View Controller의 Life Cycle에 대해서 알아보려고 합니다.\nView Controller의 Life CycleView Controller도 다른 모든 객체들처럼 init과 deinit 과정을 거쳐야합니다. 그리고 Life Cycle에 해당되는 내용 중 어떤 것은 저희에게 아주아주 익숙한 모습이죠.View Controller 파일을 처음 만들면 보통 아래와 같이 코드가 자동으로 입력되어 있습니다. 너무 익숙한 친구죠?\nimport UIKit\n\nclass HomeViewController: UIViewController &#123;\n\toverride func viewDidLoad() &#123;\n\t\tsuper.viewDidLoad()\n\t\t&#x2F;&#x2F; Do any additional setup after loading the view, typically from a nib.\n\t&#125;\n&#125;\n\n말 그대로 View가 Load 될 때 실행되는 코드인데요, View Controller의 Life Cycle에는 이 viewDidLoad외에도 많은 함수들이 있습니다.\n\n이해하기 쉽게 메소드들의 이름들이 직관적으로 명명되어 있는 걸 볼 수 있네요. 그럼 하나하나 살펴봅시다. 별 거 없답니다!\nviewDidLoad가장 익숙한 친구부터 알아봅시다. 애플의 설명에 따르면 viewDidLoad는\n\n\n\n\n\n\n\n\n\nController의 View가 메모리에 로드된 후에 호출됩니다.\n라고 합니다. View를 표현하려면 우선 로드해야하고, 메모리에 리소스를 올려주어야 하겠죠. 해당 과정이 모두 끝난 후에 자동으로 호출되는 메소드가 바로 viewDidLoad인 것입니다.그래서 보통 viewDidLoad에서는 화면에 필요한 데이터들을 로드하거나 View가 로드된 후 딱 한 번만 실행해야 하는 코드가 있을 경우 이 곳에서 호출하면 됩니다.\nviewWillAppearView가 로드된 후에는 어떤 일이 일어날까요?바로 viewWillAppear가 호출됩니다. View가 화면에 띄워지기 직전에 호출되는 메소드인데요, viewDidLoad와 호출 시점이 굉장히 유사해보입니다.\n하지만 Appear와 Load라는 명확하게 다른 시점을 갖고 있는 만큼 아주 큰 차이가 있습니다. viewDidLoad는 View가 로드된 후 딱 한 번만 호출되기 때문에, 여러 View를 로드하고 서로를 오갈때는 호출되지 않습니다.반면 viewWillAppear는 여러 View를 오갈 때도 어쨋던 화면에 띄워지는 것이기 때문에 호출됩니다.\n따라서 View가 화면에 뜰 때마다 수행되어야 하는 기능이 있다면 viewWillAppear에 구현해주면 됩니다!\nviewDidAppearviewDidAppear는 말 그대로 View가 화면에 띄워진 직후에 호출됩니다. View가 화면에 띄워질 때마다 수행되어야 할 후처리 기능이 있다면 바로 여기에 구현해주면 됩니다.\nviewWillDisappear &#x2F; viewDidDisappear사실 위의 viewWillAppear와 viewDidAppear 메소드를 이해하셨다면, 이 두 메소드는 뽀너스입니다. View가 사라질 때마다 동일한 방식으로 호출되는 메소드이기 때문이죠.\n참고\n","slug":"Swift/2022-09-22-Swift11","date":"2022-09-21T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"a04236f3e453274a957b21632bdbd41b","title":"3)🧰 Swift - 데이터 타입","content":"\n변수와 상수변수 (Variables)변수의 의미\n변수: 데이터를 담을 수 있는 공간\n프로그램 동작의 첫 번째 단계는 메모리에 값(데이터)를 저장하는 것\n\nvar a &#x3D; 3 &#x2F;&#x2F; a에 3을 저장\nvar b &#x3D; 7 &#x2F;&#x2F; b에 7을 저장\n\nvar c &#x3D; b &#x2F;&#x2F; c에 b의 값을 복사해서 저장\n\n변수의 이름 짓기\n소문자로 시작\n숫자 사용 가능\n하지만 첫글자로 시작하는 것은 금지\n\n\n특수문자, 한자, 한글도 가능\n하지만 관습적으로 사용하지 않음\n\n\n\n변수의 선언\n변수의 이름 뒤에 :(콜론)을 붙이고 그 뒤에 데이터 타입 지정\n\nvar name: String\nvar a: Int &#x3D; 3 &#x2F;&#x2F; 메모리 공간을 생성하는 동시에 데이터 저장\n\n변수의 사용var name &#x3D; &quot;홍길동&quot;\nvar age &#x3D; 20\nvar address &#x3D; &quot;서울 강남구&quot;\nprint(name, age) &#x2F;&#x2F; 홍길동, 20\n\nname &#x3D; &quot;전지현&quot;\nprint(name, age) &#x2F;&#x2F; 전지현, 20\nprint(&quot;저의 이름은 \\(name)입니다. 저의 나이는 \\(age)살 입니다. 그리고 \\(address)에 살고 있습니다.&quot;) \n&#x2F;&#x2F; 저의 이름은 전지현입니다. 저의 나이는 20살 입니다. 그리고 서울 강남구에 살고 있습니다.\n\n\n문자열 보간법(String Interpolation): 문자열 중간에 출력할 변수를 삽입할 때 사용\n\n상수 (Constants)상수의 의미\n상수: 변하지 않는 데이터를 담을 수 있는 공간\n\nlet name &#x3D; &quot;김철수&quot;\n\nname &#x3D; &quot;우영우&quot; &#x2F;&#x2F; Error\n\n데이터 타입 (Data Types)데이터 타입데이터 타입의 이해\n컴퓨터와 사람의 데이터 타입에 대한 이해는 다르다.\n주어진 크기와 형태로 공간을 생성한다.\n\n\n\nvar i: Int &#x3D; 4\nvar j: Int &#x3D; 3\ni &#x3D; 3.4 &#x2F;&#x2F; Error (Type error)\n\nSwift의 데이터 타입정수형 데이터 타입\nInt\nex) …, -5, -4, -3, -2, -1, 0, 1, 2, 3, …\n\n\n\n실수형 데이터 타입\nFloat\n소수점 6자리 &#x2F; 4-byte\nex) -5.324, -4.2211, 0, 1.032, 3.14, …\n\n\nDouble\n소수점 15자리 &#x2F; 8-byte\n\n\nSwift에서는 주로 Double 타입 사용\n\n문자형 데이터 타입\nChar\n하나의 문자\nex) “A”, “b”, “C”, “한”, “ “(공백)\n\n\nString\n문자열\nex) “안녕하세요”, “홍길동”, “”(빈 문자열)\n\n\n\n참과 거짓\nBool\ntrue &#x2F; false\n\n\n\n타입 주석  (Type Annotation)\n변수를 선언하면서, 데이터 타입도 명확하게 지정하는 방식\n\nvar number: Int &#x2F;&#x2F; 변수 선언\nnumber &#x3D; 10     &#x2F;&#x2F; 값을 저장 (초기화)\nprint(number)   &#x2F;&#x2F; 10\n\nvar a1: Int &#x3D; 3\nvar b1: Int &#x3D; 4\n\nvar value: Double &#x3D; 5.345\nvalue &#x3D; 12.3\nvar value2 &#x3D; value &#x2F;&#x2F; Double\n\n타입 추론 (Type Inference)\n타입을 지정해주지 않아도 컴파일러가 타입을 유추하여 저장하는 방식\n\nvar name &#x3D; &quot;홍길동&quot;\ntype(of: name) &#x2F;&#x2F; String:Type\n\n타입 안정성 (Type Safety)\n데이터 타입을 명확하게 구분하여 사용하는 속성\nSwift는 다른 타입의 데이터끼리 계산할 수 없다.\n\n\n\nlet num5 &#x3D; 7\nlet num6: Double &#x3D; num5 &#x2F;&#x2F; Error (공간의 크기가 다름)\n\nlet d &#x3D; 12\nlet e &#x3D; 3.14\nlet result &#x3D; d + 2 &#x2F;&#x2F; Error  (데이터 타입이 다름)\n\n타입 변환 (Type Conversion)\n다른 다입끼리 계산이 안된다면, 타입을 변환하면 된다!\n기존의 데이터를 다른 타입으로 변환하여 새롭게 저장\n\nlet str &#x3D; &quot;123&quot;\nlet number &#x3D; Int(str)\nprint(type(of: number)) &#x2F;&#x2F; Optional&lt;Int&gt;\n\nlet str2 &#x3D; &quot;123.4&quot;\nlet number2 &#x3D; Int(str2) &#x2F;&#x2F; 타입 변환이 실패하면 nil\nprint(type(of: number2)) &#x2F;&#x2F; Optional&lt;Int&gt;\nprint(number2)  &#x2F;&#x2F; nil\n\n타입 애일리어스 (Type Alias)\n기존에 선언되어 있는 타입에 새로운 별칭을 붙여 가독성을 높이는 방법\n\ntypealias Name &#x3D; String\nlet name: Name &#x3D; &quot;홍길동&quot;\n\ntypealias Something &#x3D; (Int) -&gt; String\nfunc someFunction(completionHandler: (Int) -&gt; String) &#123;\n\t\n&#125;\n\nfunc someFunction(completionHandler: Something) &#123;\n\t\n&#125;\n","slug":"Allen/2022-09-21-Allen03","date":"2022-09-20T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"9108559a97d1d0ac73adf4e69cc1693c","title":"4)🧰 Swift - 용어 정리","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n키워드\nSwift에서 특별한 의미로 사용하겠다고 미리 정해놓은 단어\nex) var, let, if, true\n\n리터럴 (Literals)\n코드에서 고정된 값으로 표현되는 데이터 그 자체\n\nvar a &#x3D; 4 &#x2F;&#x2F; &lt;정수 리터럴&gt; 값인 4를 넣었다.\nvar b: Int &#x3D; 8\n\nvar name &#x3D; &quot;홍길동&quot; &#x2F;&#x2F; &lt;문자열 리터럴&gt; &quot;홍길동&quot;\nvar double &#x3D; 3.14 &#x2F;&#x2F; &lt;double 리터럴&gt; 3.14\n\n식별자 (Identifier)\n변수, 상수, 함수, 사용자 정의 타입의 이름\n\nvar name1 &#x3D; &quot;전지현&quot; &#x2F;&#x2F; name1\nvar name2 &#x3D; &quot;임꺽정&quot; &#x2F;&#x2F; name2\n\n토큰 (Token)\n코드의 가장 작은 단위 (식별자, 키워드, 구두점, 연산자, 리터럴)\nex) var, !=, 123\n\n표현식 (Expression)\n값, 변수, 연산자의 조합으로 하나의 결과값으로 평가되는 코드 단위\n\nvar n &#x3D; 5 &#x2F;&#x2F; 문장\n17 &#x2F;&#x2F; 표현식\nn  &#x2F;&#x2F; 표현식\nn + 7 &#x2F;&#x2F; 표현식\nn &lt; 5 &#x2F;&#x2F; 표현식\n\n문장 (Statement)\n특정 작업을 실행하는 코드 단위\n\nvar n2 &#x3D; 3 &#x2F;&#x2F; 문장\nprint(n)   &#x2F;&#x2F; 문장\n","slug":"Allen/2022-09-21-Allen04","date":"2022-09-20T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"cf2f5162a371fd39afcfa188ee9b14c2","title":"2)🧰 Swift - 등호의 의미와 print","content":"앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\n프로그래밍 기본등호(&#x3D;)의 의미\n프로그래밍에서 사용하는 등호(&#x3D;)는 할당의 의미이다.\n할당연산자var a &#x3D; 5\na &#x3D; a + 7\n\n\n등호 기준으로 오른쪽에 있는 무언가를 왼쪽에 담는다\n같다에는 &#x3D;&#x3D; 사용\n&#x3D;&#x3D; : 같다\n!&#x3D; : 같지 않다\n\n\n\n대문자와 소문자의 엄격한 구분\n대부분의 첫글자는 소문자로 시작한다.var nameOfYou &#x3D; &quot;홍길동&quot;\n카멜케이스(camel-case)\n언어에 따라 다르다\n\n\n\n키워드(keyword)\n약속어 (Swift에서 특별한 의미로 사용하겠다고 미리 정해놓은 단어)\n약 70여개 존재\n참고: [[https://www.tutorialkart.com/swift-tutorial/swift-keywords/]]\n\n\n다른 의미로 사용 불가능var\nfunc\nif\n\n주석 (comment)\n컴퓨터가 코드를 읽지 않아도 된다고 알려주는 부분\n&#x2F;&#x2F;: 한 줄 주석\n&#x2F;* *&#x2F;: 여러줄 주석 print(&quot;Hello, Swift!&quot;)\n&#x2F;&#x2F; print(&quot;Hello, Swift!&quot;)\n&#x2F;* \nprint(&quot;Hello, Swift!&quot;)\n&#x2F;* \nNested Comment\n*&#x2F;\nprint(&quot;Hello, World!&quot;)\n*&#x2F;\n\n세미콜론(;) 규칙 (semicolon)\nSwift에서 각 라인의 마지막에 붙는 세미콜론(;)은 선택사항var name &#x3D; &quot;Swift&quot;\nprint(&quot;Hello, World!&quot;)\nprint(&quot;Hello, World!&quot;); print(&quot;Dream&quot;);\n\n&#x2F;&#x2F;print(&quot;&quot;);\n\n줄 맞추기\n일반적으로 중괄호 안에서 들여쓰기(indentation)을 통해 코드의 가독성을 높였다if true  &#123;\n\tprint(&quot;안녕하세요&quot;)\n&#125;\n\n출력문(print)print(&quot;Hello, World&quot;)\nprint(&quot;안녕하세요&quot;)\nprint(5)\nprint(3 + 4)\nprint(3.14)\n","slug":"Allen/2022-09-20-Allen02","date":"2022-09-19T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"82a0cf49292d5e4a2482e5b47ada0044","title":"10)🍎Swift - Struct vs Class","content":"구조체(struct)와 클래스(class)Swift에는 두 가지 데이터 타입이 있습니다. 바로 struct와 class입니다. 어느 정도 감으로 사용하고 있었지만 정확하게 알아보고 싶어서 공부를 해보겠습니다.\n값 타입 vs 참조 타입정의의 차이로 설명하자면 class는 참조 타입, struct는 값 타입입니다. 값 타입인 struct에 소속된 인스턴스들은 값을 복사하여 새로운 인스턴스를 만들어 사용합니다. 참조 타입인 class에 소속된 인스턴스들은 참조 값이 전달됩니다. \n할당 메모리 영역Struct값 복사 방식을 사용하는 구조체는 메모리의 스택 영역에 할당됩니다. 따라서 스택 영역의 특징들을 갖습니다.\n\nThread-Safe하다. (스레드가 독립적으로 사용)\n한 번의 명령으로 할당&amp;해제 가능 (스택 포인터 사용)\n컴파일 시간에 크기 배정\n\nClass참조 방식을 사용하는 클래스는 메모리의 힙 영역에 할당됩니다. 따라서 힙 영역의 특징들을 갖습니다.\n\n런타임에 크기가 배정된다.\nThread-Safe하지 않다. (스레드가 공유하여 사용)\n\n권장하는 타입은?애플은 되도록이면  struct를 사용하는 것을 권장하고 있습니다. 메모리 관리 시에 별도의 연산 과정이 필요하지 않고 속도도 빠르기 때문입니다. 그렇다면 class 는 왜 사용할까요?\n상속class 는 상속이 가능합니다. protocol을 사용하여  기존의 class에서 확장된 버전의 class를 사용할 수 있습니다. 이 내용은 추후에 따로 다루고 링크를 남겨두도록 하겠습니다!\n그럼 언제 뭘 쓸까요?그렇다면 언제 struct를, 언제 class를 사용해야 할까요?위에서 한 번 언급했던대로 애플은 struct를 사용하는 것을 권장하고 있습니다. Swift의 struct는 다른 언어에서는 class만이 갖고 있는 편리한 기능들을 상당 수 지원합니다. Swift의 struct는 저장&#x2F;연산 프로퍼티, 메서드, 심지어 프로토콜까지 사용할 수 있습니다. 실제로 애플은 대부분의 표준 라이브러리(숫자, 문자열, 배열, 딕셔너리 등)에 struct를 사용했습니다.\nobj-c 언어와 상호 이용할 때는 class를 이용obj-c의 API를 사용하여 데이터를 처리할 때는 class를 사용해야만 합니다. 따라서 이런 경우에는 클래스를 사용할 수 밖에 없습니다.\n고유한 값에 대한 제어가 필요할 때는 class 이용class는 참조 타입이기 때문에 어느 한 곳에서 값을 수정하더라도 앱의 모든 곳에서 변경이 일어납니다. 이런 현상을 의도적으로 원한다면  class를 사용하면 좋습니다.\n상속과 공유를 모델링 할 때는 struct를 이용class와 struct는 모두 상속을 지원합니다. 하지만 struct는 class로부터 상속되지는 못하고, protocol로부터만 차용될 수 있습니다.protocol은 클래스, 구조체, 열거형 데이터들이 상속할 수 있지만 class는 같은 class들끼리만 상속이 가능하기 때문에 데이터를 설계할 때 우선 protocol을 사용해보는 것을 추천합니다.\n참고\n","slug":"Swift/2022-09-20-Swift10","date":"2022-09-19T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"b08c3ce9980327554bb7435efb5f3b94","title":"1)🧰 Swift - 컴퓨터의 동작 원리","content":"이번에 Swift 언어와 iOS의 기본에 대해 부족하다는 생각이 들어서 앨런님의 온라인 부트캠프를 수강하게 되었습니다. 매주 내용들을 정리해보며 공부해볼 생각입니다!앨런 Swift문법 마스터 스쿨 (온라인 BootCamp - 2개월과정)\nCS 101컴퓨터의 기본 구조와 동작 원리폰노이만 구조\n\n\n\n\n\n\n\n\nCPU ↔️ RAM(메모리) ↔️ HDD\n\n하드디스크의 프로그램이 램에 복사되어 올라간다.\n프로세스(Process): 실행중인 프로그램\n\n\n\n메모리 구조\n램은 코드(프로그램), 데이터, 힙, 스택의 구조로 나뉘어있다.\n프로그램은 램의 코드 공간에 저장된다.\n프로그램이 수행되며 생성되는 데이터는 데이터, 힙, 스택의 공간에 저장된다. \n램의 모든 공간에는 주소가 부여되어 있다.\n하드웨어적으로 나뉘어져 있는 것이 아니라 OS가 나누어 관리한다.\n\n\nCPU는 한 번에 한 가지 일처리만 할 수 있다.\n멀티코어와 쓰레드로 어느정도 발전했다.\n\n\n\nCPU와 메모리의 동작, 프로그래밍 언어CPU와  메모리의 동작\nCPU는 제어장치 + 연산장치\n제어장치: PC(프로그램 카운터), 메모리 주소 레지스터, 메모리 버퍼 레지스터, 명령 레지스터\n명령어가 한줄씩 실행되도록 통제한다.\n\n\n연산장치: ALU(산술 논리 장치)\n캐시 메모리\n\n\nRAM에 올라오는 것들\n시스템 S&#x2F;W (OS)\n응용 S&#x2F;W (앱, 프로그램)\n코-데-힙-스의 형태\n\n\n\n\nROM\n비휘발성\nPOST(점검), ROM-BIOS(기본 입출력 활성), Boot(OS 복사)\n\n\n\n프로그래밍 언어\n컴퓨터는 0과 1밖에 이해하지 못한다.\n기계어 ➡️ 어셈블리어 ➡️ 고급언어\n기계어: 실제 CPU가 받아들여 실행할 수 있는 언어\n어셈블리어(저급언어): 기계어를 인간이 읽을 수 있는 형태로 표현한 언어\n고급언어: 인간이 논리적인 생각대로 코드를 작성할 수 있는 언어\n고급언어 ➡️ 기계어 &#x3D; 컴파일\n\n\n\n메모리의 저장방식메모리의 저장 방식과 2진법&#x2F;16진법\n10진법: 0~9까지의 숫자를 수로 표현\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …\n123 &#x3D; 1 x 10^2 + 2 x 10^1 + 3 x 10^0\n\n\n2진법: 0과 1 두 개의 숫자로 수를 표현\n00, 01, 10, 11, …\n101(2) &#x3D; 1 x 2^2 + 0 x 2^1 + 1 x 2^0\n\n\n컴퓨터는 2진법을 사용한다\n0 &#x3D; off, 1 &#x3D; on\n실질적인 데이터의 저장\n1 bit &#x3D; 2가지, 2 bit &#x3D; 2^2 &#x3D; 4가지, 3 bit &#x3D; 2^3 &#x3D; 8가지, …\n8-bit &#x3D; 1-byte &#x3D; 2^8 &#x3D; 256가지\n컴퓨터에서 데이터를 다루기 위해 사용하는 기본 단위\n\n\n1100 0010(2) &#x3D; 194\n1111 1111(2) &#x3D; 255\n글자 1개 &#x3D; 1-byte\n\n\n\n\n10진법, 2진법, 16진법의 표현\n10진법: 1, 2, 3, …\n2진법(0b): 0b00, 0b01, 0b10, …\n16진법(0x): 0x01, 0x02, 0x03, …\n\n\n\n2진법과 16진법\n1100 0010\n1개의 니블(4자리)는 16개의 데이터를 표현\n2개의 니블 &#x3D; 16진법의 수 2개로 표현 가능\n인간의 눈에 보기 편하다\n\n\n0b11000010 &#x3D; 0xC2\n\n\nex) 유니코드(0x0061), rgb컬러코드(#ff00ff)\n\n참고\n32-bit 컴퓨터: CPU가 한 번에 처리할 수 있는 bit가 32개\n2^32 &#x3D; 4GB\n\n\n64-bit 컴퓨터: CPU가 한 번에 처리할 수 있는 bit가 64개\n2^64 &#x3D; 16EB\n\n\n\n메모리에서 음수의 표현 방법2진법에서 음수를 표현하는 방식\nMSB(최상위비트)를 부호비트로 사용\n부호와 절대치 방식 (잘못된 방법)\n0010 1010 &#x3D; 42\n1010 1010 &#x3D; -42\n컴퓨터에게 계산 시 도움이 되지 않는다\n\n\n2의 보수를 사용\n보수 &#x3D; 수를 채우기 위해 필요한 수\n2의 보수 &#x3D; 1의 보수 + 1\n0010 1010 ➡️ 1101 0101 ➡️ 1101 0110\n\n\n\n\n\n","slug":"Allen/2022-09-19-Allen01","date":"2022-09-18T15:00:00.000Z","categories_index":"AllenBootCamp","tags_index":"Swift,iOS,Allen","author_index":"nomatterjun"},{"id":"feb104f2e415f3c30b5b2264f2206c66","title":"9)🍎Swift - ARC(strong, weak, unowned)","content":"Swift 문서에는 오랜만이네요. 최근 파이썬만 다루다보니 Swift 쪽 밀린 공부가 산더미에요.\n오늘은 ARC에 대해 알아볼겁니다. 이야기는 계속 들어왔고 참고하는 코드들에서도 매우 자주 보였는데 이번에 제대로 알아보고 가봐야겠습니다.\nARC (Automatic Reference Counting)이름에서 알 수 있듯이 ARC는 참조와 관련된 기능입니다. 그리고 보기만해도 기분이 좋아지는 Automatic한 기능입니다. \n한 마디로 쉽게 넘기면 ARC는\n\n\n\n\n\n\n\n\n\n자동으로 메모리를 관리해주는 아주 간편한 기능입니다. \n여기서 조금 더 들어가면 ARC는,\n\n\n\n\n\n\n\n\n\n컴파일 타임에 자동으로 retain, release 코드를 생성해주는 기능입니다. retain한 횟수를 추적하며 더 이상 참조되지 않는 인스턴스를 release해주는 것 이라고 설명할 수 있습니다.\n모든 기기의 메모리(Heap) 영역은 유한된 자원입니다. 따라서 언제나 최적화가 필요하고, 가볍게 유지할 필요가 있죠!\nSwift가 공개되기 이전 Obj-C 언어로 iOS 앱을 개발했던 시절에는 이 메모리 관리를 개발자가 직접 수동으로 해주어야 했다고 합니다. 이때의 메모리 관리 방식을 MRC(Manual Reference Counting)이라고 부릅니다.\n\nretain: reference count를 증가시켜 객체가 유지되도록 보장\nrelease: reference count를 감소시켜 더 이상 사용되지 않는 객체가 메모리에 유지되는 것을 방지\n\n이 두 기능을 계속해서 반복해서 사용하며 메모리를 관리해주어야 했던 것이죠. 정말이지 너무 번거롭지 않나요..? 그래서 애플은 개발자들의 편의성을 위해 ARC를 등장시키게 된 것 입니다.\nARC는 컴파일 타임에 수행됩니다. 그런데 수행되는 방식이 각각의 코드 중간중간에 자동으로 retain 코드와 release 코드를 삽입시키는 방식입니다.\n컴파일 타임에는 단순히 코드를 삽입만 해주고, 런타임동안 코드가 실행되며 reference count를 증감시킵니다. 그러다가 count 값이 0이 되면 deinit을 통해 메모리에서 해제시키는 것이죠!\n자 그런데, 자동으로 관리를 해주는 것이 아무리 편하더라도 개발자가 어느정도 메모리에 관여를 하고 싶을 때가 있겠죠? 그런 경우를 위해서 strong, weak, unowned가 존재하는 것 입니다.\nstrong (강한 참조)\n선언할 때 아무 키워드도 적어주지 않으면 기본값(default)으로 설정\n해당 인스턴스의 소유권을 가짐\n참조하는 인스턴스의 reference count 증가\nstrong reference count가 0이 되면 객체는 deinit\n값 지정 시점에 retain, 참조 종료 시점에 release\n\nvar david: Person? = Person(name: \"David\")\n// reference count ++\n\ndavid = nil // reference count --\n\n강한 참조를 사용할 때는 주의할 점이 하나 있습니다. 바로 **강한 참조 순환(Strong Reference Cycle)**입니다. \nclass Strong &#123;\n\tvar strong: Strong? = nil\n&#125;\n\nvar strong1: Strong? = Strong()\nvar strong2: Strong? = Strong()\n\nstrong1?.strong = strong2\nstrong2?.strong = strong1\n\nstrong1 = nil\nstrong2 = nil\n\n위 예시를 보면 strong1과 strong2는 서로의 strong을 참조하고 있습니다. 이 때, strong은 강한 참조 객체라서 nil을 주기 전까진 해제되지 못합니다.그런데 마지막 strong1과 strong2에 nil 값을 주려 할 때, 서로가 서로를 강하게 참조하고 있어 각각의 객체 변수는 메모리 해제가 되었지만, 객체 자체는 여전히 서로를 참조하며 메모리 해제가 되지 못합니다.이렇게 되면 객체 변수는 이미 해제가 되어 객체에 접근할 방법도 없고, 객체를 메모리에서 해제할 방법도 없어지게 됩니다.영원히 메모리에 머물러 메모리 누수가 발생하게 되는 것이죠.\n이런 현상을 해결하기 위해 weak (약한 참조)가 필요합니다.\nweak (약한 참조)\n해당 인스턴스의 소유권을 가지지 않음\n주소값만 가짐으로서 포인터처럼 사용\nreference count를 증가시키지 않음\nweak reference count가 0이 되면 dead\n메모리 해제될 때 자동으로 nil로 초기화\n해당 인스턴스가 nil 일 수 있기 때문에 항상 optional이어야 함weak var david: Person? = Person(named: \"David\")\n// 바로 객체 해제, nil\n\n그렇다면 weak는 어떻게 참조 순환을 해결할까요?\nclass Strong &#123;\n\tweak var strong: Strong? = nil\n&#125;\n\nvar strong1: Strong? = Strong()\nvar strong2: Strong? = Strong()\n\nstrong1?.strong = strong2\nstrong2?.strong = strong1\n\nstrong1 = nil\nstrong2 = nil\n\n위와 같은 예시이지만 각각의 객체 변수가 weak(약한 참조)이기 때문에 ARC가  메모리에서 해제될 때 자동으로 객체까지 메모리에서 해제시켜 줍니다. \n참조 순환 문제가 해결되었네요!\nunowned (미소유 참조)\n해당 인스턴스의 소유권을 가지지 않음\nunowned reference count가 0이 되면 free\n해당 인스턴스를 nil로 초기화하지 않음\n\n그래서 셋의 차이는?\nstrong\n메모리에서 해제되는 것을 막기 위해 사용\nReference Count 1 증가\n\n\nweak\n순환 참조의 가능성이 있을 경우 사용\n항상 var \nReference Count 변동 X\n\n\nunowned\n\n사이드 테이블 (Side Table Entry)설명의 순서는 강한 참조 순환 때문에 strong ➡️ weak ➡️ unowned의 순서로 했지만 개념을 자세히 살펴보면 strong ➡️ unowned ➡️ weak의 순서로 보는 것이 맞습니다.\n강한 참조 변수와 미소유 참조 변수는 객체를 직접 참조하지만, 약한 참조 변수는 객체의 사이드 테이블을 참조하기 때문입니다.\n내부적으로 객체가 생성되면 weak, unowned, strong의 종류에 따라 따로 reference count를 세는 것이 아니라 모든 종류의 reference count를 전부 셉니다.\n순차적으로 살펴보면,strong reference count가 0이 되면 객체는 deinit 되지만 메모리에는 남아 있습니다.\n이후 unowned reference count를 체크하여 0이 아니라면 DEINITED 상태로 메모리에 쭈욱 남아있고, 0이라면 free 됩니다.\n그 이후에는 weak reference count를 체크하여 0이 아니라면 FREED 상태가 되어 사이드 테이블이 메모리에 남아있고, 0이 되었을때야 모든 reference count가 0이 되어 사이드 테이블이 메모리에서 해제되며 객체가 DEAD 상태가 됩니다.\n\n위 State Machine 그래프로 한눈에 알아보기 쉽게 정리해볼 수 있습니다.\n참고\n","slug":"Swift/2022-09-09-Swift09","date":"2022-09-08T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"880e35cd89b3cfce92587e2ccc115063","title":"4)📘 Python - Context Manager","content":"contextManagerContext Manager는 많은 코드 시간과 리소스 중에 정확히 원하는 시간과 리소스를 사용할 수 있도록 도와주는 기능입니다. 우리가 무심결에도 사용하던 with문 또한 Context Manager 중의 하나입니다. 이 with문은 보통 파일 하나를 열어 수정할 때 자주 사용됩니다.\n\n\n\n\n위 두가지 코드는 같은 역할을 수행합니다. 아래의 with문을 사용한 경우가 훨씬 가독성에도 좋고 사용하기도 편해보입니다. 이런 장점들 덕분에 Context Manager는 여러 프로그래머들이 애용하는 기능이 되었습니다.\ncontextlibwith문은 이미 굉장히 편리하고 유용하지만, contextlib 모듈을 통해 직접 Context Manager를 만들 수도 있습니다. .__enter__()와 .__exit__()를 사용해서 구현하는 방법과 contextlib.contextManager() 데코레이터를 사용하는 방법이 있습니다. 하나씩 살펴보도록 하겠습니다.\n__enter__() + __exit__()\n\nFile 클래스는 __enter__ 메서드를 호출하여 f_name과 method를 받아와 __init__() 메서드를 통해 파일을 열고 반환합니다. 이렇게 열린 파일은 self.f로서 접근 가능하고 블록 안에서는 with as문을 통해 file이라는 이름으로 명명하였기 떄문에 file.write(&quot;abc&quot;)와 같이 파일을 수정할 수 있습니다. 블록이 끝나면 __exit__()문이 호출되고 파일을 닫습니다.\n이떄 __exit__()  메서드의 type, value, traceback 변수는 사용되지 않은 것을 볼 수 있는데요, 이 세 변수는 예외처리가 발생할 경우에 사용됩니다. __exit__() 메서드가 True를 반환한다면 예외 처리가 적용된 것을 의미하고, 아니라면 처리되지 않은 것으로 여겨 with문의 부분에서 에러가 발생하게 됩니다. \n@contextmanager 데코레이터@contextmanager 데코레이터를 사용하여 Context Manager를 만들 수도 있습니다. contextlib 모듈은 이때 사용되게 됩니다. 위 __enter__() + __exit__()의 방법보다 더욱 간단하게 작성할 수 있습니다.\n\n\nopen_file() 메서드의 위에 데코레이터의 형식으로 @contextlib.contextmanager가 작성되어 있는 것을 볼 수 있습니다. 그런데 처음 보는 문법들이 보입니다. 저는 yield문이 생소했는데요, 이를 이해하기 위해서는 yield문 뿐만 아니라  Generator 또한 이해해야 합니다.\nyieldyield는 흔히 사용되는 return과 유사한 기능을 하는 키워드입니다. 한가지 예시를 보겠습니다.\n\n\nreturn의 경우 모든 결과값을 얻어내기 전까지는 결과값을 받아낼 수 없습니다. 따라서 이 예시는 실행에 최소 16초가 걸리게 됩니다.\n\n\n\n\n\n\n\n\n\nABCDEFGHIJKLMNOP\n이번에는 비슷한 동작을 하는 yield의 경우를 보겠습니다.\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\n…\nP\n사용법이 return과는 조금 다른 것을 볼 수 있습니다. yield는 일반적인 형태의 변수를 반환하는 것이 아닌, generator 타입의 객체를 반환합니다. generator 객체는 어떤 시점에 필요한 데이터를 즉석에서 만들어내어 반환하는 객체입니다.\ngenerator의 장점은 여기에 있습니다. 수행 시간이 오래 걸리는 작업에서 모든 결과값이 나오지 않고 일부분만 나오더라도 해당 결과값으로 다른 작업을 수행할 수 있다는 점이 매우 매력적입니다.\n그러면 다시 Context Manager로 돌아갑시다. 위의 예시를 다시 한번 가지고 오겠습니다.\n\n\n우리는 이제  yield 가 어떤 역할을 하는지, 어떤 형태로 데이터를 생성하는 알고 있습니다. yield의 앞 부분은 __enter__(), yield의 뒷부분은 __exit__()부분이라고 생각해도 무방할 것 같습니다.\n\n\n사용할때는 위와 같은 순서대로 수행됩니다. yield의 앞부분은 with문에 진입할 때, yield의 뒷부분은 with문이 끝나고 종료될 때 실행됩니다. \n","slug":"Python/2022-07-16-Python04","date":"2022-07-15T15:00:00.000Z","categories_index":"python","tags_index":"Python,Context Manager","author_index":"nomatterjun"},{"id":"c4627b4e684e76e57427d504523ee0e8","title":"3)📘 Python - Covariance & Contravariance","content":"Covariance &amp; Contravariance파이썬의 경우를 살펴보기 전에, Covariance와 Contravariance가 무엇인지 알아보기 위해 정적 프로그래밍 언어의 경우를 살펴보겠습니다.\n예를 들어, 상위타입 Animal과 서브타입 Cat이 있다고 생각해볼게요. 정적 프로그래밍 언어에서 Cat 타입은 Animal 타입의 표현식들을 아마도 사용할 수 있을 것입니다. 왜 “아마도”라는 애매한 말을 붙였냐면, “상위타입과 서브타입에서 서로의 표현식들을 사용할 수 있는가?”는 해당 언어의 Covariance와 Contravariance 속성에 따라 달라지기 때문이죠!\nCovariance &amp; ContravarianceCovariance\nT’가 T의 서브 타입이라면, C&lt;T’&gt;는 C의 서브타입이다.\n\nCovariance 속성을 가질 경우, 예시로 들었던 서브타입 Cat은 상위타입 Animal보다 더 작고 세분화된 타입의 표현식들을 사용할 수 있습니다. \n이 경우에는 이해하기가 비교적 쉽습니다. 일반적인 Polymorphism의 특성과 동일하기 때문이죠. 하위 클래스는 상위 클래스의 특성들을 상속받아 사용할 수 있습니다!\nContravariance\nT’가 T의 서브 타입이면, C는 C&lt;T’&gt;의 서브타입이다.\n\n반대로 Contravariance 속성을 가질 경우에는 상위타입 Animal이 서브타입 Cat의 세분화된 표현식들을 사용할 수 있게 됩니다.\nInvariance이 두 속성 외에도 Invariance라는 속성도 있습니다. 이 경우에는 서로의 표현식을 양 쪽 모두 사용할 수 없습니다.\nPython의 Covariance &amp; Contravariance이제 이 개념을 파이썬의 예시에 적용시켜보겠습니다. 상위 클래스 Animal과 하위 클래스 Cat 이 있다고 생각해봅시다. 그리고 withList[Animal]이라는 Cat 클래스를 인자로 받는 함수가 있다고 해볼게요. 이 함수의 인자에 Cat을 사용할 수 있을까요? withList[Cat]과 같이 말이죠.\n보통의 경우 이런 사항은 Covariance하게 처리됩니다. “사용할 수 있다”는 쪽인 것이죠. 하지만 확신할 수 없습니다. 실제로는 Contravariance하게 동작하고 있을 수도 있는 것이죠. 타입 체커나 컴파일러에 따라 다르다는 것입니다.\n파이썬에서는 이 문제를 해결하기 위해 convariant = True나 contravariant = True와 같이 직관적이고 간단한 인자를 하나 추가해줄 수 있습니다. 그리고 이러한 옵션을 줄 경우에는, 변수의 뒤에 _co, _contra를 붙여주는 것이 표기적으로 좋습니다.\n예시를 통해 한번 볼게요.\nfrom typing import TypeVar, Generic, Iterable, Iterator\n\nList_co = TypeVar('List_co', covariant = True)\n\nclass ImmutableList(Generic[List_co]):\n  \n  def __init__(self, items: Iterable[List_co]) -> None:\n    ...\n    ...\n   \n  def __iter__(self) -> Iterator[List_co]:\n    ...\n    ...\n    \nclass Animal():\n  ...\n  \nclass Cat(Animal):\n  ...\n\nIterable 타입을 모두 받는 List_co 타입을 covariant 속성을 준 상태로 만들어 준 코드입니다. 그리고 상위 클래스 Animal과 서브 클래스 Cat도 있네요.\ndef list_animals(animals: ImmutableList[Animal]) -> None:\n  for animal in animals:\n    print(animal)\n    \ncats = ImmutableList[Cat()]\nlist_animals(cats)\n\nImmutableList[Animal]을 인자로 갖는 list_animals 함수를 만들어주고 ImmutableList[Cat()]을 인자로 넣어보았습니다. covariant 속성을 true로 주었기 떄문에 아무 문제 없이 동작합니다. \n","slug":"Python/2022-05-06-Python03","date":"2022-05-05T15:00:00.000Z","categories_index":"python","tags_index":"Python","author_index":"nomatterjun"},{"id":"e585a8a76173e8bfa9151f74e32ccb79","title":"2)📘 Python - typing","content":"TypingTyping 모듈은 파이썬에서 지원하는 타입 힌팅(Type Hinting) 모듈입니다. Type Checking도 아니고 Hinting이라니, 참 요상하죠..? 파이썬이 이런 모듈을 지원하는 것은 파이썬의 독특한 특징이 그 이유입니다.\n왜 Typing 모듈이 필요할까?파이썬은 동적 프로그래밍 언어입니다. 동적 프로그래밍 언어는 컴파일 타임에  타입을 정하는 것이 아니라, 프로그램 실행 중에 타입이 결정됩니다. 그런데 파이썬은 여기서 더 나아가서 실행 중에도 오브젝트(변수)의 타입을 자유롭게 변경할 수 있습니다. \na = 1\ntype(a) # int\na = \"1\"\ntype(a) # str\n\n이렇게 파이썬은 타입에 대해 굉장히 유한 것을 볼 수 있습니다. 이런 파이썬의 특징 덕분에 파이썬을 이용하여 코드를 짤 때 프로그래머는 에러를 훨씬 덜 보게 되고 빠른 개발이 가능해집니다. 하지만 이런 자유로움은 당연히 코드가 길어지고 프로젝트가 커질 수록 버그를 일으킬 확률을 높이는 주범이 됩니다.\n그래서 파이썬은 Typing 모듈을 사용하기로 하였습니다. Typing 모듈은 타입을 검사(체킹)하는 것이 아니라 개발자가 코드를 읽기 편하고 PyLint와 같은 도구가 활용할 수 있도록 객체들에 정보를 추가해주는 모듈입니다.\n어떻게 쓰죠?기본적인 변수형에 사용하기 위해서는 변수이름: 타입과 같이 사용할 수 있습니다.\nnum: int = 5\nstring: str = \"Hello World\"\nletters: list = [\"A\", \"B\", \"C\"]\nstudent: dict = &#123;\n  \"name\": \"Chris\",\n  \"age\": 25,\n  \"phone\": \"01012345678\"\n&#125;\n\n함수에도 def 함수이름(필수인자: 타입, 선택인자: 타입 =  기본값) -&gt; 반환타입: 과 같이 사용할 수 있습니다.\ndef foo(arg: int, arg_optional: str = \"A\") -> str:\n  return \"B\"\n\n\n\n이렇게 보니 사용법은 Swift의 기본 문법과 똑같네요.. 사용하는데 어려움은 없을 것 같습니다.\n어떤 타입들이 있나요?유용하게 사용할 수 있는 타입들과 사용 예시를 간단하게 쭉 살펴보겠습니다.\n내장 자료 구조Listfrom typing import List\nletters: List[str] = [\"A\", \"B\", \"C\"]\n\nDictfrom typing import Dict\nTimeZone: Dict[str, str] = &#123;\n  \"KR\": \"South Korea\",\n  \"CN\": \"China\",\n  \"US\": \"United States\",\n  \"JP\": \"Japan\"\n&#125;\n\nTuplefrom typing import Tuple\nstudent: Tuple[str, int, bool] = (\"Chris\", 25, True)\n\nSetfrom typing import Set\nletters: Set[str] = &#123;\"A\", \"B\", \"C\"&#125;\n\n\n\nFinalFinal은 더이상 값의 변경이 없는 경우 사용하면 편리합니다.\nfrom typing import Final\nDEFAULT_TIMEOUT_SECONDS: Final[int] = 5\n\n\n\nUnion하나의 객체에 여러 타입의 값을 할당하고 싶을 떄 사용하면 편리합니다.\nfrom typing import Union\ndef foo(num: Union[int, float]) -> int:\n  return int(num)\n\n\n\nOptionalSwift의 optional과 동일합니다. nil 값을 가질 수 있습니다. 다만 ? 대신 Optional[]로 표기하고 nil이 아니라 None을 사용합니다.\ndef foo(url: str, params: Optional[str] = None) -> bool:\n  if params:\n    return True\n  else:\n    return False\n\n\n\nCallableCallable은 함수입니다. 함수를 변수에 저장하거나 인자로 사용할 때, 혹은 반환값으로 사용할 때 Callable 타입을 사용하면 편하게 사용할 수 있습니다.\n형식은 함수이름: Callable[[인자타입, 인자타입, ...], 반환타입]과 같이 사용할 수 있습니다.\nfrom typing import Callable\ndef repeat(greet: Callable[[str], str], name: str, times: int = 2) -> None:\n  for _ in range(times):\n    print(greet(name))\n\n>>> greet: Callable[[str], str] = lambda name: f\"Hi, &#123;name&#125;!\"\n>>> repeat(greet, \"John\")\nHi, John!\nHi, John!\n\n\n\n타입 추상화 (duck-type)Iterable모든 iterable들에 적용할 수 있습니다. \nfrom typing import Iterable\ndef foo(ints: Iterable[int]) -> list[str]:\n  return [str(x) for x in ints]\n\n>>> print(foo(range(1, 3)))\n['1', '2']\n\n\n\nMappingDict 형 Iterable입니다.\nfrom typing import Mapping\ndef foo(my_mapping: Mapping[int, str]) -> list[int]:\n  my_mapping[5] = \"maybe\"\n  return list(my_mapping.items())\n\n>>> print(foo(&#123;3: 'yes', 4: 'no'&#125;))\n[(3, 'yes'), (4, 'no'), (5, 'maybe')]\n\n\n\nMutable Mappingfrom typing import MutableMapping\ndef foo(my_mapping: MutableMapping[int, str]) -> set[str]:\n  my_mapping[5] = \"maybe\"\n  return set(my_mapping.items())\n\n>>> print(foo(&#123;3: 'yes', 4: 'no'&#125;))\n&#123;(3, 'yes'), (4, 'no'), (5, 'maybe')&#125;\n\n\n\n제네릭 타입TypeVarJava의 Generic Type과 같이 타입을 미리 정해주지 않고, 그때 그때 필요한 타입이 지정될 수 있도록 할 수 있습니다.\nfrom typing import TypeVar\n\nT = TypeVar('T')\n\ndef temp(var: List[T]) -> T:\n  return var[0]\n\n>>> print(temp([1, 2, 3, 4, 5]))\n>>> print(temp(['a', 'b']))\n1\na\n\n\n\nNamed Tuple마치 Dict 타입 객체처럼 튜플에 key 값을 줄 수 있습니다. class형 문법으로서 사용성과 가독성도 향상 되었습니다. 또한 default 값을 줌으로서 객체를 상속받아 사용할 수 있습니다!\nfrom typing import NamedTuple\n\nclass Student(NamedTuple):\n  name: str\n  age: int\n  graduated: bool = False\n\ntommy = Student(name='Tommy', age=26)\n\n>>> tommy\nStudent(name='Tommy', age=26, graduated=False)\n\n","slug":"Python/2022-05-05-Python02","date":"2022-05-04T15:00:00.000Z","categories_index":"python","tags_index":"Python,typing","author_index":"nomatterjun"},{"id":"a531efef964a2f4190bd13943c878d7b","title":"1)📘 Python - asyncio","content":"asyncioasyncio란?asyncio는 파이썬에서 사용할 수 있는 비동기 프로그래밍 모듈입니다. async&#x2F;await 함수를 통해 동시적으로 여러 작업들을 수행시킬 수 있습니다. 코루틴을 사용하여 작동하며, 이벤트 루프를 생성하고 관리함으로서 네트워크 작업, 서브-프로세스, OS 신호 핸들링 등을 할 수 있습니다.\n이벤트 루프asyncio를 사용한 프로그램은 이벤트 루프가 처음이자 곧 끝이라고 할 수 있습니다. 이벤트 루프는 비동기성 작업들을 수행하고, 작업이 끝나면 응답을 받아 처리합니다. \nasyncio.get_running_loop() \t\t# 현재 스레드에서 실행중인 이벤트 루프를 반환\nasyncio.get_event_loop()\t \t\t# 현재 이벤트 루프를 반환합니다.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 현재 이벤트 루프가 설정되지 않았다면, 새로 만듭니다.\nasyncio.set_event_loop(loop)\t# loop를 현재 이벤트 루프로 설정합니다.\nasyncio.new_event_loop()\t\t\t# 새로운 이벤트 루프를 만듭니다.\n\n\n\n코루틴코루틴은 스레드와 비슷하게 동시성 프로그래밍이 가능할 수 있도록 고안된 개념입니다. 스레드가 많이 쓰이며 코루틴은 관심을 잃었었지만, 스레드의 데드락과 같은 문제점들 때문에 다시 주목받기 시작했습니다. 코루틴은 스레드를 사용하지 않으며, 메인 스레드에서 여러 작업들을 번갈아가며 수행합니다. \n이렇게만 설명하면 동기성 프로그래밍과 같은 개념인 것 같지만, 코루틴을 사용하면 함수의 실행을 탈출 지점이 아니여도 중간에 중단하고 다른 함수로 넘어갈 수 있습니다. 다른 작업을 마치고 나면, 다시 해당 함수의 멈춘 부분으로 돌아가 남은 작업을 마저 할 수도 있습니다. \n파이썬에서 asyncio가 특히 유용한 이유가 있는데, 파이썬 특유의 GIL(Global Interpreter Lock)으로 인해 한 번에 하나의 스레드만 파이썬 코드를 실행할 수 있기 때문입니다. 동시에 여러 스레드를 실행시킬 수 없다는 것인데(스레드를 사용할 수는 있습니다), 이러면 스레드를 사용할 경우 context switching으로 인해 하나의 메인 스레드만 사용하는 것 보다 오히려 속도가 느려질 수 있습니다.\nasync func이벤트 루프를 가져오거나 만들었다면, run_until_complete()등의 함수로 태스크를 이벤트 루프에 등록할 수 있습니다. 코루틴을 만들기 위해서 async func를 사용하여 함수를 정의할 수 있습니다.\nrun_until_complete() 함수는 코루틴이 이벤트 루프에서 실행될 수 있도록 등록하고, 해당 코루틴이 종료될 때 까지 기다립니다. \n\n\nHello World!\n\n\n\nawaitawait은 코루틴 안에서 다른 코루틴을 실행하고, 해당 코루틴이 끝나는 것을 기다립니다. 코루틴 객체 외에도 Future 객체, Task 객체에도 사용할 수 있습니다.\n\n\nadd: 1 + 2\nprint_add: 1 + 2 &#x3D; 3\n\n\n\ncreate_task위와 같이 코루틴을 실행한다면, 단일의 코루틴만 실행하기 때문에 동기성 프로그래밍과 큰 차이가 없습니다. 동시에 여러 코루틴을 실행하기 위해서는 create_task() 함수로 이벤트 루프에 등록해주어야 합니다.\n\n\nTask 1\nTask 2\nTask 2 Done\nTask 1 Done\nAll Done\n\n\n\ngather등록해야 할 코루틴이 많을 경우 create_task()는 하나하나 등록해주어야 하기 때문에 번거롭습니다. 그럴떄는 gather()를 사용하여 한번에 등록할 수 있습니다. 또한 마지막 인자로 return_exception 값을 Bool 타입으로 줄 수 있는데, 기본값은 False로서 에러가 발생하면 즉시 모든 코루틴을 종료합니다. True로 설정시에는 아래처럼 에러가 난 코루틴 객체만 에러 정보를 포함하여 반환됩니다.\n\n\nTask A: factorial(2)\nTask B: factorial(2)\nTask C: factorial(2)\nTask A: factorial(2) &#x3D; 2\nTask B: factorial(3)\nTask C: factorial(3)\nTask B: factorial(3) &#x3D; 6\nTask C: factorial(4)\nTask C: factorial(4) &#x3D; 24\n[2, 6, 24]\n\nTask A: factorial(2)\nTask B: factorial(2)\nTask A: factorial(2) &#x3D; 2\nTask B: factorial(3)\nTask B: factorial(3) &#x3D; 6\n[2, 6, ValueError(&#39;Number should not be equal to 4&#39;)]\n\n\n\nwait_fortimeout도 설정이 가능합니다. wait_for() 함수를 사용해서요!\n\n\nTime Out!\n\n\n\nFuture, Taskasyncio에는 코루틴 외에도 비동기성으로 처리할 수 있는 객체들이 더 있습니다. \nCoroutine코루틴은 코루틴 함수에 의해 생성되는 객체를 말합니다. 위의 설명과 같이 async def를 사용하여 작성되고, await를 통해 return값을 받아올 수 있습니다.\n코루틴은 코루틴에서만 실행이 가능해서 코루틴을 최소 한 번은 실행해주어야 합니다. asyncio.run(async_func())와 같이 사용할 수 있습니다.\nTask위와 같이 asyncio.create_task()를 통해 코루틴을 Task로 만들 수 있고, 이벤트 루프에 스케줄링하여 실행 가능한 시점에 시작되도록 만들 수 있습니다. \nFutureFuture는 코루틴 내부의 코드가 아닌 코루틴을 호출한 논블럭 함수의 결과값입니다. 만약 비동기 작업이 결과값을 요구했을 때 완료되었다면 바로 결과를 얻을 수 있지만, 그렇지 않았다면 요청한 쪽의 흐름을 블럭할 수 있습니다. 함수의 처리 시점을 값이 필요한 시점으로 미룰 수 있는 효과가 있는 것이죠. \n\nresult(): 결과를 반환합니다.\ndone(): 작업이 완료되었는지 확인합니다.\ncancelled(): 작업이 취소되었는지 확인합니다.\nadd_done_callback(): 작업이 완료 됐을 때 콜백을 추가합니다.\nremove_done_callback(): 콜백을 제거합니다.\ncancel(): 작업을 취소합니다.\nget_loop(): 연결된 이벤트 루프를 반환합니다.\n\n","slug":"Python/2022-05-04-Python01","date":"2022-05-03T15:00:00.000Z","categories_index":"python","tags_index":"Python,asyncio","author_index":"nomatterjun"},{"id":"c6e16700a7ef39990817280778f95b8a","title":"8)🍎Swift - Coordinator 패턴.02","content":"TabBar + Coordinator 패턴코디네이터 패턴을 조금 응용하면 TabBar에도 적용을 할 수가 있습니다. 오늘은 단순 적용이기 때문에 코드 위주로 쓱쓱 지나갈게요!\n\n\n다른 기본적인 부분은 TabBar 구성과 동일합니다.\n중요한 곳은 바로 여기!\n\n\nHome이라는 페이지에는 Home Coordinator의 start()를 call해서 구성하는 부분이죠! 동시에 코디네이터 패턴을 적용시키기 위해  finishDelegate도 등록하면서 childCoordinator에 해당 코디네이터를 등록시켜주는 작업까지 이루어졌습니다. \n이번엔 Home Coordinator 파일을 살펴볼까요?\n\n\n이전 게시물의 코디네이터와 비슷한 구조를 지니고 있죠. Navigation Controller를 받아오고, View Model도 등록해주었습니다. \nlet homeStoryboard = UIStoryboard(name: \"Home\", bundle: nil)\nlet homeVC = homeStoryboard.instantiateViewController(withIdentifier: \"HomeVC\") as! HomeViewController\nself.homeViewController = homeVC\n\n이 부분은 제가 storyboard를 사용하는 것을 선호하기 때문에 이렇게 사용하였습니다.\n코드로 UI 구성을 하실 분들은\nself.homeVC = HomeViewController()\n\n이렇게만 넣어주시면 됩니다!\n","slug":"Swift/2022-04-12-Swift08","date":"2022-04-11T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"69ea212f10e69614cb613a9eeb1f8524","title":"7)🍎Swift - Coordinator 패턴.01","content":"진짜로 이 프로젝트가 이렇게 이거저거 많이 해보게 될 줄은 몰랐는데.. 아무래도 이거저거 너무 많이 해보느라 이해가 부족하게 넘어가는 부분도 있는 것 같아요. 마무리 되면 래핑을 한번 해봐야겠습니다 😭\n이번에는 Coordinator 패턴입니다.\nView Controller간의 Flow를 제어하는 객체를 두어서 뷰컨간의 전환을 안정적이고 쉽게 만드는 패턴인데요, 사실 제 프로젝트에는 당장 필요성은 못느끼고 있지만 또 당장 적용해볼수 있는 데 안해볼 수 없지 않습니까? ㅎㅎ;;\n그래서 해보기로 했습니다.\n오늘 도움을 얻은 게시물은\n\n\n\n\n\n\n\n\n\nCoordinator Pattern with Tab Bar Controller\n위 블로그 글 입니다!\nCoordinator Pattern코디네이터 패턴이란?코디네이터 패턴이란 위에서 간략하게 설명했듯이\n앱의 View Controller들 사이의 Flow Control과 Navigation을 관리해주는 패턴입니다. 코디네이터 패턴을 사용함으로서 화면의 흐름을 관리하기 쉽고, 또 뷰를 불러오는 코드에 재사용성을 부여해준다는 이점이 있습니다.\n원래의 방식자 원래라면 View Controller를 불러올 때 어떤 식으로 했나요? 스토리보드를 사용했다고 한다면\nlet storyboard = UIStoryboard(name: \"Main\", bundle: nil)\nlet mainViewController = storyboard.instantiateInitialViewController() as! MainViewController\nself.navigationController.pushViewController(mainViewController, animated: true)\n\n위처럼 아주아주 긴 코드를 새로운 뷰컨을 불러올때마다 입력하고 실행해야 했죠?\n화면이 많지 않은 앱이거나 하나의 화면에서 하나의 화면으로만 넘어가는 경우에야 전혀 문제가 될 게 없지만, 화면이 아주 많고 한 화면에서 여러가지 화면으로의 전환이 가능하다면 위 코드를 반복해서 계속 입력했을 거에요. \n코디네이터를 사용하면?\n\n네 엄청 복잡해보이죠..? 그냥 원래의 방식을 쓰고 싶어지죠..?\n하지만 한번 배워두면 분명 잘 써먹을거라 믿고 배워봅시다.\n그래서 저걸 어떻게 쓰죠?코디네이터 패턴을 사용하는 모든 앱에는 최소한 하나의 코디네이터가 필요합니다. 보통 가장 뿌리가 되는 코디네이터부터 만들기 시작하고, 일반적으로 AppCoordinator라고 부릅니다. 물론 여러개의 코디네이터를 사용할 수 있지만 우선 가장 뿌리가 되는 친구부터 만들어보겠습니다.\n\n\n마찬가지로 복잡해보이지만 앞에 만들었던 프로토콜대로 만든 것 뿐이에요!\n그리고 AppCoordinator를 init하는데 가장 좋은 곳은 AppDelegate라고 하네요\n이 AppDelegate라는 놈도 한번 제대로 공부해봐야하는데 잊고 있엇네요. 이참에 리스트에 올려두고.. 그런데 AppDelegate라는 놈은 iOS13 이후부터 SceneDelegate와 기능을 나누어갖게 되었습니다. 간단하게만 설명드리고 넘어가자면 앱의 진입지점을 정해주고 실행상태를 모니터링 해준다고 생각하시면 됩니다. (사실 저도 잘 몰라요 😓)\n그래서 SceneDelegate에 아래 부분을 추가해서 앱 실행시에 설정해줍시다!\n\n\n이제 이 앱은 실행시키면 아무것도 없는 비어있는 Navigation Controller만 띄우는 앱이 되었습니다. 하지만 사실은 DefaultAppCoordinator의 start 함수를 콜하여 실행시키고 있죠. 단지 아직 그 부분을 구현하지 않았을 뿐입니다.\n\n\n우선 동작하는 것을 확인하기 위해 이렇게 원하는 ViewController를 push해주는 코드를 넣어주면 해당 뷰컨이 앱 실행 초기화면으로 등장하는 것을 볼 수 있습니다!\n","slug":"Swift/2022-04-08-Swift07","date":"2022-04-07T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,Coordinator","author_index":"nomatterjun"},{"id":"4155e8969c3d99086cd0bca559bd0d29","title":"6)🍎Swift - MVVM, Clean Architecture","content":"이번 포스트에서는 제 프로젝트를 예시로 iOS 프로젝트에 MVVM+Clean Architecture 구조를 적용해보겠습니다!\n저번 포스팅을 작성하고도 헷갈리는 부분들이 많아서 계속해서 정보들을 찾아봤습니다. 그러다가 아주 좋은 포스트를 발견했는데, 오늘은 해당 포스트를 기반으로 내용을 정리해보겠습니다. 제 포스트를 보시는 분들도 아래 포스트를 자세히 읽어보는 것을 추천합니다 👍\n\n\n\n\n\n\n\n\n\n Clean Architecture and MVVM on iOS\nMVVM + Clean Architecture\n해당 게시물을 보면 위와 같이 크게 세 가지 레이어로 구성을 나누었습니다. 이런 의문점이 들 수 있습니다. 저번 포스트에서는 4가지로 나뉘었는데 Clean Architecture 구조가 아닌거 아닌가요?\nClean Architecture의 핵심은 의존성에 있습니다. 안쪽 레이어부터 바깥 레이어로의 의존성 방향이 있지만 않으면 레이어의 개수나 구조는 아무 상관이 없죠. 따라서 위와 같은 구조도 아무 문제가 없는 것입니다!\n위 게시물에 따른 레이어의 종류는 아래과 같습니다.\n\nPresentation Layer\nDomain Layer\nData Layer\n\nDomain LayerDomain Layer는 가장 안쪽의 레이어입니다. 따라서 아무런 의존성을 가지지 말아야하고, 독립되어 있어야합니다. 이로서 얻을 수 있는 이점으로는 아무론 종속성이 없기 때문에 테스트하기 매우 간편하다는 점입니다. 다른 파일의 수정이나 추가 없이 오직 Domain Layer에만 집중해도 결과가 도출되죠.\nEntities, Use Cases, Repository Interfaces들이 Domain Layer에 속합니다.\nPresentation LayerPresentation Layer에는 말 그대로 UI 요소들이 속합니다. 대표적으로 View Model이 여기에 속하여 Use Cases의 함수들을 호출합니다. \nPresentation Layer는 오직 Domain Layer에만 종속되어 있습니다.\nData LayerData Layer에는 Repository와 Data Sources들이 속합니다. 여기서 Repository는 외부의 Data Sources로부터 데이터를 받아올 때 사용되고,  Data Sources들은 로컬 데이터들을 의미합니다.\nData Layer 또한 오직 Domain Layer에만 종속되어 있습니다.\n✔️ 적용하기위 포스트와 제가 배워온대로 그림을 그려보면 아래와 같이 나와야합니다.\n\n그런데 구조가 이렇게 되면 Use Case가 Repository를 호출하는데, 참조 관계는 반대로 되어 있는 아주 잘못된 현상이 발생하게 됩니다. 안쪽 레이어가 바깥 쪽 레이어를 참조하다니, Clean Architecture의 규칙을 깨부수고 있네요 😫\n하지만 Use Case는 꼭 Repository에 Request를 해야합니다. 이럴 땐 어떻게 해야할까요?\n\n바로 위와 같이 중간에 한 단계를 더 거치게 만들면 됩니다. 위 레이어 설명에서 Domain Layer에 Repository Interface가 포함되어 있었죠? 이 친구가 바로 여기에 쓰입니다.\nRepository Interface는 프로토콜의 형태로서 Use Case와 같은 레이어에 속해있지만, 실제 구현은 Data 레이어에 있게 됩니다.\n데이터의 흐름을 살펴보고 실제 구현에 들어가보겠습니다.\n\nView가 View Model의 함수를 요청한다.\nView Model이 Use Case를 실행한다.\nUse Case가 User와 Repository로부터 얻은 데이터를 활용하여 결과를 도출합니다.\n이 때, Repository는 네트워크(ex: API)와 Local DB(ex: Realm)로부터 데이터를 받아와 Use Case에 제공합니다.\nUse Case에서 도출된 결과를 거꾸로 View에 제공합니다.\n\n","slug":"Swift/2022-04-04-Swift06","date":"2022-04-03T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,MVVM","author_index":"nomatterjun"},{"id":"6914f10df24adec42e526e015cc9898d","title":"5)🍎Swift - MVVM, Clean Architecture","content":"RxSwift를 다루게 되다 보니 불가항력적으로 눈에 계속 보이는 MVVM 구조라는 놈이 있습니다. View Controller의 역할이 너무 무거워지고 있던 것을 체감하던 중이여서 프로젝트가 더 진행되기 전에 MVVM 구조를 적용해보기로 했습니다.\n원래는 AWS 서비스들을 사용해보고자 시작했던 프로젝트인데 하다보니 이것저것 많이 건들여보게 되네요 🧐\nMVVMMVVM 구조는 사실 굳이 RxSwift가 아니여도 iOS 앱개발을 공부하다보면 자주 마주치게 되는 용어입니다. MVVM은 Model, View, View Model로 코드를 구분하는 구조입니다. \n그런데 기존의 MVC 구조에서 뭔가가 불편했으니까 이런 새로운 구조를 적용하는 것이겠죠? MVC 구조는 이해하기 상당히 쉽고 애플도 XCode의 기본 구조를 MVC로 설정해둔 듯 합니다. 기본으로 설정된 파일의 이름조차 View Controller이기 때문이죠. 하지만 MVC 구조는 View Controller에게 거의 모든 것을 맡깁니다. 아무리 class를 분리하더라도 결국에는 View Controller에서 참조하여 사용하게 되죠. \nMVVM 구조는 View Controller가 독박쓰던 구조를 세가지 구조로 나눕니다.\n\nView &amp; View Controller: 화면을 구성하는 것을 담당합니다.\nView Model: 화면으로 전달되는 정보들과 그에 필요한 기능들을 담당합니다.\nModel: 실질적인 데이터들의 저장을 담당합니다.\n\n알기 쉽게 예를 들어보면 위와 같이 표현할 수 있습니다. View Model은 Model의 데이터들을 계속해서 Update해주고, View Controller에는 화면에 출력할 정보를 뿌려줍니다. View Controller는 View를 구성해서 화면을 구성합니다.\n이렇게 해서 얻는 이점이 뭐냐?! 하시면\n이제 View Controller와 View에는 오직 화면 구성 코드만이 남겨지게 됩니다. 그리고 실질적인 동작 코드들은 전부 View Model에 들어가게 됨으로서 UI에 대한 접근 없이도 이런저런 테스트나 기능 수정등을 할 수 있게 됩니다. 정돈된 파일은 덤이고요!\n하지만 그렇다고 MVVM 구조가 만능인 것은 아닙니다..\n고통받는 View ModelView Controller는 이제 무게를 좀 덜 수 있게 되었습니다. 하지만 모든 업무를 떠안게 된 View Model… 사실상 무겁고 계속해서 추가가 되는 코드들은 이 View Model이 전부 맡게 되었습니다. \n그래서 Clean-Architecture로 View Model의 기능들도 쪼개봅시다!\n\nClean Architecture\n이 그래프 하나로 모든 것을 설명할 수 있습니다.\n\n종속성은 안쪽으로만 향할 수 있다.\n안쪽의 요소는 바깥쪽 요소에 대해 아무것도 알 수 없다.\n바깥쪽에서 사용된 이름들은 안쪽에서 사용할 수 없다. (변수, 함수, 클래스 등)\n\n사실 세가지 모두 동일한 말을 하고 있습니다. 바깥쪽 요소들은 어떤 일이 있어도 절대로 안쪽 요소들로부터의 영향을 받지 않도록 한다는 것이죠.\n자 이제 각 단계별로 어떤 요소들이 있는지 알아보겠습니다.\nEntities (Model)이 안에 있는 요소들의 특징은 거의 변경될 일이 없다는 점입니다. 예를 들면 DB의 구조..같은 것이 있겠죠? 그래서 MVC 모델에서 Model로 쓰던 데이터의 구조 파일 등이 여기에 속합니다. \nstruct Film &#123;\n  let id: Int\n  let name: String\n  let plot: String?\n  let image: String?\n&#125;\n\n위와 같이 Film이라는 데이터 구조는 완전히 새로운 데이터 구조를 추가&#x2F;수정할 것이 아니라면 거의 건드릴 일이 없는 코드입니다. 영화 정보앱의 기능이 아무리 바뀌더라도 영화 정보를 사용하지 않을 일은 없겠죠?\nUse CasesUse Cases란 사용자가 직접 “사용”하는 앱의 동작과 시나리오들이라고 말할 수 있습니다. 이런 구조를 처음 보는 저에게는 가장 이해하기 힘들었던 부분입니다. 이번에도 쉽게 위의 예시를 통해 살펴보겠습니다. \n영화 정보앱을 켜고 사용자는 어떤 행동을 할까요? 검색을 하던, 추천 정보를 보던 영화 정보를 보여주기 위한 일종의 버튼을 클릭하겠죠? 이 시나리오가 바로 Use Case입니다. \nvar isLoginAccepted = BehaviorSubject(value: false)\nfunc loadFilmInfo() &#123;&#125;\nfunc updateFilmInfo() &#123;&#125;\nfunc notifyReceived() &#123;&#125;\n\n보통 위와 같이 표현됩니다. 유저의 행동, 상태의 변화 등으로 인해 어떤 출력값의 변화가 필요할 때 Use Cases가 출동하여 해결해준다 고 볼 수 있습니다.\nInterface Adapters이 부분은 Presentation Layer라고 부르는 사람들도 많습니다. 어느쪽이던 이름에서 화면의 구성과 관련이 있을 것 같다는 느낌이 들죠? MVVM 모델의 View Model이 보통 이 구역에 해당됩니다. Clean Architecture를 적용한 MVVM 구조에서 View Model은 오직 화면에 출력될 데이터를 최종적으로 가공하는 역할만 하기 때문입니다. \nfunc setTimestampFormat() &#123;&#125;\nfunc setFilmGradeFormat() &#123;&#125;\n\n그래서 보통 위와 같이 Use Cases의 output으로 얻은 정보를 사용자가 보기 쉽게 가공하는 방식으로 많이 사용됩니다. \n20220323 ➡️ 2022년 3월 23일\n처럼요.\nFrameworks &amp; Drivers이 부분은 최외곽인 만큼 가장 활발하게 변형이 이루어집니다. 사용자가 직접적으로 상호작용하는 UI나 DB 외에도 Framework등도 여기에 포함됩니다.\n","slug":"Swift/2022-03-31-Swift05","date":"2022-03-30T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,MVVM","author_index":"nomatterjun"},{"id":"ba350faaa7dac5578f5aca8757053cb0","title":"4)🍎Swift - RxSwift","content":"오늘은 모두가 쓰지만 저만 안쓰고 있던 RxSwift가 무엇이고, 어떻게 쓰는건지 알아보겠습니다.\n우선 RxSwift는 Swift만 갖고 있는 라이브러리는 아닙니다. 원래의 프로젝트 명은 ReactiveX이고 이 이름으로는 어디선가 들어봤던 것 같기도 하죠. RxSwift는 이 ReactiveX를 Swift에 이식한 버전의 이름입니다.\nReactiveX그렇다면 ReactiveX는 무엇일까요? \n보통 우리가 짜는 코드는 **동기적(Synchronous)**으로 실행됩니다. 우리가 적은 윗 줄부터 아래 줄까지 순서대로 한 번에 한 줄씩 차근차근 실행되죠. 하지만 ReactiveX에서는 작업들을 우선 병렬(parallel)적으로 실행하고, **”observers”**라는 놈들로 나중에 결과물을 받아옵니다. \nReactiveX에서 작업은 아래 구조로 실행됩니다.Observable &lt;–Subscribe– Observer\nObservable에서 어떤 행동이 포착되면 Observer는 그에 맞는 반응을 보내줍니다.\nObservableObserver 발행비동기성(Asynchronous) 모델의 흐름은 아래와 같습니다.\n\n비동기성 호출의 return 값을 활용하여 method를 정의한다: Observer의 일부분\n비동기성 호출을 정의한다: Observable\nObserver를 Observable에 연결한다: Subscribe\nreturn value와 value를 활용한다.\n\ndef myOnNext &#x3D; &#123; it -&gt; do something useful with it &#125;;\ndef myObservable &#x3D; someObservable(itsParameters);\nmyObservable.subscribe(myOnNext);\n\nonNext, onCompleted, onErrorSubscribe된 Observer는 상황에 따라 subset을 가집니다.\nonNextObservable이 어떤 정보를 내보내면, onNext method의 인자로 받아옵니다.\nonError예상한 데이터를 생성하는 데 실패하거나 에러가 발생하면 onError method를 호출합니다. onError method를 호출한 이후에는 onNext, onCompleted method를 호출하지 않습니다. onError method의 인자로는 무엇이 에러를 일으켰는지 받아옵니다.\nonCompleted에러가 발생하지 않았을 때, 마지막 onNext method를 호출한 후에 호출됩니다.\n정리해보면, onNext는 여러번 발생할 수도 있지만 onError와 onCompleted는 좋든 싫든 한 번만 발생하게 됩니다!\ndef myOnNext     &#x3D; &#123; item -&gt; &#x2F;* do something userful with item *&#x2F; &#125;;\ndef myError      &#x3D; &#123; throwable -&gt; &#x2F;* react sensibly to a failed call *&#x2F; &#125;;\ndef myComplete   &#x3D; &#123; &#x2F;* clean up after the final response *&#x2F; &#125;;\ndef myObservable &#x3D; someMethod(itsParameters);\nmyObservable.subscribe(myOnNext, myError, myComplete);\n\nUnsubscribingObservable이 더 이상 모니터링이 필요 없어질 경우, Subscribe를 해제할 수도 있습니다.\nObservable이 unsubscribe 되면, 새로운 방출값을 생성하는 것을 멈출 수도 있습니다. \n그런데 주의할 점은, 이 과정은 약간의 딜레이가 발생할 수 있기 때문에 방출값이 조금 더 생성된 후에 멈출 수도 있습니다.\nHot &amp; Cold ObservablesHot Observable생성됨과 동시에 방출값이 생성됩니다. Subscribe하는 Observer는 중간값부터 값을 받아가게 됩니다.\nCold ObservableSubscribe 되면, 그때부터 방출값이 발생합니다. 때문에 Subscribe하는 Observer는 생성된 모든 값을 받아갈 수 있습니다.\nOperatorsChaining Operators거의 대부분의 operator들은 Observable 안에서 작동하고, Observable을 반환하기 때문에 서로가 서로에게 연결되어 일종의 체인을 만들 수 있습니다. \n이때 Operator들 간의 chain은 독립적으로 시행되지 않습니다. 연결된 순서에 따라 순서대로 하나씩 시행되게 됩니다.\nOperators by Category공식 문서를 보면 각 operator의 기능을 카테고리화 하여 분류해두었는데, 이를 한 번씩 살펴보며 정리해보겠습니다!\nCreating ObservablesCreateObservable을 생성할 수 있습니다.\n\n\nlet source: Observable &#x3D; Observable.create &#123; observer in\n    for i in 1...5 &#123;\n        observer.on(.next(i))\n    &#125;\n    observer.on(.completed)\n\n    return Disposables.create &#123;\n        print(&quot;disposed&quot;)\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\nnext(1)\n\n\n\n\n\n\n\n\n\nnext(2)\n\n\n\n\n\n\n\n\n\nnext(3)\n\n\n\n\n\n\n\n\n\nnext(4)\n\n\n\n\n\n\n\n\n\nnext(5)\n\n\n\n\n\n\n\n\n\ncompleted\n\n\n\n\n\n\n\n\n\ndisposed\nJust간단하게 어떤 하나의 값을 Observable로 만들고 싶을 때 사용합니다.\n\n\nlet source &#x3D; Observable.just(1, 2, 3)\nlet source2 &#x3D; Observable.just([1,2,3])\n\n\n\n\n\n\n\n\n\n1, 2, 3\n\n\n\n\n\n\n\n\n\n[1, 2, 3]\nFrom여러개의 값이 있고 각각을 Observable로 만들고 싶을 때 사용합니다.\n\n\nlet numbers &#x3D; [1,2,3,4,5]\nlet source &#x3D; Observable.from(numbers)\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n5\nOf여러개의 값을 Observable로 만들고 싶을 때 사용합니다. \nFrom과 Just의 중간 정도로 생각하면 됩니다.\n배열을 사용했을 때는 배열 그대로 방출하고, 아닐때는 각각의 값을 하나씩 방출합니다.\nlet source &#x3D; Observable.of(1, 2, 3)\nlet source2 &#x3D; Observable.of([1, 2, 3])\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n1, 2, 3\n\nTransforming ObservablesMap각각의 값을 원하는 형태로 변환하여 Observable로 만들고 싶을 때 사용합니다.\n\n\nlet source &#x3D; Observable.from([1, 2, 3]).map &#123; $0 * 2 &#125;\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n6\nFlatMap각각의 Observable이 방출한 값에 대해 지정한 함수를 적용합니다. 이 떄, 각 함수는 자체적으로 값을 방출하는 Observalbe을 반환합니다.\n\n\nlet observableInt &#x3D; Observable.of(1, 2, 3)\nlet observableString &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)\n\nobservableInt\n    .flatMap &#123; (x: Int) -&gt; Observable&lt;String&gt; in\n        return observableString\n    &#125;\n\n\n\n\n\n\n\n\n\nnext(A)\n\n\n\n\n\n\n\n\n\nnext(B)\n\n\n\n\n\n\n\n\n\nnext(A)\n\n\n\n\n\n\n\n\n\nnext(C)\n\n\n\n\n\n\n\n\n\nnext(B)\n\n\n\n\n\n\n\n\n\nnext(A)\n\n\n\n\n\n\n\n\n\nnext(C)\n\n\n\n\n\n\n\n\n\nnext(B)\n\n\n\n\n\n\n\n\n\nnext(C)\n\n\n\n\n\n\n\n\n\ncompleted\nScan각각의 값에 대해 이전에 방출된 값과 함께 연산을 하고 싶을 때 사용됩니다.\n\n\nlet observable &#x3D; Observable.of(1, 2, 3).scan(0) &#123; $0 + $1 &#125;\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n6\n\nFiltering ObservablesFilter결과를 원하는 조건에 맞게 필터링하여 방출합니다.\n\n\nlet observable &#x3D; Observable.from([1, 2, 3]).filter &#123; $0 &gt; 1 &#125;\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n3\nFirst, Last결과 중 가장 첫번째&#x2F;마지막을 방출합니다.\n\n\nlet observable &#x3D; Observable.from([1, 2, 3]).first\n\n\n\n\n\n\n\n\n\nOptional(1)\nTake, TakeLast결과 중 마지막&#x2F;처음부터 n번째까지 방출할지 정해서 방출합니다.\n\n\nlet observable &#x3D; Observable.from([1, 2, 3]).takeLast(2)\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n3\nElementAtn번째 인덱스의 결과를 방출합니다.\n\n\nlet observable &#x3D; Observable.from([1, 2, 3]).elementAt(2)\n\n\n\n\n\n\n\n\n\n3\n\nCombining ObservablesMerge여러 Observable의 결과를 하나의 Observable로 합하여 반환합니다. 이 때, 하나의 Observable이라도 에러가 발생하면, 합쳐진 Observable도 종료됩니다.\n\n\nlet observableInt &#x3D; Observable.of(1, 2, 3)\nlet observableInt2 &#x3D; Observable.of(4, 5, 6)\nlet observableMerge &#x3D; Observable.of(observableInt, observableInt2).merge()\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n6\nZip각 Observable의 순서대로 짝을 맞추어 연산 결과를 방출합니다. 짝이 맞지 않는 값은 버립니다.\n\n\nlet observableInt &#x3D; Observable.of(1, 2, 3, 4)\nlet observableString &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)\nlet observableZip &#x3D; Observable.zip(observableInt, observableString) &#123;\n    &quot;\\($0)&quot; + $1\n&#125;\n\n\n\n\n\n\n\n\n\n1A\n\n\n\n\n\n\n\n\n\n2B\n\n\n\n\n\n\n\n\n\n3C\nCombineLatest각 Observable의 마지막 값끼리의 연산 결과를 방출합니다.\n\n\nlet observableInt &#x3D; Observable.of(1, 2, 3)\nlet observableString &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)\nlet observableCombineLatest &#x3D; Observable.combineLatest(observableInt, observableString) &#123;\n    &quot;\\($0)&quot; + $1\n&#125;\n\n\n\n\n\n\n\n\n\n1A\n\n\n\n\n\n\n\n\n\n1B\n\n\n\n\n\n\n\n\n\n2B\n\n\n\n\n\n\n\n\n\n3B\n\n\n\n\n\n\n\n\n\n3C\n","slug":"Swift/2022-03-18-Swift04","date":"2022-03-17T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS,RxSwift","author_index":"nomatterjun"},{"id":"e8e4dffd0540e6da0503ffe01c05cfbd","title":"3)🍎Swift - 클로저(Closure).03","content":"이번에는 @autoclosure와 @escaping에 대해 알아보겠습니다.\n\n@autoclosureautoclosure도 우선 용어 자체를 살펴보겠습니다.\n자동-클로저?\n이게 대체 뭘까요?\n이번에는 정의를 살펴봅시다.\n인자로서 전달된 일반구문&#x2F;함수를 클로저로서 감싸는 것\n아무래도 일반구문&#x2F;함수를 자동으로 클로저로서 취급한다.. 라는 의미인 것 같네요.\n아직도 이해가 잘 가지 않으니 예제를 살펴보겠습니다.\nfunc foo(closure: @autoclosure () -&gt; ()) &#123;\n    &#x2F;&#x2F; Tasks\n&#125;\n\n@autoclosure가 사용되는 위치도 잘 기억해주세요. 인자명 뒤 타입 정의 바로 앞에 위치해있습니다!\n자 그래서 대체 이게 무슨말이냐..\n@autoclosure를 사용하면 클로저 타입의 인자 closure는 클로저가 아닌 일밤구문&#x2F;함수를 받아도 클로저로서 처리해줍니다.\n우선 @autoclosure를 사용하지 않았을 때를 봅시다.\nfunc foo(_ closure: () -&gt; Void) &#123;\n    closure()\n&#125;\n\n위 함수를 호출할 때 어떻게 호출할까요? 아래와 같이 호출합니다.\nfoo(&#123; \n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;)\n\n이번엔 같은 함수에 @autoclosure를 사용해봅시다.\nfunc foo(_ closure: @autoclosure () -&gt; Void) &#123;\n    closure()\n&#125;\n위 함수는 아래처럼 호출됩니다.\nfoo(print(&quot;Hi! I&#39;m Closure&quot;))\n\n{ … } 이 중괄호가 없어진 것을 볼 수 있죠.\n클로저는 본인이 클로저임을 알리기 위해 중괄호가 무조건 필요합니다. @autoclosure는 클로저가 아닌 일반구문&#x2F;함수를 중괄호로 감싼 역할을 해주는 것이죠.\n단 유의할 점은 @autoclosure를 사용하기 위해서는 클로저의 인자가 없어야 합니다!\nfunc foo(closure: @autoclosure (Int) -&gt; Void) &#123;\n    closure()\n&#125;\n\n위와 경우 (Int) -&gt; Void 인자로 Int 타입이 들어가있죠?\n따라서 오류가 납니다. 꼭 주의해주세요!\n그렇다면 일반구문에 비해서 @autoclosure을 사용했을 때의 차이점은 무엇일까요?\n일반구문은 원래 실행 순서가 되면 즉시 실행됩니다. \n지연을 준다고 하더라도 지연을 주는 함수가 즉시 실행되었기 때문에 뒤에 따라오는 다른 함수들이 지연되는 것이죠.\n그런데 클로저는 즉시 실행되지 않습니다. 함수 안에서 해당 인자가 사용될 때 실행되죠.\n결론적으로 @escaping은 일반구문을 클로저처럼 사용하고 싶을 때 유용한 기능입니다.\n@escaping@escaping 클로저란 용어의 이름에서 유추할 수 있듯이, 함수에서 벗어나서도 실행될 수 있는 클로저입니다.\n@escaping 클로저를 사용하면 다음과 같은 기능을 사용할 수 있습니다.\n\n함수가 끝난 뒤에도 실행될 수 있다.\n중첩함수에서 중첩함수를 return 할 수 있다.\n변수&#x2F;상수에 클로저를 대입할 수 있다.\n\n이 말은 지금까지 다뤘던 클로저들은 위의 경우들이 전부 불가능하다는 소리겠죠?\n지금까지 다뤄온 클로저들 같이 @escaping 구문을 사용하지 않은 클로저들을 non-escaping closure라고 부릅니다.\nAPI 라이브러리인 Alamofire의 예시를 보겠습니다.\nfunc dataGET(from url: URL, completion: @escaping (AnyObject) -&gt; ()) &#123;\n    DispatchQueue.global(qos: .background).async &#123;\n        Alamofire.request(url, method: .get).responseObject &#123; (response: DataResponse&lt;FilmResponse&gt;) in \n        switch response.result &#123;\n        case .success(_):\n            let res &#x3D; response.result.value\n            let resURL &#x3D; res.results.imageID\n            print(resURL ?? &quot;No URL Found&quot;)\n        case .failure(let error):\n            print(error)\n        &#125;&#125;\n    &#125;\n&#125;\n\n굉장히 복잡해보이죠? 사실 다른건 다 필요없습니다.\nfunc dateGET(from url: URL, completion: @escaping (AnyObject) -&gt; ()) &#123;\n    DispatchQueue.global(qos: .background).async &#123;\n        &#x2F;&#x2F; Blah Blah\n    &#125;\n&#125;\n이렇게만 보면 됩니다.\n이제 우리는 저 함수를 분석할 수 있습니다! \n마지막 인자로 closure를 사용하여 Trailing Closure 방식이 채택되었네요. 또, @escaping 클로저가 사용된 것도 볼 수 있습니다. 왜 사용했을까요?\nAPI 호출은 상대적으로 많은 시간이 소요됩니다. 그래서 보통 비동기성으로 실행하죠. 유저가 로딩이 다 될 때까지 먹통이 된 앱을 가만히 보고 있진 않을테니까요. \n따라서 위 함수가 완료되기 전에 DispatchQueue로 실행한 구문들은 완료되었을 가능성이 거의 전무합니다. 여기서 @escaping 클로저가 아니라 non-escaping 클로저를 사용했다면..? 함수가 종료됨과 동시에 함수 안에서 실행된 클로저까지 전부 종료되어 버립니다. 저희가 원하는 결과는 절대 아니죠.\n그리고 애초에 XCode에서 이를 허용하지 않습니다. **”Escaping closure captures non-escaping parameter”**라는 에러 메시지를 출력하며 빌드 에러가 나죠.\n\n이렇게 @autoclosure와 @escaping 클로저까지 알아봤습니다. @escaping 클로저는 온라인으로 통신하는 앱에서는 거의 필수적으로 사용법을 알아둬야 하니 꼼꼼하게 기억해둘 필요가 있습니다. 저처럼 헤매지 않으려면 말이죠 ㅜㅜ\n","slug":"Swift/2022-03-03-Swift03","date":"2022-03-02T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"4bec864af0b8c90bc4e0e9a7d2f81123","title":"2)🍎Swift - 클로저(Closure).02","content":"이번에는 덩치가 큰 클로저라는 친구를 다이어트 시키는 방법과 저를 곤란하게 만든 @escaping 클로저에 대해 알아보겠습니다\n우리 클로저라는 친구는 덩치가 너무 큽니다.. 이전 게시물의 예시를 다시 가져와볼까요?\nfoo(closure: &#123; () -&gt; () in\n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;)\n클로저를 인수로 받는 함수의 호출법입니다. 위 예시는 사실 아주 단순한 친구였죠? \nfoo(클로저)\n네.. 가만히 한번 관찰해보면 이 친구는\n() -&gt; () \n요 부분이라던지..\nclosure: \n요 부분이라던지.. 불필요하게 명시되어 있는 여러 부분들이 보입니다. 마치 저의 몸에 붙어있는 불필요한 지방같죠. 😝\n그래서 지금부터는 클로저의 체중 감량법을 알아보겠습니다.\n\nTrailing Closure (트레일링 클로저)또 새로운 용어가 나왔지만 이해를 돕기 위한 도구로서 접근해봅시다. “Trailing &#x3D; 끝에 붙은” 이라는 뜻이죠?\n이 경량법은 함수의 마지막 인자로 클로저가 들어가있을 때 사용할 수 있습니다. 마지막 클로저를 빼내서 함수의 끝에 간략화해서 붙여쓰는 방법이죠. 이 때, 인자의 자리에서 뛰쳐나왔으니 인자명은 적지 않습니다.\n역시 예시가 이해에 직빵이죠?\nfoo(closure: &#123; () -&gt; () in\n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;)\n\n네 위의 예시와 같은 예시입니다. function({ … }) 이렇게 괄호안에 중괄호가 들어가있어서 한 눈에 파악이 어려운 점이 있었습니다. 그래서 Trailing Closure를 사용해볼게요!\nfoo() &#123; () -&gt; () in\n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;\n\n이렇게!! function() { … } 형태로 바꿀 수 있고, closure: 와 같은 인자명도 생략할 수 있습니다. \n그리고 여기에서 추가로! 인자가 클로저 단 하나일 경우에는 **()**까지 생략 가능합니다.\nfoo &#123; () -&gt; () in\n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;\n이렇게 말이죠!\n인자가 여러개인 경우도 한번 볼게요\nfunc fetchData(success: () -&gt; (), fail: () -&gt; ()) &#123;\n    &#x2F;&#x2F; Tasks\n&#125;\n위 함수는 아래와 같이 호출될겁니다.\nfetchData(success: &#123; () -&gt; () in\n    print(&quot;Success&quot;)\n&#125;, fail: &#123; () -&gt; () in\n    print(&quot;Fail&quot;)\n&#125;)\n이 호출법에 Trailing Closure를 활용해볼게요.\nfetchData(success: &#123; () -&gt; () in\n    print(&quot;Success&quot;)\n&#125;) &#123; () -&gt; () in\n    print(&quot;Fail&quot;)\n&#125;\n이렇게! 마지막 클로저 인자만 뒤로 쏙 뺄 수 있죠.\n정리해볼까요?\n\n마지막 인자가 클로저인 경우, 해당 클로저를 인자에서 빼내서 함수 뒤에 붙일 수 있다.\n이 때, 인자명은 생략된다.\n만약 인자가 클로저 단 하나일 경우에는 함수 호출 구문인 () 또한 생략할 수 있다.\n\n\n() -&gt; () in 생략자.. 그런데 사실 저희 눈에 제일 거슬리는건 저런 마이너한 부분이 아닙니다. 본인이 클로저라고 당당히 소리치고 있는 () -&gt; () in 이 부분이죠.\n너무 자기주장이 강해서 클로저 구문을 보면 저 부분부터 눈이 갑니다. 그래서 저 부분을 생략해볼겁니다.\n자 아래와 같은 함수가 있습니다.\nfunc foo(closure: (Int, Int, Int) -&gt; (Int)) &#123;\n    closure(1, 2, 3)\n&#125;\n인자로 Int형 1, 2, 3을 받아 Int형 Return Type을 내보내는 클로저를 인수로 갖는 함수 foo()이네요. 이 함수를 호출할 때는 어떻게 해야할까요?\nfoo(closure: &#123;closure: (a: Int, b: Int, c: Int) -&gt; Int in\n    return a + b + c\n&#125;)\n혹은 Trailing Closure를 사용해서\nfoo() &#123; (a: Int, b: Int, c: Int) -&gt; Int in\n    return a + b + c\n&#125;\n이런식으로 주저리주저리.. 굉장히 길어집니다. 심지어 위 예시는 굉장히 간단한 예시이죠? 실전에선 더욱 복잡해지고 길어질겁니다. 그래서 이 친구를 총 다섯 단계에 걸쳐 축약해볼게요!\n1.. 데이터 타입을 생략한다.\n가장 만만한 데이터 타입부터 생략해봅시다. Swift는 현대 언어의 기본 소양인 “데이터타입 알아서 처리하기” 기능이 당연히 있습니다. 이를 적극적으로 활용한 방법이죠.\nfoo(closure: &#123;closure: (a: Int, b: Int, c: Int) -&gt; Int in\n    return a + b + c\n&#125;)\n여기서 Int 타입들을 전부 생략합니다!\nfoo(closure: &#123;closure: (a, b, c) in \n    return a + b + c\n&#125;)\n😮😮😮 \n벌써부터 엄청나게 줄어들었네요! 물론 데이터타입에 대해 엄격하게 관리하실거면 하나하나 적어주시는게 좋습니다.\n2.. 클로저의 인자명을 생략하고 shortand를 사용한다.\n우선 shortand가 무엇이냐 하면, \n($0, $1, $2)\n요 친구들입니다. 파이썬을 다뤄보신 분들이라면 익숙하실거에요. 각각 **(첫 번째 인자, 두 번째 인자, 세 번째 인자)**를 의미하죠.\n이를 위 예시에 한 번 적용해볼까요?\nfoo(closure: &#123;closure: (a, b, c) in \n    return a + b + c\n&#125;)\n쨔쟈쟌~\nfoo(closure: &#123;\n    return $0 + $1 + $2\n&#125;)\n\n와우.. 이제 두 번째 단계인데 벌써 엄청나게 단순해졌어요.\n물론 두 번째 방법에도 유의할 점은 있습니다. 인덱스 수와 인자의 수를 정확히 맞춰주셔야 해요!\n3.. 클로저 구문 안에 return만 있을 경우, 이 또한 생략한다.\n이건 빠르게 예시로 보고 넘어갑시다.\nfoo(closure: &#123;\n    return $0 + $1 + $2\n&#125;)\n\n이렇게 클로저 안에 return 구문만 있는 경우에는?\nfoo(closure: &#123;\n    $0 + $1 + $2\n&#125;)\n이렇게 return 또한 생략해줄 수 있습니다.\n4.. Trailing Closure\n위에서 다룬 Trailing Closure를 적용해줍시다.\nfoo(closure: &#123;\n    $0 + $1 + $2\n&#125;)\n\n마지막 인자를 함수 뒤로 빼버리죠!\nfoo() &#123;\n    $0 + $1 + $2\n&#125;\n\nㅎㅎ;;;\n5.. 인자가 클로저 단 하나라면? ()도 생략한다.\n마찬가지로 위에서 다뤘었죠? 인자가 클로저 단 하나이고, Trailing Closure를 적용하면 () 안에는 아무것도 남아있지 않습니다.\nfoo() &#123;\n    $0 + $1 + $2\n&#125;\n\n없어져라 ()!\nfoo &#123;\n    $0 + $1 + $2\n&#125;\n\n여기까지! 통통했던 클로저 친구가 이쑤시개가 되었습니다.. 드라마틱한 연출을 위해 비교해볼게요.\nfoo(closure: &#123;closure: (a: Int, b: Int, c: Int) -&gt; Int in\n    return a + b + c\n&#125;)\n이 친구가..\nfoo &#123;\n    $0 + $1 + $2\n&#125;\n\n이렇게.. 이 정도면 클로저 친구의 건강을 걱정해야 하는거 아닌가 싶네요 😅\n물론 위의 예시는 매우 극단적인 경우입니다. 실전에서 이렇게까지 축약되는 경우는 거의 없다고 보셔도 되지만, 한두가지만 적용해도 가시성이 훨씬 좋아지니 적극적으로 활용해줍시다!\n","slug":"Swift/2022-03-02-Swift02","date":"2022-03-01T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"95363f08e13410733c358df6bc3d7681","title":"1)🍎Swift - 클로저(Closure).01","content":"혼자 공부하다 도저히 안되겠어서 정리해보는 태그를 하나 만들었습니다!첫 게시물의 주제는 느낌적으로 써왔지만 제대로 공부해본 적은 없는 클로저입니다.\n클로저란?지금까지 클로저하면 그냥 “그룹으로 실행되는 코드 덩어리” 정도로 생각하고 사용해왔습니다.그런데 자료를 찾아보니 어머나 글쎄 그게 전부네요?\n물론 여러가지 옵션들이 추가되면서 다양하게 활용이 가능하지만 기본적인 개념은 정말로 코드 덩어리 그 이상도 이하도 아니였습니다.\n그런데 충격적인 사실이 하나 있었습니다.바로 함수도 클로저였던 것이죠.\n함수야 다른 언어들에서도 기본적인 개념이라서 Swift에서도 써왔는데 생각해보면 클로저나 함수나 하는 기능은 같습니다.\n정확하게 살펴보면 함수는 이름이 있는 클로저입니다.이게 무슨 소리냐면, 클로저에는 Unnamed Closure와 Named Closure 이렇게 두 가지 종류가 있습니다.\nfunc foo() &#123;\n    print(&quot;Actually, I&#39;m Named Closure&quot;)\n&#125;\n저희가 줄곧 사용해왔던 위와 같은 함수라는 녀석은 사실 Named Closure였던 것이죠. \nlet boo &#x3D; &#123; print(&quot;I&#39;m Unnamed Closure&quot;) &#125;\n그리고 지금까지 감으로 사용해오던 윗 놈은 Unnamed Closure이지만, 편의상 Named Closure를 함수라고 부르기 때문에 줄여서 그냥 “Closure”라고 불렀던 것입니다.\n자 그래서 클로저란 놈은 어떻게 생겼느냐? 하시면\n&#123; (Parameters) -&gt; Return in\n    &#x2F;&#x2F; tasks\n&#125;\n이렇게 생겼습니다. Swift를 사용하다보면 굉장히 자주 나오기 때문에 은연중에 익숙해진 구조네요..\n하지만 제대로 학습해보기 위해 구조를 뜯어내보겠습니다. 클로저는 in을 기준으로 두 가지 부분으로 나눌 수 있습니다.인자와 반환형으로 이루어진 Closure Head와 실행부가 있는 Closure Body이죠.\n사실 쓸 줄만 알면 됐지 용어는 중요한 게 아니니 예시 하나만 간단히 보고 넘어갑시다!\nlet boo &#x3D; &#123; (title: String) -&gt; String in \n    return &quot;Title: \\(title)&quot;\n&#125;\n\n클로저의 기능, 사용법지금부터는 클로저가 할 수 있는 기본적인 기능을 알아보겠습니다. 함수와 같은 놈인걸 알았으니 함수의 기능들을 생각해보면서 보면 나름 쉽습니다!\n1.. 함수의 인자로서 사용될 수 있다.\n기능 첫 번째! 처음 마주쳤을 때 가장 당황했던 기능입니다. 웬 처음보는 구조가 함수 인자로 떡하니 자리를 잡고 있는데, 괄호에 화살표에 어질어질했던 기억이 있네요.\nfunc foo(closure: () -&gt; ()) &#123;\n    closure()\n&#125;\n위와 같이 함수를 인자로 받는 함수 형태를 사용할 수 있다는 점 아시나요? 개인적으로 익숙하지는 않아서 인지만 해두고 직접 사용하지는 않던 기능인데요, 여기에 클로저를 사용하게 되면 사실은 자주 사용하던 기능이라는 사실을 깨닫게 됩니다. 참고로 위 예시에서 closure()는 함수입니다!\nfoo(closure: &#123; () -&gt; () in\n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;)\n처음 보시는 분들이 여기서 헤롱헤롱하고 계실테니 자세히 살펴보겠습니다. 자세히 보면, \n&#123; () -&gt; () in\n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;\n이 부분.. 보이시나요? 뭔가 굉장히 길어보이지만 그냥 하나의 클로저입니다. 이 클로저가 closure라는 이름으로 foo() 함수의 인자로서 전달된 것이죠.\n이게 보이고나면 위 구조는 생각보다 간단해집니다. “Hi! I’m Closure”라는 String을 출력하는 함수 closure()가 foo() 함수의 인자로 전달되어 실행되는 구조인 것이죠.\n2.. 함수의 반환으로서도 사용될 수 있다.\n두 번째 기능은 빠르게 살펴봅시다! 함수의 인자로 클로저를 사용할 수 있다면 반환 타입으로도 사용될 수 있겠죠?\nfunc foo() -&gt; () -&gt; () &#123;\n    return &#123; () -&gt; () in\n        print(&quot;Hi! I&#39;m Closure&quot;)\n    &#125;\n&#125;\n네 맞아요. 얘도 만만치 않게 복잡해보입니다. 하지만 우리의 애플은 () -&gt; () -&gt; () 같은 애매한 표현을 좋아하지 않아요.\n저 형태 그대로 사용될 일은 거의 없으니 해당 파트에서 다시 정리해보겠습니다.\n3.. 변수&#x2F;상수에 사용할 수 있다.\n사실 제일 기본적인 형태입니다.\nlet closure &#x3D; &#123; () -&gt; () in\n    print(&quot;Hi! I&#39;m Closure&quot;)\n&#125;\n보통 return으로 변수&#x2F;상수에 값을 넣어주게 됩니다.\n여기까지가 클로저의 기본 개념이라고 할 수 있습니다. 다음 게시물에서는 제가 이렇게 정리하게 만든 원흉인 @escaping closure 위주로 작성해보겠습니다!\n","slug":"Swift/2022-03-01-Swift01","date":"2022-02-28T15:00:00.000Z","categories_index":"Swift","tags_index":"Swift,iOS","author_index":"nomatterjun"},{"id":"aeca58d27d9a585d8ce5c912856b6811","title":"9)📱iOS앱개발 - CaseIterable 이해하기","content":"Pageboy 라이브러리의 예제를 보던 도중 CaseIterable 프로토콜을 사용하는 예제가 있는데 이게 뭔지를 몰라서 공부를 해보았습니다.\n\n\nCaseIterable 프로토콜은 모든 case들에 대해 컬렉션을 만들어 제공해주는 타입입니다. 쉽게 말해서 enum 열거형의 각 case에 배열처럼 접근할 수 있다는 말입니다. 또 더 쉽게 말하면, enum 열거형 타입에 forEach와 같은 루프등을 쓸 수 있게 됩니다.\nenum Tab: String, CaseIterable &#123;\n    case detail\n    case front\n    case board\n&#125;\n\n위 예제를 보면 Tab이라는 enum 열거형 변수가 있습니다. 우선 String 타입을 갖는 enum이기 때문에 각 case의 이름과 동일한 Raw Value가 각각 지정됩니다. \n\n\n그리고 오늘 다루는 CaseIterable 프로토콜 또한 채택되어 있습니다. 덕분에 우리는 Tab이라는 값에 “allCases” 프로퍼티를 사용해 배열처럼 접근할 수 있습니다. 나아가서는 배열이기에 고차함수(map, reduce, filter, …) 또한 사용할 수 있습니다. \nprivate let tabItems &#x3D; Tab.allCases.map(&#123; BarItem(for: $0) &#125;)\n\n위 예제를 보면 Tab이라는 enum 타입에 map을 사용하여 BarItem 클래스의 규칙에 따라 변환된 각 case들을 tabItems에 저장하였습니다. \n","slug":"Assemble/220214_09/2022-02-14-assemble09","date":"2022-02-13T15:00:00.000Z","categories_index":"Assemble","tags_index":"Swift,iOS,Assemble","author_index":"nomatterjun"},{"id":"a41d20cacf7715bb74660a95ac0d6e15","title":"8)📱iOS앱개발 - Lambda 함수에서 다른 Lambda 함수 실행하기","content":"DB의 데이터를 자동으로 채우고 api로 불러오는 작업을 계속 진행하던 중에 Lambda 함수에서 다른 Lambda 함수를 불러오면 간단하게 끝낼 수 있는 작업을 마주치게 되었습니다. 방법을 찾아보니 AWS에서 Invoke 함수를 제공하고 있었습니다.\nimport boto3\n\nlambda_client &#x3D; boto3.client(&#39;lambda&#39;,\n                             region_name&#x3D;&#39;ap-northeast-2&#39;, # 서울 (본인이 설정한 지역 코드)\n                             aws_access_key_id&#x3D;&#39;YOUR ACCESS KEY&#39;,\n                             aws_secret_access_key&#x3D;&#39;YOUR SECRET KEY&#39;) \n\nlambda 함수에만 사용하는 함수는 아니기 때문에 클라이언트 유형을 lambda로 설정해주고, 본인의 환경에 맞게 값들을 입력해줍니다.region_name: 사용하고 있는 AWS 리전 코드를 입력해줍니다. AWS 콘솔 우측 상단에서 확인 가능합니다.\n\n\naws_access_key_id: AWS 계정의 보안자격키를 입력해줍니다.aws_secret_access_key: AWS 계정의 보안자격 시크릿키를 입력해줍니다.이 두가지 값은 AWS의 IAM 서비스에서 발급&#x2F;조회할 수 있습니다.\n\n\nIAM 서비스의 사용자 탭에서 사용자가 없다면 새로운 사용자를 추가하거나, 있다면 수정하여 얻을 수 있습니다.\n\n\n\n권한 탭의 권한 추가에서 기존 정책 직접 연결을 선택해주고, 정책 필터에 “lambda“를 검색해줍니다. 그럼 아래에 AWSLambda_FullAccess라는 항목이 나올텐데, 위 캡처에는 이미 적용된 권한이라 표시되지 않았습니다. 이름 그대로 Lambda에 대한 모든 권한을 부여해주는 권한입니다. \n\n\n보안 자격 증명 탭에서 액세스 키를 조회하거나 생성할 수 있습니다. 액세스 키 만들기 버튼을 통해 새로운 키를 만들 수 있는데, 이때 주의할 점은 시크릿 키는 이때 말고는 조회할 수 있는 방법이 없으므로 .csv파일로 저장해서 잘 보관해두거나, 따로 다른 곳에 적어두어 보관해둡시다. \nresponse &#x3D; lambda_client.invoke(\n    FunctionName&#x3D;&#39;updateActors&#39;, \n    InvocationType&#x3D;&#39;Event&#39;, \n    Payload&#x3D;json.dumps(&quot;&quot;)\n)\ninvoke 함수로 다른 Lambda 함수를 실행할 수 있습니다.FunctionName\n\n함수 이름: updateActors(이름만), updateActors:v1(별칭포함)\n함수 ARN: arn:aws:lambda:us-west-2:123456789012:function:my-function\n부분적 ARN: 123456789012:function:my-function\n\nInvocationType\n\nRequestResponse(default): 동기적 함수 호출\nEvent: 비동기적 함수 호출\nDryRun: 파라미터 유효성 검사, 권한 확인\n\nPayload: 입력으로 들어가는 값들을 지정 (json 형식)\n","slug":"Assemble/220130_08/2022-01-30-assemble08","date":"2022-01-29T15:00:00.000Z","categories_index":"Assemble","tags_index":"Python,AWS,Assemble","author_index":"nomatterjun"},{"id":"63d243280a5706ad4c80cf0178f771fe","title":"7)📱iOS앱개발 - API Gateway로 DB에 정보 입력/수정하기","content":"DB 틀이 어느정도 맞춰졌으니 실제로 데이터를 넣어보려고 합니다. 이전에 만들어두었던 Lambda 함수와 API Gateway를 사용하면 RESTful하게 데이터를 입력해줄 수 있습니다.\nAPI Gateway\n\n위와 같이 리소스를 생성해주고 PUT 메서드를 추가해주었습니다. API Gateway에서 지원하는 메서드는 총 6가지인데, HTTP 메서드와 동일한 역할을 합니다.\n\nHTTP Method1. ANY아래 다섯 메서드 중 적합한 메서드를 골라 실행합니다.\n2. GET데이터를 조회&#x2F;검색할 때 사용됩니다. 요청시에 body 값과 content-type 없이 url에 파라미터만 입력하여 사용됩니다다. 요청이 성공적으로 완료되면 200(OK) 메시지와 함께 body 값에 데이터가 저장되어 돌아옵니다.\nGET &#x2F;films&#x2F;2024012802\n3. POST새로운 데이터를 생성할 때 사용됩니다. 요청시에 body 값과 content-type을 필요로 하고, 생성할때만 사용되기 때문에 이미 중복된 데이터가 있더라도 무조건 생성을 시도합니다. url에 모든 데이터를 넣는 것은 너무나 불편하기 때문에 body에 데이터를 넣어 보냅니다. 성공적으로 데이터를 생성하면 201(created) 메시지와 함께 body 값에 생성된 값이 저장되어 돌아옵니다.\nPOST &#x2F;films\nbody: &#123;fID: 2023042403, fNM: &quot;영화&quot; ... &#125;\ncontent-type: &quot;application&#x2F;json&quot;\n4. PUT데이터를 업데이트&#x2F;생성할 때 사용됩니다. POST와 비슷하지만 이미 존재하는 데이터에 대해서는 업데이트가 이루어집니다. (idempotent)\nPUT &#x2F;films&#x2F;2023042403\nbody: &#123;fNM: &quot;영화2&quot; ... &#125;\ncontent-type: &quot;application&#x2F;json&quot;\n5. DELETE존재하는 데이터를 삭제할 때 사용됩니다. GET과 비슷하게 url을 통해서 삭제할 데이터를 파라미터로 받습니다. 성공적으로 데이터가 삭제되면 별도의 body 내용 없이 성공 응답만 돌아옵니다.\nDELETE &#x2F;films&#x2F;2023042403\n6. HEADGET 메서드와 동일한 기능을 수행하지만 서버가 body를 보내주지 않습니다. 보통 서버가 정상적으로 작동하는지 확인하기 위해 응답 메시지만을 확인하고 싶을 때 사용됩니다.\nHEAD &#x2F;films&#x2F;2021022302\n\n\n\n다시 API Gateway로 돌아와서, 생성한 PUT 메서드를 선택하고 통합 요청에 들어갑니다.\n\n\n아래의 매핑 템플릿을 통해 url에 어떤 형식으로 파라미터를 제공할 것인지 설정해줄 수 있습니다. 정의된 템플릿이 없는 경우 패스스루를 하도록 설정하고 Content-Type으로는 json을 입력해줍니다.\n\n&#123;\n    &quot;movieCd&quot;: &quot;$input.params().querystring.get(&#39;movieCd&#39;)&quot;,\n    &quot;univ&quot;: &quot;$input.params().querystring.get(&#39;univ&#39;)&quot;\n&#125;\n위와 같이 key 하나하나 직접 입력해주었습니다. loop를 통해 하는 방법도 있다고 하는데 아직 익숙치 않아 일단은 이렇게 진행해보았습니다. query string 형태로 input parameter를 받아 lambda 함수의 input으로 들어가게 됩니다.\n\n\n\n테스트로 들어가 쿼리 문자열에 lambda 함수의 입력에 맞는 값을 입력해주었습니다. 아래의 테스트 버튼을 눌러보면?\n\n\n상단에 입력된 요청 url이 표시되고 상태(200 ok), 소요 시간, lambda 함수에서 작성한 출력이 표시됩니다.\n여러 테스트를 거쳐 값들이 제대로 들어가는 것을 확인하였습니다.\n","slug":"Assemble/220125_07/2022-01-25-assemble07","date":"2022-01-24T15:00:00.000Z","categories_index":"Assemble","tags_index":"AWS,mySQL,Assemble","author_index":"nomatterjun"},{"id":"291cbcf6b4765cf7164ff2800622aa73","title":"6)📱iOS앱개발 - DB 재설계","content":"DB 재설계이전의 DB는 관계형DB로서의 기능을 하지 못하였습니다. 각 인스턴스 사이의 관계를 설명할 수 없었고, 자연스럽게 외래키도 잘못 연결되어 있었습니다. 그래서 다음과 같이 처음부터 다시 뜯어고쳤습니다. \n\n\nfilm과 filmInfo 테이블이 분리되어 있는 것이 비효율적이라 생각하여 통합하였고, 추가적인 정보를 더 제공하기 위해 새로운 테이블도 추가하였습니다. 관계를 설명하는 테이블에도 id를 부여하여 추후에 수정할 때 편하게 설계하였습니다. \n1. CURRENT_TIMESTAMPfilms 테이블에 정보가 언제 마지막으로 수정되었는지 확인할 수 있도록 fLastUpdate 행을 새로 만들어 주었습니다. 이 부분은 AWS의 Lambda에서 직접 수정해주지 않아도 DB에서 자체적으로 update 시켜주길 원해서 방법을 찾아보았습니다. \n아래와 같이 원하는 행에 DEFAULT와 ON UPDATE를 이용해줍니다.\n&#39;fLastUpdate&#39; TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\nDEFAULT CURRENT_TIMESTAMP: INSERT 시에 자동으로 현재 timestamp가 입력된다.ON UPDATE CURRENT_TIMESTAMP: UPDATE 시에 자동으로 현재 timestamp가 입력된다.\n2. CHAR, VARCHAR, TEXTfilms 테이블의 fPlot 행은 영화의 대략적인 줄거리를 설명하는 글이 저장되는 공간입니다. 이 공간은 다른 행에 비해서 많은 양의 데이터가 들어갈 것이기 때문에 저장공간의 낭비없이 공간을 할당해줄 수 있을까 싶어 SQL이 지원하는 데이터 타입을 둘러보게 되었습니다. \n문자열을 저장하는 데이터타입 중 많이 사용되는 VARCHAR, CHAR, TEXT 타입이 있습니다. 이 셋에는 차이점이 존재하는데 정리해보면 아래와 같습니다.\n\n\n\n데이터 타입\n사이즈 (byte)\n가변형\n\n\n\nCHAR\n&lt;&#x3D; 255\nX\n\n\nVARCHAR\n&lt;&#x3D; 65535\nO\n\n\nTEXT\n&lt;&#x3D; 65535\nO\n\n\n1. CHAR고정된 크기를 갖는 데이터 타입입니다. 예를 들면, CHAR(4)로 선언된 행은 고정적으로 4-byte의 크기를 할당받습니다.2. VARCHAR, TEXT가변형 크기를 갖는 데이터 타입입니다. 예를 들면, VARCHAR(45)로 45-byte 크기의 행을 설정해줘도, 실제로 갖는 내용이 4-byte라면 4-byte를 할당받습니다. 45-byte는 들어가는 값의 최대 크기가 됩니다.\n그렇다면 이 둘의 차이는 또 무엇일까요?TEXT 타입은 최대 크기를 지정해주지 못합니다. 고정적으로 65535 사이즈의 최대 크기를 갖게되는 것이죠.반대로 VARCHAR 타입은 최대 크기를 지정해줄 수 있습니다. 위 예시의 VARCHAR(45)는 45-byte의 최대 크기를 지정해준 것입니다.\n또, 이 두 데이터 타입은 실제로 갖는 데이터 외에도 자신의 사이즈를 저장하기 위해 추가적인 공간을 사용하는데, VARCHAR 타입은 1255 사이즈일 경우 1-byte, 25665535 사이즈일 경우 2-byte를 사용하지만 TEXT 타입은 최대 크기가 고정적으로 65535-byte이므로 2-byte를 사용합니다.\n추가적으로 TEXT 타입의 행은 INDEX로 사용될 수 없고, 메모리가 아닌 하드디스크에 저장되기 때문에 쿼리시에 속도가 느릴 수 있습니다.\n3. BLOBTEXT 타입과 비슷한 타입이 하나 더 있습니다. BLOB(Binary Large OBject)이라는 데이터 타입인데, 이 두 데이터 타입은 모두 문자열을 저장하지만 BLOB 타입은 문자셋과 콜레이션이 없는 바이너리 데이터를 저장하고, TEXT 타입은 문자셋과 콜레이션이 있는 텍스트 데이터를 저장한다는 점이다. 대표적인 문자셋으로는 utf-8이 있고, 콜레이션을 통해 대소문자 등 글자를 서로 구분하는 법칙을 지정할 수 있다. \nBLOB 타입의 데이터는 이미지 파일을 저장할 수 있다. 이미지를 Base64로 인코딩한 후, utf-8로 디코드하면 바이너리 형식의 긴 텍스트를 얻어낼 수 있다. 이 텍스트를 DB에 저장하고, 다시 SELECT로 불러올 때도 디코딩 과정을 거치면 이미지 파일을 얻어낼 수 있다.\n4. 이미지 저장?작은 이미지 파일을 저장할 때는 BLOB 타입으로 충분히 감당이 가능하다. 하지만 현재의 이미지는 BLOB 타입으로 DB에 직접 저장하기에는 너무 커졌다. DB에 이미지 파일을 직접 저장하면 안되는 이유는 다음과 같다.\n\n백업과 복원에 상당한 시간이 소요된다. 오랜 기간 소요되는 복원은 DB의 성능에 심각한 저하를 가져오고, DB가 손상되어 급하게 복원이 필요할 때 시간이 소요되어 소비자들이 불편을 갖게 된다.\n상당한 자원을 소모한다. Azure나 AWS와 같은 서비스를 사용한다면 제한된 용량을 빠르게 소모할 것이고, 예상치 못한 금액을 지불해야 할 수도 있다.\n직관적이지 않다. BLOB으로 변환된 이미지 파일은 사람이 알아볼 수 없다.\n\n그렇다면 어떻게 하는 것이 좋을까?\n물리적인 하드디스크를 하나 사용하여 모든 이미지 파일들을 그 곳에 저장하고, DB에는 그 파일과의 연결 관계를 만들어준다. 클라우드에 저장하는 것보다 훨씬 빠르고, 저렴하게 이미지 파일을 저장할 수 있다. 이미지 파일을 열어보는 것 조차 너무나도 쉬워진다.\n","slug":"Assemble/220124_06/2022-01-24-assemble06","date":"2022-01-23T15:00:00.000Z","categories_index":"Assemble","tags_index":"mySQL,Assemble","author_index":"nomatterjun"},{"id":"3dd5dd23bc1bf752e32b431e49dca7c1","title":"5)📱iOS앱개발 - Lambda 함수 생성 & API 배포하기","content":"함수를 테스트할 로컬 환경 만들기완성된 함수를 아마존 서버에 올리고 싶어서 로컬에서 먼저 테스트하기 위한 환경을 만들어주겠습니다. 파이썬을 사용해서 MySQL에 접근해야하기 때문에 먼저 PyMySQL이라는 라이브러리를 설치해야 합니다. 아래 명령어로 설치해줍니다. (맥 환경)\n$ pip install PyMySQL\n\n이제 테스트 코드를 작성해보겠습니다.\nimport pymysql as mysql\nimport pandas as pd\n\ndb &#x3D; mysql.connect(\n    host&#x3D;&#39;본인의 RDS 엔드포인트&#39;, \n    user&#x3D;&#39;RDS username&#39;, \n    password&#x3D;&#39;RDS password&#39;, \n    db&#x3D;&#39;본인의 DB 이름&#39;, \n    charset&#x3D;&#39;utf8&#39;\n)\n\ntry:\n    with db.cursor(mysql.cursors.DictCursor) as cursor:\n        sql &#x3D; &quot;SELECT * FROM actor&quot;\n        cursor.execute(sql)\n        result &#x3D; cursor.fetchall()\n\n        result &#x3D; pd.DataFrame(result)\n        print(result)\nfinally:\n    db.close()\n\nDB 연결 - connect()db &#x3D; mysql.connect(\n    host&#x3D;&#39;본인의 RDS 엔드포인트&#39;, \n    user&#x3D;&#39;RDS username&#39;, \n    password&#x3D;&#39;RDS password&#39;, \n    db&#x3D;&#39;본인의 DB 이름&#39;, \n    charset&#x3D;&#39;utf8&#39;\n)\nconnect() 함수를 통해 RDS의 DB에 직접적으로 연결할 수 있습니다. \n\nhost: RDS 엔드포인트\nuser: 설정한 RDS username\npassword: 설정한 RDS password\ndb: RDS DB 이름\ncharset: 문자 인코더\n\n커서 사용 - cursor()db.cursor(mysql.cursors.DictCursor) as cursor\nPyMySQL에서는 커서를 사용해 DB에 접근할 수 있습니다. 파이썬 작업 중에도 가시성이 좋은 출력 결과를 얻고 싶어 데이터프레임 형태로 출력하기로 했습니다. 이를 위해 Dictionary 형태로 결과를 내보내는 DictCursor를  사용하였습니다.\n데이터 접근 - execute()sql &#x3D; &quot;SELECT * FROM actor&quot;\ncursor.execute(sql)\nresult &#x3D; cursor.fetchall()\n\nexecute() 함수의 파라미터로 쿼리문을 넣어 SQL을 실행하고 fetch 함수를 사용해 결과를 받아올 수 있습니다. fetch 함수에도 여러 종류가 있는데 다음과 같습니다.\n\nfetchall(): 모든 데이터를 한 번에 fetch\nfetchone(): 하나의 행만 fetch\nfetchmany(n): n개의 데이터를 fetch\n\n결과를 데이터프레임으로 출력result &#x3D; pd.DataFrame(result)\nprint(result)\npandas 라이브러리를 사용해 결과를 데이터프레임의 형태로 출력해줍니다.\n데이터 적용 - commit()INSERT, UPDATE, DELETE문은 DB에 변경이 생기게 되므로 commit 과정이 필요합니다. 저의 예시에서는 SELECT만 사용하여 commit을 하지 않았지만 이 외의 경우에는 매우 중요합니다.\ndb.commit()\n\n결과\n\nPlaceholdersql문을 작성할 때 placeholder를 사용해 데이터를 동적으로 다룰 수 있습니다.\ndata &#x3D; (&#39;케빈 파이기&#39;, 500000000)\n# data &#x3D; [[&#39;케빈 파이기&#39;, 1536253195], [&#39;에이미 파스칼&#39;, 1536253195], [&#39;제임스 건&#39;, 167400219]]\n\nsql &#x3D; &quot;SELECT * FROM filmInfo WHERE fDirector &#x3D; %s AND fBoxOffice &gt; %s&quot;\nexecute(sql, data)\nexecutemany(sql, multiple data)\n두 번째 파라미터에 들어간 data들이 작성된 순서대로 실행되어 반복문과 같은 동작을 하게 됩니다. \nLambda에 함수 적용하기이제 AWS 서버에 전의 과정을 통해 만들어진 함수들을 업로드해보겠습니다. 우선 이 함수에서 사용된 라이브러리들이 서버에는 없기 때문에 우리가 직접 제공해줘야 합니다. 아래 명령어를 통해 라이브러리를 원하는 디렉토리에 다운로드 받습니다.\n$ pip install PyMySQL -t .\n\n그리고 위의 함수에서 DB의 정보에 대한 부분을 dbinfo.py 파일에 따로 분리해주겠습니다.\ndb_host&#x3D;&#39;본인의 RDS 엔드포인트&#39;\ndb_user&#x3D;&#39;RDS username&#39;\ndb_password&#x3D;&#39;RDS password&#39;\ndb_name&#x3D;&#39;본인의 DB 이름&#39;\ndb_charset&#x3D;&#39;utf8&#39;\ndb_port&#x3D;3306 # RDS default\n원래 함수의 DB 정보 부분도 수정해줍니다.\nimport dbinfo\n\ndb &#x3D; mysql.connect(\n    host&#x3D;dbinfo.db_host, \n    user&#x3D;dbinfo.db_user, \n    password&#x3D;dbinfo.db_password, \n    db&#x3D;dbinfo.db_name, \n    charset&#x3D;dbinfo.db_charset\n)\n\n마지막으로 테스트를 위해 사용했던 pandas 라이브러리를 사용하지 않게 바꾸어줍니다.\nresult &#x3D; pd.DataFrame(result)\nprint(result)\n\nfor result in results:\n    print(result)\n위 코드를 아래 코드와 같이 바꿔주고, pandas를 import한 부분도 삭제해줍니다.최종적으로 얻은 이 네가지 파일과 폴더를 zip파일로 압축해줍니다. 이 압축 파일을 lambda 함수에 업로드 해야합니다.우측 상단에서 업로드를 진행하면,이렇게 lambda 함수의 내용이 압축 파일의 내용으로 교체됩니다.마지막으로 코드 하단에 있는 런타임 설정 &gt; 편집에서 핸들러를 실행할 파일 이름.그 코드에서 실행할 함수 이름으로 바꿔주고 저장합니다.이제 이 코드를 Test 해보겠습니다. Test 버튼을 누르고,이벤트 이름을 정해주고, 제 코드는 파라미터가 필요없으므로 공란으로 두고 생성해줍니다. 다음부터는 이벤트 템플릿에 저장된 테스트 이벤트를 선택해서 사용해줄 수 있습니다.이렇게 결과가 정상적으로 출력되었다면 성공입니다!\nAPI 배포이렇게 만들어진 API를 배포해보겠습니다. API Gateway로 돌아와서 API 배포를 해줍니다.\n스테이지 편집기의 상단에 API 호출 주소가 표시됩니다.\n왼쪽에서 이전에 만든 주소를 찾아 들어가면 해당 주소의 API 호출 주소도 볼 수 있습니다.\n이 주소로 접속해보면 현재는 null이 뜨는 것이 정상입니다. Lambda 함수에서 아무것도 return 해주지 않았기 때문이죠. API 주소가 제대로 작동하는 것을 확인했으니 이제 정말로 return 값도 만들어줍시다. Lambda 서비스로 돌아가 코드를 수정해줍니다. 저는 list를 만들어 결과들을 append 해준 뒤 return 해주었습니다.\nimport dbinfo\nimport pymysql as mysql\n\ndb &#x3D; mysql.connect(\n    host&#x3D;dbinfo.db_host, \n    user&#x3D;dbinfo.db_user, \n    password&#x3D;dbinfo.db_password, \n    db&#x3D;dbinfo.db_name, \n    charset&#x3D;dbinfo.db_charset)\n\ndef lambda_handler(event, context):\n    result_list &#x3D; []\n    try:\n        with db.cursor(mysql.cursors.DictCursor) as cursor:\n            sql &#x3D; &quot;SELECT * FROM actor&quot;\n            cursor.execute(sql)\n            results &#x3D; cursor.fetchall()\n    \n            for result in results:\n                print(result)\n                result_list.append(result)\n    finally:\n        return result_list\n\n이제 다시 API 호출 주소로 접속해보면?\n이렇게 결과값이 나오면 API 생성에 성공한 것입니다!\n","slug":"Assemble/220112_05/2022-01-12-assemble05","date":"2022-01-11T15:00:00.000Z","categories_index":"Assemble","tags_index":"Python,AWS,mySQL,Assemble","author_index":"nomatterjun"},{"id":"6fb7b20ef7439001e04bd4ee42c09224","title":"4)📱iOS앱개발 - API Gateway, Lambda 사용하기","content":"사용할 AWS 서비스들우선.. 안그래도 처음 다뤄보는 AWS인데 사용하는 서비스들이 너무 많게 느껴집니다.. 하지만 모바일 어플리케이션에서는 API의 형태로 DB에 접근하는 것이 좋다고 해서 이런 방식으로 진행해보고자 합니다. 진행 과정에서 많은 오류가 발생할 것 같아 일단 해보고 나중에 수정하는 방식으로 진행해보겠습니다.\n저의 최종 목적은 생성한 RDS에 API Gateway를 이용하여 REST API의 형태로 데이터를 생성&#x2F;조회&#x2F;수정&#x2F;삭제하는 것입니다. 이 때, 데이터를 건드리는 작업들을 하기 위해 필요한 “함수”들을 Lambda를 통해 구현합니다. 요약하면 다음 세 가지 서비스가 이번 포스트를 위해 사용할 서비스들입니다.\n\nRDS\nAPI Gateway\nLambda\n\nAmazon API Gateway란?우선 API Gateway부터 살펴봅시다. API Gateway는 AWS 클라우드에 저장된 모든 데어터에 HTTP 요청으로 액세스하는 REST &#x2F; Websocket API를 생성할 수 있게 하는 서비스입니다. 이렇게 만들어진 API를 호출하기 위한 Swift 언어용 SDK도 준비되어 있기 때문에 API를 생성할 수만 있다면 간편하게 이용할 수 있을 것 같습니다.\n\n\nAmazon Lambda란?다음으로 Lambda입니다. Lambda는 서버에 대한 걱정 없이 (내 소유의 서버 없이, Serverless) 개발자가 작성한 코드를 실행시켜주는 서비스입니다. AWS의 다른 서비스들과의 확장성이 뛰어나 여러방면에서 사용할 수 있습니다. 저는 사용자의 GET 명령이 있을 때마다 Lambda 서비스를 통해 코드를 실행시켜 db에서 데이터를 가져오게 할 예정입니다.\nAPI를 만들어보자.1. AWS Console에서 [Amazon API Gateway &gt; REST API 구축]을 통해 API를 생성해줍니다. 여기서 엔드포인트 유형은 지역으로 설정해줍니다.\n\n지역: 현재 지역에만 배포\n최적화된 에지: CloudFront(AWS) 네트워크에 배포\n프라이빗: VPC에서만 액세스 가능\n**2. [리소스 > 작업]에서 리소스 생성을 눌러 리소스 이름/경로를 설정하고 생성합니다.**\n\n\n생성한 리소스의 하위 리소스를 계속해서 만들 수 있습니다. /films 주소 뒤에 /{fID} 리소스를 생성하였습니다. {}가 포함된 경로는 파라미터를 가질 수 있습니다.\n\n**3. AWS Console에서 [Lambda > 함수 > 함수 생성]을 통해 함수를 새로 생성합니다.**\n\n생성된 Lambda 함수를 보면 기본으로 \"Hello from lambda!\"라는 메시지를 출력하는 함수가 입력되어 있습니다.\n\n**4. 다시 API Gateway로 돌아가 이번에는 메서드를 생성합니다.**\n\nDB의 내용을 조회하는 요청이기 때문에 GET 메서드를 생성해야 합니다.\n\n메서드의 통합 유형을 Lambda 함수, 리전은 현재 위치 (서울), 함수에는 이전에 생성한 함수의 이름을 적고 저장해줍니다.\n\n메서드가 저장되면 메서드의 실행 단계를 한 눈에 볼 수 있으며, \"테스트\" 버튼을 통해 메서드가 제대로 동작하는지 확인해볼 수 있습니다.\n\n\n\n","slug":"Assemble/220111_04/2022-01-11-assemble04","date":"2022-01-10T15:00:00.000Z","categories_index":"Assemble","tags_index":"AWS,Assemble","author_index":"nomatterjun"},{"id":"b06e01c571f7d6e2c0ed7687c5f5f482","title":"3)📱iOS앱개발 - DB 설계하기","content":"ERD 작성하기나름 학기중에 DB 과목을 배웠으니 설계 단계부터 제대로 해보기로 했습니다. 이전 프로젝트 때는 DB 개념을 제대로 몰랐기 때문에 막무가내로 DB를 구현했었는데 덕분에 엔티티나 속성을 새로 추가하거나 수정할 때마다 곤욕을 치뤘습니다.우선 ERD가 무엇인지부터 다시 정리해보면 아래와 같이 말할 수 있을 것 같습니다.\n\n\n\n\n\n\n\n\n\nERD (Entity Relation Diagram) -ERM(Entity Relation Model, 관계형모델)을 다이어그램으로 시각화하여 데이터의 구조를 파악하기 쉽게 해주는 그림이다. 엔티티의 속성과 엔티티간의 관계를 한 눈에 보기 쉽게 표현한다.\n\n\nERD를 그릴 수 있는 프로그램은 매우 다양하지만 가장 보편적으로 사용되는 MySQL Workbench 프로그램을 사용해보았습니다. MySQL 공식 홈페이지에서 다운받을 수 있습니다.\nWorkbench를 실행한 초기화면에서 MySQL Connections 옆에 있는 + 버튼을 눌러 새로운 연결을 만들어 주겠습니다.\n그러면 이런 화면이 나오는데, 미리 만들어둔 AWS의 RDS 정보를 입력해줍니다. 새로운 RDS를 생성하는 방법은 구글에 “AWS RDS EC2”만 검색해도 많이 나옵니다. 저도 처음 다루어보는 것이기 때문에 정확하게 설명한 분들의 게시물과 본인의 상황에 맞게 생성해보는 것을 추천합니다.\n\n\n\n\n간단하게만 설명하면, \nRDS: 아마존이 제공하는 DB 서비스\nEC2: 아마존이 제공하는 가상 서버 서비스\n위의 두 가지 서비스를 연결하여 EC2를 통해 RDS DB에 접근하는 방식입니다. EC2를 생성할 때 우분투 등의 os 환경을 지정하여 사용할 수 있고, RDS 또한 SQL 외에도 MariaDB, Aurora 등을 선택하여 생성할 수 있습니다.\n\n\n성공적으로 연결이 되면, ERD를 작성하기 위해 메뉴의 Database -&gt; Reverse Engineer에 들어갑니다.\n\n\n가장 상단의 EER Diagrams 탭의 Add Diagram을 통해 ERD 설계를 할 수 있습니다.\n\n\n왼쪽에 있는 도구들의 목록을 보면 도구 아이콘들이 이렇게 있습니다. 가장 기본이 되는 테이블부터 추가해보겠습니다.\n\n\n테이블 추가 도구를 통해 테이블을 추가하고, 추가된 테이블을 더블 클릭하면 테이블을 수정할 수 있습니다. 테이블의 column과 datatype, Priority Key(PK), Not Null(NN) 등을 설정할 수 있습니다.\n\n\nForeign Key는 테이블 선택 상태에서 하단의 메뉴를 보면 탭이 따로 있습니다. 이곳에서 참조하는 테이블을 설정하고, 어떤 column이 참조하는 테이블의 어떤 column을 참조하는지 설정할 수 있습니다.\n\n\nForeign Key를 설정하면 다이어그램에 화살표가 생기는 것을 확인할 수 있는데, 이 화살표를 더블클릭하면 Relation 또한 수정할 수 있습니다. 마찬가지로 하단의 Foreign Key 탭을 보면 Relation이 1:n 관계인지, n:m 관계인지 설정할 수 있는 것을 확인할 수 있습니다.\n\n\n우선 이 정도로 구성해두고 추후에 수정하면서 진행하도록 했습니다. 이전 프로젝트와는 다르게 다이어그램이 있으니 추후에 수정할 때도 난잡하지 않게 다시 정리할 수 있기를 바랍니다.\n\n\n이제 이 db 모델을 RDS에 적용해보겠습니다. Reverse Engineering을 열었던 메뉴에서 이번에는 Forward Engineer를 선택해줍니다.\n\n\n\n\n\n이미 RDS에 연결을 한 상태에서 Forward를 하고 있기 때문에 특별히 건들여줄 것은 없습니다. 두 번째 단계에서 원하는 옵션이 따로 있다면 선택해주고, 네 번째 단계에서 스크립트를 점검할 수 있습니다.\n\n\n한두번의 실패 후에 이렇게 성공했다는 메시지가 떴습니다! 이제 스키마가 RDS에 정상적으로 적용 됐는지 확인해보겠습니다.\n\n\n왼쪽 사이드바의 Schemas에서 마우스 오른쪽 버튼을 누르고 Refresh를 해보았습니다.\n\n\n이렇게 스키마가 추가되었고 테이블을 살펴보면 ERD로 설계했던 테이블이 그대로 들어간 것을 확인할 수 있습니다! 이제부터는 gui던 cli던 편한대로 사용하면서 수정을 해보겠습니다.\n","slug":"Assemble/220110_03/2022-01-10-assemble03","date":"2022-01-09T15:00:00.000Z","categories_index":"Assemble","tags_index":"AWS,mySQL,Assemble","author_index":"nomatterjun"},{"id":"9b25483611e26238e83efe31554cdaec","title":"2)📱iOS앱개발 - CocoaPod 설치하기","content":"\n\n프로젝트를 시작하기에 앞서 설치해야할 것이 있습니다. 이번 포스트 제목에서 알 수 있듯이 CocoaPod이라는 놈입니다.그런데 이 CocoaPod이라는 놈이 뭘 하는 놈인지는 알고 설치를 해야겠죠?\nCocoaPod이란?대개의 유명한 프로젝트가 그렇듯이 모든 정보는 공식 홈페이지만 봐도 자세하게 상술되어 있습니다. \n\n\n\n\n\n\n\n\n\nCocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 87 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.\n해석해보면 “CocoaPods은 Swift와 Obj-C 프로젝트를 위한 종속 매니저입니다. 87,000개 이상의 라이브러리를 가지고 있으며 3백만개 이상의 앱에서 이들이 사용되고 있습니다. CocoaPods은 당신의 프로젝트를 우아하게 확장시켜 줄 수 있습니다.” 라고 설명하고 있습니다.\n\n\n맞습니다. CocoaPod은 라이브러리 매니저입니다. Xcode에 기본으로 탑재되어 있는 Swift Package Manger라는 놈과 비슷한 기능을 하는 놈이죠. 개발하는동안 필요한 핵심 기능들이나 디자인들이 이미 완성도 높게 CocoaPod을 통해서 공유되고 있는 경우가 많습니다. 직접 모든 것을 개발하는 것도 물론 중요하지만 이미 나와있는 소스들을 잘 활용하는 것도 매우 중요합니다.\nCocoaPod 설치하기1. 터미널에서 아래 명령어를 입력해줍니다.\n$ sudo gem install cocoapods\n\n2. CocoaPod을 적용할 프로젝트 디렉토리로 이동해줍니다.\n\n\n3. 이동한 상태에서 아래 명령어를 입력해줍니다.\n$ pod init\n\n그러면 아래와 같이 Podfile이 생성 되었을겁니다.\n\n\n4. 이 Podfile에 아래와 같이 원하는 pod을 입력해주면 됩니다.\n\n\n보통 라이브러리의 깃허브를 보시면 제작자분이 자세하게 설치 방법도 적어주십니다.이번에는 iOS 프로젝트에서 정말 많이 사용되는 DBM인 Realm을 설치해보겠습니다.Podfile을 저장해주고 다시 터미널 창으로 가줍니다.\n5. 이제 아래 명령어로 라이브러리를 설치해줍시다.\n$ pod install\n\n\n\n아래 노란 부분은 플랫폼 버전이나 버전 관리를 정확하게 해주지 않아서 뜨는 경고입니다. 급한건 아니니 나중에 처리해주도록 하고, 중요한 건 초록색 부분입니다!pod이 성공적으로 설치되었고 ‘프로젝트이름.xcworkspace’ 파일을 사용하라고 하는군요.\n\n\n기존 프로젝트 외에 흰색 아이콘의 xcworkspace 파일이 생성된 것을 확인할 수 있습니다. 라이브러리를 사용할 때는 이 파일을 열어주어 작업해야합니다. 원래의 파란 아이콘의 xcodeproj 파일을 열면?\n \n왼쪽 이미지와 같이 Pods라는 프로젝트가 불러와지지 않고 라이브러리들을 사용할 수 없게 됩니다.\nPod 삭제하기Pod을 통해 라이브러리를 설치했다면 삭제하고 싶을 때도 있겠죠? 이 때도 간단합니다.다시 Podfile을 열어보겠습니다.\n\n\n설치할 때 입력해줬던  pod ‘RealmSwift’  부분을 지워주고 다시 아래 명령어를 입력해줍니다.\n$ pod install\n\n\n\n이렇게 삭제됩니다.\n","slug":"Assemble/220106_02/2022-01-06-assemble02","date":"2022-01-05T15:00:00.000Z","categories_index":"Assemble","tags_index":"Swift,iOS,Assemble","author_index":"nomatterjun"},{"id":"89904a00e743f6436b48ab3c60d884d7","title":"1)📱iOS앱개발 - 프로젝트 구상하기","content":"이전에 진행하고 있던 프로젝트가 엎어졌다..   서드파티 앱이였는데 해당 기능이 서비스에 직접 도입되어 개발 필요성이 사라져버렸다.   개발사가 일을 너무 열심히 해도 문제다..   거의 완성이였던 프로젝트를 급하게 마무리하고 나만의 보관소에 모셔두었다.\n새롭게 진행할 프로젝트가 필요해졌지만 주제를 고르는 것은 어렵지 않았다. 약 보름전에 개봉했던 “스파이더맨:노웨이홈”이 코로나 시국에도 불구하고 대흥행을 거두었다. 스파이더맨 팬이였던 나는 한동안 영화에서 헤어나오지 못했고, 이 넘쳐흐르는 스파뽕을 가만히 둘 수 없었다. \n\n\n히어로 영화 관련된 앱을 만들어야겠다는 생각이 들었다. 노웨이홈과 디즈니플러스 드라마를 중심으로 MCU, SSU, DCU까지 히어로 작품 제작에 박차를 가하고 있다. 히어로 작품들은 쏟아져 나올 것이고 정보들도 범람할 것이다.\n\n\n\n\n\n\n\n\n\n그렇다면 쏟아져 나오는 히어로 작품 정보들을 한 곳에 모아 제공하는 앱을 만들면 어떨까?\n개발 측면에서 봤을 때도 다양한 기능들(API 활용, 서버 DB, 인앱 웹브라우저 등)을 연습해 볼 수 있을 것 같아 바로 실행하게 되었다. \n\n🧐 정보모음앱이니 API부터 알아보자\n네이버 영화 API\n 국내 정보는 역시 네이버, 카카오\n\n영화진흥위원회 API\n 다양한 정보를 상세하게 나눠 제공한다. 유용하게 활용할 수 있을 것 같다.\n\n3대 평론사이트 API\n\n로튼토마토\n  Welcome to the Rotten Tomatoes® Developer Network\n\nIMDB\n  API for IMDb, TMDb, Subscene, Wikipedia and more - IMDb-API\n\n메타크리틱\n  Metacritic API\n\n\n\nSuperHero API\n 각 히어로별로 스탯이나 인물 관계를 제공하는 것 같다.\n\n\n\n💻 그렇다면 개발환경은?\n개발언어: Swift (iOS 네이티브)\nDB: SQL 혹은 Realm (realm이 익숙하지만 학기중에 배운 sql을 활용해보고자 한다)\n서버: AWS (로컬만으로는 절대 구현할 수 없는 기능들이 있다)\n\n\n📱 어떤 기능을 구현할 것인가?\n각 작품들의 정보 제공 (출연진, 등장 히어로, 예고편, 평점, 선행 작품 등)\n히어로 별 커뮤니티 게시판\n개봉 디데이 위젯\n\n","slug":"Assemble/220105_01/2022-01-05-assemble01","date":"2022-01-04T15:00:00.000Z","categories_index":"Assemble","tags_index":"Swift,iOS,Assemble","author_index":"nomatterjun"}]