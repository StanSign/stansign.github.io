<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="kr"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="/jekyll-theme-yat/" rel="alternate" type="text/html" hreflang="kr" /><updated>2023-03-29T04:42:10+00:00</updated><id>/jekyll-theme-yat/feed.xml</id><title type="html">끄적끄적…</title><subtitle>사과가 되고 싶은 감자 이야기</subtitle><author><name>nomatterjun</name></author><entry><title type="html">26)🍎 Swift - Concurrency</title><link href="/jekyll-theme-yat/swift/2023/03/28/Swift26.html" rel="alternate" type="text/html" title="26)🍎 Swift - Concurrency" /><published>2023-03-28T00:00:00+00:00</published><updated>2023-03-28T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/03/28/Swift26</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/03/28/Swift26.html"><![CDATA[<h1 id="concurrency">Concurrency</h1>

<p>WWDC21의 주요 주제는 Concurrency라고 생각합니다.</p>

<p>21년에 처음 공개된 후 관련된 포스트도 많아졌고 서드파티 라이브러리에서도 대응 업데이트가 많이 이루어진 상황입니다.</p>

<p>이제 슬슬 실무에 사용되는 모습들도 보이기 시작하는 것 같습니다.</p>

<p>어렴풋이 “<code class="language-plaintext highlighter-rouge">async</code>와 <code class="language-plaintext highlighter-rouge">await</code>를 사용하는 문법이다.” 정도로만 알아두고 나중에 공부해야겠다 생각했지만 프로젝트에서 <code class="language-plaintext highlighter-rouge">callback</code> 지옥을 본 순간.. 학구열이 올라 한 번 학습해봤습니다.</p>

<p>WWDC21의 세션들을 살펴보았더니 관련 세션만 거의 10개에 달하고 하나하나의 내용들도 꽉 찬 20~30분 정도를 이루고 있더군요..</p>

<p>그래서 내용이 무지무지 많습니다.. 🫠</p>

<h2 id="비동기-프로그래밍">비동기 프로그래밍</h2>

<p><strong>비동기 코드</strong>는 <strong>“나중에 언젠가 호출되어 실행될 코드”</strong> 입니다.</p>

<p>그 시기는 보장되지 않으며 순서 또한 보장되지 않을 때도 있습니다.</p>

<p>Swift에서는 우리가 흔히 <strong>GCD</strong>라고 부르는 <code class="language-plaintext highlighter-rouge">DispatchQueue</code>를 통해 지원하는 개념이였죠.</p>

<pre><code class="language-Swift">print("1")
DispatchQueue.main.async {
  print("2")
}
print("3")
</code></pre>

<p>위 코드의 <code class="language-plaintext highlighter-rouge">print("2")</code> 구문은 비동기 코드입니다.</p>

<p>따라서 순서와 호출 시기가 불확실합니다.</p>

<p>바로 호출될수도 있고 아닐수도 있죠.</p>

<blockquote>
  <p>1 2 3</p>
</blockquote>

<blockquote>
  <p>1 3 2</p>
</blockquote>

<p>그래서 위와 같이 <strong>실행마다 결과가 다를</strong>수도 있습니다.</p>

<p>비동기코드는 <strong>1. 해당 라인에 도달되도 바로 실행되지 않고</strong>, <strong>2. 이후에 있는 코드의 실행을 Blocking하지도 않습</strong>니다.</p>

<p>비동기 코드가 언제 실행되는지 모른다면, 비동기적으로 산출된 어떤 값을 언제 사용해야 할까요?</p>

<p>다행히도 비동기 코드가 <strong>종료되는 시점</strong>은 우리가 알 수 있습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">@escaping</code> 클로저</strong>를 통해서요.</p>

<pre><code class="language-Swift">func foo() {
  print("1")
  asyncFoo(completion: { value in
    print(value)
  })
  print("3")
}

func asyncFoo(completion: @escaping (String) -&gt; Void) {
  DispatchQueue.main.async {
    let a = "2"
    completion(a)
  }
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">asyncFoo</code> 메서드에서 <code class="language-plaintext highlighter-rouge">completion</code> 클로저는 <code class="language-plaintext highlighter-rouge">async</code> 함수가 종료되는 시점에 호출되어 콜러인 <code class="language-plaintext highlighter-rouge">foo</code> 메서드에 <code class="language-plaintext highlighter-rouge">String</code> 타입 파라미터 <code class="language-plaintext highlighter-rouge">value</code>를 제공합니다.</p>

<p>이런 방식의 문법은 어떤 함수가 끝났을 때의 동작들의 묶음을 명시적으로 모아둘 수 있다는 장점이 있지만 <em>(장점인가..?)</em> <code class="language-plaintext highlighter-rouge">callback</code> 지옥과 코드 가독성이 떨어진다는 문제점을 가집니다.</p>

<h3 id="gcd의-진짜-문제점">GCD의 진짜 문제점</h3>

<p>코드의 가독성과 개발자에게 주는 불쾌한 경험도 중요하지만 GCD에는 더욱 크리티컬한 단점이 존재합니다.</p>

<p>바로 <strong>CPU의 불필요한 추가 동작</strong>과 <strong>과도한 리소스의 사용</strong>을 유발할 수 있다는 점입니다.</p>

<p>이게 무슨 말인지 살펴볼까요?</p>

<p>DispatchQueue에 동작이 enqueue되면, 시스템은 해당 작업이 수행될 <strong>쓰레드를 불러오고 수행</strong>시킵니다.</p>

<p>만약 무수히 많은 동작들이 enqueue되면, 시스템은 해당 동작들을 동시에 수행하기 위해 <strong>쓰레드를 계속해서 불러</strong>옵니다. <strong>CPU의 코어</strong>가 <strong>더 이상의 쓰레드 작업을 추가할 수 없을 때까지</strong>요.</p>

<p><img src="https://i.imgur.com/wFvTBDv.png" alt="" /></p>

<blockquote>
  <p>코어가 2개인 환경에서 쓰레드를 추가적으로 불러오는 상황</p>
</blockquote>

<p>하나의 코어가 여러개의 쓰레드를 가지고 있는 이유는 여러가지입니다.</p>

<ol>
  <li>하나의 쓰레드가 Block되더라도 <strong>코어가 쉬지않고 다른 쓰레드의 작업</strong>을 할 수 있도록 하기 위해</li>
  <li>쓰레드간의 <strong>Race Condition을 해결</strong>하기 위해 (Semaphore 참고)</li>
</ol>

<p>그런데 과연 Blocking된 쓰레드가 많아진다고 쓰레드를 무수히 많이 불러오는 것이 항상 좋을까요?</p>

<p><img src="https://i.imgur.com/yQLmP2Y.png" alt="" /></p>

<p>당연히 아니겠죠..</p>

<p>쓰레드들이 Blocking된 상태에서 추가적으로 쓰레드를 계속 불러온다면, 더 이상 코어가 쓰레드를 불러올 수 없는 상태가 됩니다.</p>

<p>해당 현상을 <strong>Thread Explosion</strong>이라고 부릅니다.</p>

<blockquote>
  <p>Swift는 이를 해결하기 위해 <code class="language-plaintext highlighter-rouge">DispatchSemaphore</code>와 같은 기능을 제공하고 있기는 합니다. 문제는 너무 복잡하다는 것이죠..!</p>
</blockquote>

<p>Thread Explosion 현상이 발생하면 OS는 여러 문제를 마주칩니다.</p>

<p><img src="https://i.imgur.com/oTDfwu0.png" alt="" /></p>

<ul>
  <li><strong>메모리 오버헤드</strong>: Block된 쓰레드는 각자 <strong>메모리와 리소스를 점거</strong>하고 있습니다. 다른 쓰레드의 unlock을 위해 필요한 리소스를 점거하고 있을 수도 있죠.</li>
</ul>

<p><img src="https://i.imgur.com/MrBlrHa.png" alt="" /></p>

<ul>
  <li><strong>스케줄링 오버헤드</strong>: CPU의 코어는 쓰레드간의 전환을 위해 <strong>컨텍스트 스위칭(Context Switching)</strong> 이라는 작업을 수행해야 합니다. 쓰레드가 폭발적으로 많아지면 컨텍스트 스위칭도 빈번히 일어나 불필요한 작업이 늘어납니다.</li>
</ul>

<p>자 그래서 Swift는 이런 현상을 어떻게 해결했느냐?</p>

<h2 id="async--await">async / await</h2>

<p>새로운 Swift의 <strong>asynchronous</strong> 개념 <code class="language-plaintext highlighter-rouge">async / await</code>와 <strong>concurrency</strong>를 통해서죠.</p>

<p>실은 멀티 쓰레딩의 이러한 오버헤드들은 이전부터 다양한 언어와 운영체제 전문가들에게 문제시 되어왔습니다.</p>

<p>이들이 제시한 방법은 바로 <strong>Coroutine</strong> 방식이였습니다.</p>

<p>오래전 멀티쓰레딩 방식이 제시되고 통용되기 시작하며 자연스럽게 버려졌던 Coroutine 방식이 현대에 와서 다시 연구되고 발전하고 있죠.</p>

<p>실제로 Python, Kotlin과 같은 언어들이 적극적으로 Coroutine 방식을 사용하고 있습니다.</p>

<p>그래서 Coroutine 방식은 어떤 방식이냐?</p>

<p><strong>코루틴(Coroutine)</strong> 은 <strong>CPU의 코어 개수만큼</strong>만 쓰레드를 만들고 쓰레드를 차단하는 대신 <strong>작업을 막아둠</strong>으로써 <strong>컨텍스트 스위칭을 차단</strong>합니다.</p>

<p><img src="https://i.imgur.com/G8fVpID.png" alt="" /></p>

<p>Swift 용어로 바꾸어볼까요?</p>

<p>Swift <strong>Concurrency</strong>는 <strong>쓰레드의 차단(Blocking)을 없애</strong>고 작업의 재실행(Resumption of Work)를 추적하는 <strong>continuation</strong>이라는 객체를 통해 Context Switching 대신 <strong>같은 쓰레드 내에서 Continuation Switching</strong>을 수행하여 동시성 프로그래밍을 지원합니다.</p>

<p>자 Concurrency가 <em>(모순적이게도)</em> 현대적이고 좋다는 건 알았어요.</p>

<p>그래서 <code class="language-plaintext highlighter-rouge">async / await</code>은 어떻게 사용할까요? 😒</p>

<p>WWDC에서도 사용한 기존의 <code class="language-plaintext highlighter-rouge">@escaping</code> 클로저를 사용하는 예시를 가져와봤어요.</p>

<p><img src="https://i.imgur.com/BJ4S8qO.png" alt="" /></p>

<p>시스템적인 단점 말고 코드 작성의 측면에서 <code class="language-plaintext highlighter-rouge">@escaping</code> 클로저 방식은 세가지 단점을 가지고 있습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">completion</code> 클로저 호출을 까먹기 쉽습니다. (여러군데에 필요)</li>
  <li><code class="language-plaintext highlighter-rouge">callback</code>이 중첩해서 발생하는 경우가 많습니다.</li>
  <li>코드 가독성이 떨어집니다.</li>
</ol>

<p>자 그런데 <code class="language-plaintext highlighter-rouge">async / await</code>를 사용한 코드로 바꿔보면요?</p>

<p><img src="https://i.imgur.com/5VqRh34.png" alt="" /></p>

<p>엄청 짧아지고 수많았던 중괄호들이 사라졌어요! 👏</p>

<h3 id="async">async</h3>

<p>함수의 파라미터와 반환타입 중간에 <strong><code class="language-plaintext highlighter-rouge">async</code></strong> 를 붙여줌으로써 <strong>해당 함수가 비동기성</strong>이다 라는 것을 나타내줍니다!</p>

<p><code class="language-plaintext highlighter-rouge">throws</code>를 통해 해당 함수가 에러를 방출할 수 있다라는 것도 함께 명시해줄 수 있습니다.</p>

<h3 id="await">await</h3>

<p><code class="language-plaintext highlighter-rouge">async</code>로 정의된 함수를 호출하기 위해서는 <strong>Concurrent Context 내부</strong>에서 <strong><code class="language-plaintext highlighter-rouge">await</code> 키워드</strong>를 붙여주어야 합니다.</p>

<pre><code class="language-Swift">let (data, response) = try await URLSession.shared.data(for: request)
</code></pre>

<p>주의할 점은 정의할때는 순서가 <code class="language-plaintext highlighter-rouge">async throws</code>지만, 사용할때는 <code class="language-plaintext highlighter-rouge">try await</code> 순서라는 것을 알아두어야합니다.</p>

<p><code class="language-plaintext highlighter-rouge">await</code> 키워드는 해당 라인이 <strong>Suspension Point</strong>라는 것을 명시하는 역할을 합니다.</p>

<h3 id="suspend">Suspend</h3>

<p><code class="language-plaintext highlighter-rouge">await</code> 포인트를 만나면 된다는 Suspend는 또 뭘까요?</p>

<p><strong>Suspend</strong>는 <strong>“해당 스레드가 다른 동작을 수행할 수 있도록 스레드의 통제권을 시스템에게 넘겨준다”</strong> 라는 것을 의미합니다.</p>

<p><img src="https://i.imgur.com/tmlzOQQ.png" alt="" /></p>

<p>일반적인 <strong>synchronous</strong>한 코드의 경우에는 위와 같이 동작합니다.</p>

<p><code class="language-plaintext highlighter-rouge">fetchThumbnail</code> 함수에서 <code class="language-plaintext highlighter-rouge">thumbnailURLRequest</code> 함수를 호출하고 있습니다.</p>

<p>이 때 두 함수 모두 sync 함수이기 때문에 <code class="language-plaintext highlighter-rouge">fetchThumbnail</code> 함수는 <code class="language-plaintext highlighter-rouge">thumbnailURLRequest</code> 함수에게 <strong>쓰레드 제어권을 넘겨줍니다.</strong></p>

<p><code class="language-plaintext highlighter-rouge">thumbnailURLRequest</code> 함수는 수행에 얼마나 많은 시간이 걸리던 쓰레드를 점유하고 작업이 완료되면 <strong>제어권</strong>을 다시 Caller인 <code class="language-plaintext highlighter-rouge">fetchThumbnail</code> 함수에게 <strong>돌려줍니다.</strong></p>

<p>이 경우 쓰레드는 이 두 작업 외의 <strong>다른 작업들을 수행할 수 없습니다.</strong></p>

<p><img src="https://i.imgur.com/blAu5WR.png" alt="" /></p>

<p><strong>asynchronous</strong>한 경우에는 어떨까요?</p>

<p><code class="language-plaintext highlighter-rouge">fetchThumbnail</code> 함수가 <code class="language-plaintext highlighter-rouge">data(for: request)</code> 함수에게 쓰레드 제어권을 넘겨주는 것까지는 동일합니다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">await</code>로 명시된 <code class="language-plaintext highlighter-rouge">data(for: request)</code> 함수는 <strong><code class="language-plaintext highlighter-rouge">async</code> 함수</strong>이기 때문에 중간에 <strong>suspend</strong> 될 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">async</code> 함수가 suspend되면, <strong>쓰레드 제어권</strong>은 다름아닌 <strong>시스템</strong>에게 넘겨집니다.</p>

<p>그러면 시스템은 다른 작업을 할 수 있게 되는 것이죠.</p>

<p>시스템은 <strong>알아서</strong> suspend 되거나 수행이 필요한 다른 작업들의 우선순위들을 판단해가며 처리해나갑니다.</p>

<p>시스템이 suspend 되었던 함수의 처리가 필요해졌다고 판단하는 순간, 쓰레드 제어권은 다시 <code class="language-plaintext highlighter-rouge">async</code> 함수였던 <code class="language-plaintext highlighter-rouge">data(for: request)</code> 함수에게 재개(<strong>resume</strong>)되고 이후의 작업들이 수행될 수 있게 됩니다.</p>

<p>자 다시 돌아가서 Suspend가 이루어지는 과정을 자세히 살펴볼게요.</p>

<p><img src="https://i.imgur.com/OlVlEgJ.png" alt="" /></p>

<p><strong>Synchronous</strong>한 함수의 경우 메모리의 <strong>스택 영역</strong>에 함수들이 <strong><code class="language-plaintext highlighter-rouge">push</code></strong> 되며 쌓이게 됩니다.</p>

<p>그러다가 함수의 실행이 끝나면 <strong><code class="language-plaintext highlighter-rouge">pop</code></strong> 되어 스택에서 제거되죠.</p>

<p>아주 간단명료합니다.</p>

<p>그러면 <strong>asynchronous</strong>한 경우에는 어떨까요?</p>

<p><img src="https://i.imgur.com/kXukxOi.png" alt="" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">async</code> 함수</strong>라고 명시되어 있는 경우, scope 전체를 한 번 돌며 <strong>suspension point(<code class="language-plaintext highlighter-rouge">await</code>)</strong> 마다 <strong>어떤 변수</strong>가 <strong>여러 쓰레드</strong>에서 사용되는지를 파악합니다.</p>

<p>예시의 경우, <code class="language-plaintext highlighter-rouge">id</code>와 <code class="language-plaintext highlighter-rouge">particle</code>은 쓰레드 사이를 오갈 필요가 없는 <strong>local 변수</strong>이죠?</p>

<p>따라서 해당 변수들은 synchronous 함수의 경우와 마찬가지로 <strong>스택 영역</strong>에 저장됩니다.</p>

<p><img src="https://i.imgur.com/hVDxMMn.png" alt="" /></p>

<p>그렇다면 <code class="language-plaintext highlighter-rouge">await</code>에서 사용된 <code class="language-plaintext highlighter-rouge">newArticles</code> 변수(<em>파라미터로 받았기 때문에 상수이지만 편의상 변수라고 하겠습니다.</em>)의 경우는 어떨까요?</p>

<p><code class="language-plaintext highlighter-rouge">suspend</code>되는 코드는 잠깐 멈춰있다가 다시 실행되야하기 때문에 필요한 변수들을 멈추기 <strong>이전과 이후 모든 시점에 사용</strong>할 수 있어야 합니다.</p>

<p>Swift는 이를 위해 <strong>Heap 영역</strong>을 활용합니다.</p>

<p><img src="https://i.imgur.com/zt4JmwU.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">add</code> 함수를 힙 영역에 저장하고 나면 스택 영역에는 해당 프레임을 계속 붙잡고 있을 필요가 없기 때문에 실행이 필요한 <code class="language-plaintext highlighter-rouge">save</code> 함수로 대체됩니다.</p>

<p><img src="https://i.imgur.com/XmdB0tW.png" alt="" /></p>

<p>이 <code class="language-plaintext highlighter-rouge">save</code> 함수 안에 마찬가지로 <code class="language-plaintext highlighter-rouge">await</code> 코드가 담겨있다고 가정해보면, 해당 <code class="language-plaintext highlighter-rouge">save</code> 함수 또한 힙 영역으로 옮겨진 후 시스템에 쓰레드 제어권을 넘겨주게 됩니다.</p>

<p><img src="https://i.imgur.com/K1SLhLB.png" alt="" /></p>

<p>쓰레드는 다른 작업들(<code class="language-plaintext highlighter-rouge">otherWork1</code>, <code class="language-plaintext highlighter-rouge">otherWork2</code>)을 마찬가지로 힙 영역에 보관하며 수행합니다.</p>

<p>따라서 힙 영역에는 <code class="language-plaintext highlighter-rouge">async</code> 함수들의 스택들이 모여있게 되는 것이죠.</p>

<p><strong>Continuation</strong>이라는 것이 이런 힙 영역의 <code class="language-plaintext highlighter-rouge">async</code> 스택을 대표한다고 합니다.</p>

<blockquote>
  <p>Continuation이란 단순히 <code class="language-plaintext highlighter-rouge">await</code> 이후에 수행되는 작업들을 표현하는 말이라고 합니다. <code class="language-plaintext highlighter-rouge">withCheckedThrowingContinuation(continuation:)</code>과 같은 메서드에서 사용되니 참고해주세요!</p>
</blockquote>

<p><img src="https://i.imgur.com/njgQmFm.png" alt="" /></p>

<p><strong>작업이 없는 쓰레드</strong>가 생기고 힙 영역에 저장된 <code class="language-plaintext highlighter-rouge">async</code> continuation이 다음 작업으로 선택되면, 힙 영역에 있던 작업 스택을 하나씩 다시 <strong>스택 영역</strong>으로 불러와 차근차근 작업을 수행합니다.</p>

<blockquote>
  <p>이 때, <strong>작업이 없는 쓰레드</strong>라는 것은 <code class="language-plaintext highlighter-rouge">await</code> 이전에 수행하던 쓰레드일수도 있고 아닐 수도 있습니다. <strong>보장되지 않는다</strong>는 것이죠.</p>
</blockquote>

<p>자 그래서 이 <code class="language-plaintext highlighter-rouge">async / await</code>를 이용한 Concurrency는 어떻게 사용하면 될까요?</p>

<h2 id="task">Task</h2>

<p><img src="https://i.imgur.com/N9K39Fh.png" alt="" /></p>

<p>위의 예시를 여러번 수행하는 또 다른 예시입니다.</p>

<p>이 예시는 상당히 좋은 예시이고 아주 정상적으로 잘 동작하는 예시입니다.</p>

<p>하지만 한 가지 개선이 필요한 부분이 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">for in</code>을 통해서 여러번의 <code class="language-plaintext highlighter-rouge">URLSession</code>을 <code class="language-plaintext highlighter-rouge">await</code>하는 것인데요.. 이런 식의 구현은 <strong>한 번에 하나의 루프</strong>만을 수행할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">async</code>하게는 구현하였지만 <strong>concurrent하지는 못한</strong> 것입니다.</p>

<p>또한 <code class="language-plaintext highlighter-rouge">fetchThumbnails()</code>이라는 함수 또한 결국에는 <code class="language-plaintext highlighter-rouge">async</code> 함수이기 때문에 프로젝트의 어딘가에서는 <strong>async 컨텍스트</strong>를 제공해줄 곳이 필요합니다.</p>

<p>이 때 <strong>Task</strong>가 등장합니다.</p>

<p><strong>Task</strong>는 concurrent한 코드 수행을 위한 <strong>새로운 async 컨텍스트를 제공</strong>합니다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">async</code> 함수를 단순히 call 하는 것은 Task를 생성하지 않습니다! (GCD 등을 사용하면 call 할 수는 있습니다.)</p>
</blockquote>

<p>하지만 어떤 Task들이 있나 보기 이전에 <strong>Task Tree</strong>라는 개념을 알아두어야 합니다.</p>

<h3 id="task-tree">Task Tree</h3>

<p><strong>Task Tree</strong>는 Task의 <strong>취소(cancellation)</strong>, <strong>우선순위(priority)</strong>, <strong>지역변수(task-local variables)</strong> 등의 속성들을 결정하는 아주 중요한 개념입니다.</p>

<p>기본적으로는 어떤 <code class="language-plaintext highlighter-rouge">async</code> 함수가 다른 <strong><code class="language-plaintext highlighter-rouge">async</code> 함수를 호출</strong>하면, 두 함수를 호출하는 데에는 <strong>같은 Task</strong>가 사용됩니다.</p>

<p><img src="https://i.imgur.com/OHtAIMh.png" alt="" /></p>

<p>아래 <code class="language-plaintext highlighter-rouge">async-let</code>에서 사용된 예시의 경우를 먼저 한 번 가져와봤습니다.</p>

<p><code class="language-plaintext highlighter-rouge">fetchOne()</code> 함수가 두 가지의 Task <code class="language-plaintext highlighter-rouge">data</code>와 <code class="language-plaintext highlighter-rouge">metadata</code>를 호출하는 경우입니다.</p>

<p><code class="language-plaintext highlighter-rouge">fetchOneThumbnail()</code> 함수는 두 가지 Task를 child로 갖고 있다고 했습니다.</p>

<p>이처럼 한 Task가 다른 Task를 실행하면 실행된 Task들은 현재 함수가 실행되고 있는 Task의 <strong>Child Task</strong>가 됩니다.</p>

<blockquote>
  <p>Task는 함수에 종속된 개념은 아니지만 함수의 생명주기에 영향을 받을 수는 있습니다.</p>
</blockquote>

<p>그리고 <strong>Parent Task</strong>는 종속된 <strong>모든 Child Task들이 종료되기 전</strong>에는 <strong>종료될 수 없습니다</strong>.</p>

<p>만약 <code class="language-plaintext highlighter-rouge">metadata</code> Task가 에러를 <code class="language-plaintext highlighter-rouge">throw</code>하면서 종료되었다는 상황을 가정해봅시다.</p>

<p>두 Task는 같은 <code class="language-plaintext highlighter-rouge">guard</code> 문 내에 있기 때문에 즉시 에러를 <code class="language-plaintext highlighter-rouge">throw</code>하고 함수를 종료할 수 있겠죠?</p>

<p>하지만 Task에서는 그렇지 않습니다. 정확히 말하면 <strong>“즉시”</strong> 종료하지는 않습니다.</p>

<p><code class="language-plaintext highlighter-rouge">metadata</code> Task가 실패했더라도 <code class="language-plaintext highlighter-rouge">data</code> Task는 여전히 동작중일 것입니다.</p>

<p>따라서 해당 Task가 <strong>취소되었다는 정보를 제공</strong>해주고 Task가 <strong>종료되기를 기다렸다</strong>가 모든 Task가 <strong>종료된 시점</strong>에 함수가 종료됩니다.</p>

<blockquote>
  <p>여기서 <strong>취소되었다(cancelled)</strong> 라는 것은 해당 Task를 종<strong>료시키는 것이 아니고</strong> <strong>결과가 더 이상 필요없다</strong>는 것을 알려줄 뿐입니다.</p>
</blockquote>

<p><img src="https://i.imgur.com/IrOtkbg.png" alt="" /></p>

<p>만약 취소된 Task가 <strong>Child Task</strong>를 가지고 있다면 <strong>모든 Child Task들 또한 취소</strong>됩니다.</p>

<p>이러한 Task Tree 동작은 ARC와 같이 실수로 벌어지는 <strong>Task Leak</strong>를 방지하기 위함이라고 합니다.</p>

<p>이런 Task Tree의 특성을 정리하면 다음과 같이 표현할 수 있습니다.</p>

<p><strong>Task의 취소</strong>는 <strong>협력적(cooperative)</strong> 으로 이루어집니다.</p>

<ol>
  <li>Task는 취소되더라도 즉시 종료되지 않습니다.</li>
  <li>Task의 취소 여부는 어디에서도 가능합니다. (synchronous한 코드에서도)</li>
</ol>

<p>이는 개발자가 Task가 취소되었을 때의 동작을 구현할 수 있게 하기 위함이라고 하네요.</p>

<blockquote>
  <p>이 말은 Task가 오래 걸리는 동작일수록 취소에 대응하는 코드가 꼭 필요하다라는 뜻 같습니다.</p>
</blockquote>

<p>설명만으로는 무슨 말인지 잘 모르겠으니 예시를 다시 가져와보죠!</p>

<p><img src="https://i.imgur.com/4i9k1jL.png" alt="" /></p>

<p>위와 같이 concurrent한 동작이 <strong>수행되기 전</strong>에 <code class="language-plaintext highlighter-rouge">Task.checkCancellation()</code>나 <code class="language-plaintext highlighter-rouge">if Task.isCancelled { break }</code>을 통해 불필요한 썸네일 생성의 동작을 방지하고 에러를 방출할 수 있습니다.</p>

<blockquote>
  <p>위 예시의 경우 Task가 취소되었더라도 thumbnails에는 취소되기 이전에 성공한 데이터들이 담겨있고, 그 데이터들이 그대로 반환됩니다. 빈 데이터 등의 결과는 UI에 에러를 발생시킬 수 있기 때문에 염두에 두고 작업해야합니다.</p>
</blockquote>

<p>이제 우리는 Task가 언제 취소되거나 완료되는지를 알았습니다! 😎</p>

<p>드디어 Swift가 제공하는 다양한 형태의 <strong>Task</strong>를 알아볼 때가 되었네요. 하나씩 살펴보죠!</p>

<h4 id="structured-tasks">Structured Tasks</h4>

<h5 id="async-let-tasks">async-let Tasks</h5>

<p><img src="https://i.imgur.com/hs0BOj3.png" alt="" /></p>

<p>지금까지의 <code class="language-plaintext highlighter-rouge">URLSession.data()</code> 함수는 위와 같이 사용되었습니다.</p>

<p>화살표의 방향대로 <strong>단 한가지의 흐름</strong>(단방향)만이 존재합니다.</p>

<p>하지만 우리는 <code class="language-plaintext highlighter-rouge">URLSession</code>은 시간이 걸리는 함수이기 때문에 수행 시간동안 다른 작업들이 수행되길 원합니다.</p>

<p><img src="https://i.imgur.com/dcjOSV3.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">async-let</code>을 사용하면 위처럼 흐름이 두 가지로 나뉘어집니다.</p>

<p><strong>Child Task</strong>가 생성되고, <code class="language-plaintext highlighter-rouge">URLSession.data()</code> 함수를 <strong>async하게 실행</strong>함과 동시에 <code class="language-plaintext highlighter-rouge">result</code>에는 <strong>임시 값(placeholder)</strong> 을 넘겨준채로 <strong><code class="language-plaintext highlighter-rouge">await</code> 키워드가 등장할 때까지</strong> 수행합니다.</p>

<p><code class="language-plaintext highlighter-rouge">await</code>에서 기다리던 작업은 <code class="language-plaintext highlighter-rouge">async</code> 함수가 끝이 나면 <code class="language-plaintext highlighter-rouge">result</code> 값을 <strong>대체</strong>하여 사용합니다.</p>

<p><img src="https://i.imgur.com/6AkTzcH.png" alt="" /></p>

<p>그렇다면 위 코드를 <code class="language-plaintext highlighter-rouge">async-let</code>을 사용하는 방식으로 바꾸려면 어떻게 해야할까요?</p>

<p><code class="language-plaintext highlighter-rouge">try await</code>은 <strong>child task</strong>에게 작업을 넘겨줬기 떄문에 더 이상 해당 함수를 호출하는 지점에서는 필요가 없습니다.</p>

<p><strong>Parent task</strong>에서 결과로 나온 변수를 <strong>사용</strong>할 때 필요하죠.</p>

<p>따라서 다음과 같이 바꿔줄 수 있습니다.</p>

<p><img src="https://i.imgur.com/xMhYuVI.png" alt="" /></p>

<p>각각의 <code class="language-plaintext highlighter-rouge">URLSession</code>에서 <code class="language-plaintext highlighter-rouge">try await</code>을 제거하는 대신 맨 앞에 <code class="language-plaintext highlighter-rouge">async</code>를 붙여주고,</p>

<p><strong>Parent task</strong>인 <code class="language-plaintext highlighter-rouge">fetchOneThumbnail()</code> 함수에서 <code class="language-plaintext highlighter-rouge">data</code>와 <code class="language-plaintext highlighter-rouge">metadata</code>가 필요한 순간에 <strong><code class="language-plaintext highlighter-rouge">try await</code></strong> 을 사용하고 있습니다!</p>

<h5 id="group-tasks">Group Tasks</h5>

<p><code class="language-plaintext highlighter-rouge">async-let</code>은 수행해야하는 <strong>Task의 개수가 정해져있을 때</strong> 유용합니다.</p>

<p><img src="https://i.imgur.com/OHtAIMh.png" alt="" /></p>

<p>다시 한번 위 예시의 경우를 보면, 몇 개의 썸네일을 생성하던지 간에 <code class="language-plaintext highlighter-rouge">fetchOne</code>이라는 Task는 <strong>고정적으로 두 개</strong>의 <strong>Child Task</strong>를 가지고 있습니다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">id</code>의 개수에 따라서는 수행할 <code class="language-plaintext highlighter-rouge">fetchOne()</code> 함수가 실행될 Task의 개수는 달라지겠죠?</p>

<p><strong>Task Group</strong>은 이런 경우에 유용합니다.</p>

<p><strong>Task Group</strong>은 <strong>동적 개수의 Task의 수행이 동시에 필요할 때</strong> 사용되기 위해 고안되었습니다.</p>

<p><img src="https://i.imgur.com/GpMeSw2.png" alt="" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">withThrowingTaskGroup(of:)</code></strong> 를 통해서 <strong>Task Group</strong>을 만들어줄 수 있습니다.</p>

<p>이 함수는 <strong>Child Task를 생성</strong>하는 <strong><code class="language-plaintext highlighter-rouge">group</code></strong> 이라는 인스턴스를 사용하는 Context를 제공합니다.</p>

<p>또한 for 루프의 각 루프들은 <code class="language-plaintext highlighter-rouge">group.async</code>를 통해 <strong>비동기적으로 수행</strong>되기 때문에 <strong>랜덤한 시기</strong>에 <strong>순서 상관 없이</strong> 수행될 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">group</code> 인스턴스가 루프를 전부 돌았더라도 <strong>Task Tree의 특성</strong>에 의해 <strong>모든 Task가 종료될 때까지 <code class="language-plaintext highlighter-rouge">await</code>된다</strong>는 것도 알 수 있겠죠!</p>

<p>그런데.. 모든게 평화로워 보이는 위 코드는 놀랍게도 <strong>심각한 에러</strong>를 가집니다.. 😰</p>

<p>심지어 빌드도 안되는 컴파일러 에러를 내뿜죠..</p>

<p><img src="https://i.imgur.com/OkgBhZ1.png" alt="" /></p>

<p>바로 <strong>Data Race Issue</strong>가 발생하기 때문입니다..</p>

<blockquote>
  <p><strong>Data Race Issue</strong>는 한 번에 <strong>여러 개의 Task</strong>에서 <strong>하나의 데이터</strong>에 접근할 때 발생하는 에러입니다. 하나의 변수는 <strong>한 번에 하나의 연산</strong>만 가능하지만, <strong>여러 Task에서 동시에 값을 수정</strong>하려고 하면 크러쉬가 나거나 데이터가 손상되게 됩니다..</p>
</blockquote>

<p>이 경우에는 하나의 <code class="language-plaintext highlighter-rouge">thumbnails</code> 딕셔너리에 여러 Task들이 동시에 값을 넣어주고 있죠?</p>

<p>이는 Concurrency 프로그래밍을 할 때 개발자들이 흔히 하는 실수 중에 하나입니다.</p>

<p>Data Race Issue의 해결은 개발자에게 달려있었습니다.</p>

<p>하지만 업데이트된 Swift Concurrency는 이를 컴파일러에서 미리 발견하여 에러를 발생시켜주는 것이죠! 👏 <em>(이렇게 들으니까 멋지죠?)</em></p>

<p>그래서 에러를 잡아주긴 하는데 해결은 어떻게 해야할까요?</p>

<p>Task는 사실 <code class="language-plaintext highlighter-rouge">@Sendable</code> 클로저라는 클로저에 의해 감싸져 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">@Sendable</code> 클로저의 캡처는 독특하게도 <code class="language-plaintext highlighter-rouge">mutable</code> 변수의 값을 캡처하지 못합니다.</p>

<p>그러면 어떤 값들을 캡처할 수 있는가 하면?</p>

<p><strong>값 타입</strong>(<code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">String</code>, …) 변수, <strong><code class="language-plaintext highlighter-rouge">actors</code></strong>, 고유한 <strong>synchronization을 가진 <code class="language-plaintext highlighter-rouge">class</code></strong> 를 캡처하거나 사용할 수 있습니다.</p>

<p>다시 예시로 돌아가서 에러를 고쳐볼게요..</p>

<p><img src="https://i.imgur.com/ArzVjpZ.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">thumbnails</code>에 직접적으로 값을 대입하는 대신, <code class="language-plaintext highlighter-rouge">String</code> 타입과 <code class="language-plaintext highlighter-rouge">UIImage</code> 타입의 튜플을 반환하는 방식으로 변경합니다.</p>

<p>그 후에 <code class="language-plaintext highlighter-rouge">for await</code> 루프를 통해 순차적으로 값들을 <code class="language-plaintext highlighter-rouge">thumbnails</code>에 대입해주고 있습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">AsyncSequence</code> 프로토콜</strong>을 채택한 값을 다루고 있다면 <code class="language-plaintext highlighter-rouge">for await</code> 루프를 사용해볼 것을 권장하고 있네요.</p>

<p>자.. 여기까지 알아본 <strong><code class="language-plaintext highlighter-rouge">async-let</code></strong> 과 <strong>Grouped Tasks</strong>는 <strong>Structured Task</strong>라는 각자의 hierarchy가 정돈된 Task들을 처리하는 방식이였습니다.</p>

<p>하지만 언제나 정돈된 방식을 사용할 수 있는 건 아니기 때문에 Swift는 <strong>Unstructured Tasks</strong>라는 API를 추가로 제공하고 있습니다.</p>

<h4 id="unstructured-tasks">Unstructured Tasks</h4>

<p>Hierarchy가 정돈되지 않은 Task에는 어떤 Task들이 있을까요?</p>

<p>먼저, <strong>Parent Task가 존재하지 않을</strong> 수 있습니다. <strong>async하지 않은 컨텍스트</strong>에서 <strong>async한 Task를 시작</strong>해야할 때가 이런 경우죠.</p>

<p>또 Task가 하나의 scope를 넘어 <strong>여러 scope에서 이루어지도록</strong> 할 필요가 있을 때도 있을겁니다.</p>

<p>보통 <strong><code class="language-plaintext highlighter-rouge">delegate</code> 패턴</strong>을 사용할 때 흔히 일어나는 일이라고 하네요.</p>

<p><img src="https://i.imgur.com/hP2cM4D.png" alt="" /></p>

<p>위 예시를 봅시다..</p>

<p><strong><code class="language-plaintext highlighter-rouge">delegate</code></strong> 함수인 <code class="language-plaintext highlighter-rouge">collectionView(willDisplay:, forItemAt)</code> 함수는 UI 레이어의 함수이기 때문에 async하지 않습니다.</p>

<p>하지만 데이터를 받아오는 <code class="language-plaintext highlighter-rouge">fetchThumbnails()</code> 함수는 async 함수이죠.</p>

<p>이럴 때가 바로 <strong>Unstructured Task</strong>를 사용할 때입니다.</p>

<p><img src="https://i.imgur.com/kHwb1FR.png" alt="" /></p>

<p>간단하게 async 처리가 필요한 곳은 <code class="language-plaintext highlighter-rouge">Task</code>로 감싸줍니다.</p>

<p>런타임동안 이 <strong>Task를 생성하는 부분</strong>을 마주치게 되면, <strong>수행하는 scope와 같은 actor</strong>에서 실행되도록 예약을 해둡니다.</p>

<p>예시의 경우에는 <strong>MainActor</strong>에서 실행이 될 겁니다.</p>

<p>이렇게 사용하기 간편하다면 단점도 당연히 있겠죠?</p>

<p>Task의 생명주기가 scope에 종속되지 않고 synchronous한 코드 중간에서도 호출이 될 수 있기 때문에 Structured Task에서 자동으로 수행될 수 있었던 <strong>취소</strong>와 <strong>await</strong>를 개발자가 직접 해줘야 합니다.</p>

<p><img src="https://i.imgur.com/uld4DAv.png" alt="" /></p>

<p>이 경우, Task를 생성한 뒤에 <code class="language-plaintext highlighter-rouge">thumbnailTasks</code>라는 딕셔너리에 저장하였습니다.</p>

<p>그러면 나중에도 언제든지 접근해서 작업을 취소할 수 있겠죠?</p>

<p><code class="language-plaintext highlighter-rouge">defer</code>문을 사용해 <strong>Task가 끝난 시점에 저장된 Task를 해제</strong>함으로써 이미 <strong>완료된 Task를 취소하는 일도 방지</strong>해둔 것을 볼 수 있네요.</p>

<p>🙋 어라 그런데.. 같은 데이터에 여러 Task가 동시에 접근하면 안된다고 하지 않았나요?</p>

<p>맞습니다.. 하지만 이 경우에는 <strong><code class="language-plaintext highlighter-rouge">@MainActor</code></strong>, 즉 메인쓰레드에서 이루어지기 때문에 절대로 동시에 일어날 일이 없습니다.</p>

<p>셀이 화면에서 벗어나면 작업을 취소해도 되겠죠.</p>

<p><img src="https://i.imgur.com/bDfgWq7.png" alt="" /></p>

<p>다음과 같이 <strong><code class="language-plaintext highlighter-rouge">task.cancel()</code></strong> 로 Task를 취소해줄 수 있습니다.</p>

<h4 id="detached-tasks">Detached Tasks</h4>

<p>어라 뭐가 하나 또 있죠…?</p>

<p>Unstructured Tasks는 어떤 스코프에서도 수행될 수 있는 Task였습니다. 하지만 어떤 컨텍스트에서 시작되었는지는 중요한 요소였습니다.</p>

<p>해당 scope의 변수도 사용해야 하고,</p>

<p><strong>Detached Tasks</strong>는 그 어떤 것도 <strong>상관이 없을 떄</strong> 사용하는 Task입니다.</p>

<p>Detached Tasks는 <strong>컨텍스트로부터 독립적</strong>입니다.</p>

<p>시작된 scope에서 <strong>아무 값도 가져오지 않습니다</strong>.</p>

<p>심지어 같은 actor에서 실행되도록 되어있지도 않아서 <strong>같은 우선순위를 갖지도 않습니다</strong>.</p>

<p><img src="https://i.imgur.com/HnQ4DHp.png" alt="" /></p>

<p>위 예시는 썸네일을 생성한 후에 로컬 디스크에 캐싱을 하는 작업을 Detached Task에서 작업하도록 하는 코드입니다.</p>

<p>캐싱은 <code class="language-plaintext highlighter-rouge">@MainActor</code>에서 처리될 필요가 전혀 없죠.</p>

<p>높은 우선순위를 가질 필요도 없습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">Task.detached(priority:)</code></strong> 를 통해서 간단하게 <strong>컨텍스트에서 독립</strong>된 <strong>Detached Task</strong>를 만들어줄 수 있습니다.</p>

<p><img src="https://i.imgur.com/4nmJx28.png" alt="" /></p>

<p>Detached Task에 <strong>Task Group</strong>을 사용해서 <strong>hierarchy</strong>를 만들어줄 수도 있습니다.</p>

<p>여러가지 백그라운드 작업이 필요하지만 연결된 작업이 필요할 때 아주 유용하겠죠!</p>

<h3 id="정리">정리</h3>

<p><img src="https://i.imgur.com/vnsVMkB.png" alt="" /></p>

<h2 id="actor">Actor</h2>

<p>끝난 줄 알았죠..?</p>

<p>하지만 아직 많이 남았습니다. 🤯</p>

<p>위에서 <strong>Actor</strong>라는 키워드가 사용되었었죠..?</p>

<p>이게 뭔지도 알아봐야죠..</p>

<p>Actor가 뭔지 알아보려면 마찬가지로 이미 한 번 살펴본 <strong>Data Race Issue</strong>와 관련되어 있다는 것을 알고 시작해야합니다.</p>

<p><strong>Data Race</strong>는 <strong>여러 개의 Task</strong>에서 <strong>동시에 하나의 <code class="language-plaintext highlighter-rouge">mutable</code> 값에 접근</strong>하려고 하면 발생하는 문제였습니다.</p>

<p>그렇다면 문제를 어떻게 해결할까요?</p>

<p><strong>변하지 않는 데이터</strong>를 사용하거나 <strong>여러 Task에 걸쳐 사용되지 않도록</strong> 하면 해결되겠죠?</p>

<p><img src="https://i.imgur.com/PiEJOBA.png" alt="" /></p>

<p>그러면 이렇게 하면 되겠네요!</p>

<p><code class="language-plaintext highlighter-rouge">let</code>으로 값이 고정된 값을 각 Task에서 <strong><code class="language-plaintext highlighter-rouge">mutable</code>한 값으로 복사</strong>한 뒤 작업을 해주면 되겠죠.</p>

<p>아뇨 안됐습니다. 🙅‍♂️</p>

<p>에러는 발생하지 않지만 Task마다 복사된 값은 서로의 값에 영향을 주지 못하거든요.</p>

<p>그러면 이렇게 정리할 수 있습니다: <strong>각 Task들이 공유할 수 있는 <code class="language-plaintext highlighter-rouge">mutable</code> Task가 필요하다!</strong></p>

<p>Swift는 이미 그런 feature들을 갖고 있습니다.</p>

<p>이런 문제는 오래된 문제거든요..</p>

<p><code class="language-plaintext highlighter-rouge">mutable</code> state를 동기화하는 작업은 로우레벨 단계에서 사용할 수 있는 <strong>Atomics</strong>, <strong>Locks</strong>, 더 높은 레벨에서 사용할 수 있는 <strong>Serial DIspatch Queues</strong>가 있습니다.</p>

<p>이들은 모두 같은 역할을 하고 같은 문제를 갖고 있습니다.</p>

<p>Shared mutable state에 Data Race 없이 접근할 수 있지만, 사용법이 조금이라도 어긋나면 바로 앱이 크러쉬된다는 것이죠.</p>

<p><strong>Actors</strong>는 이런 문제를 해결하고 shared mutable state의 동기화를 좀 더 쉽게 이룰 수 있도록 등장했습니다.</p>

<p><strong>Actors</strong>는 state를 <strong>다른 모든 프로그램에서 분리</strong>하여 관리합니다.</p>

<p>그리고 해당 state에 접근하려면 무조건 <strong>actor 내부</strong>에 들어가야만 하죠.</p>

<p><strong>Actor</strong>는 조금 특이하게 사용됩니다.</p>

<p>새로운 타입이거든요</p>

<p><img src="https://i.imgur.com/4uqjN9J.png" alt="" /></p>

<p>마치 <code class="language-plaintext highlighter-rouge">struct</code>, <code class="language-plaintext highlighter-rouge">enum</code>, <code class="language-plaintext highlighter-rouge">class</code>와 같이 <strong>프로퍼티</strong>, <strong>메서드</strong>, <strong>생성자</strong> 등을 가집니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">protocol</code></strong> 과 <strong><code class="language-plaintext highlighter-rouge">extension</code></strong> 또한 사용할 수 있습니다.</p>

<p>또, actor는 shared mutable state에 접근하기 위해 만들어진 만큼 <code class="language-plaintext highlighter-rouge">class</code>와 같은 <strong>참조 타입</strong>입니다.</p>

<p>사용법은 <code class="language-plaintext highlighter-rouge">class</code>와 동일합니다.</p>

<p>한 가지 주의할 점이 있다면 <code class="language-plaintext highlighter-rouge">class</code>와는 다르게 <strong>상속</strong>을 지원하지는 않습니다!</p>

<p>그리고 가장 중요한 점은 actor에서 정의된 값들은 <strong>동시에 접근되지 않도록 보장</strong>되어 있다~라는 점입니다.</p>

<p><img src="https://i.imgur.com/uZlj9lu.png" alt="" /></p>

<p>위의 예시에 적용해보면 이렇게 됩니다.</p>

<p>같은 값에 접근하지만, 절대 동시에 접근할 수는 없기 때문에 순서대로 2, 1이나 1, 2가 출력될겁니다.</p>

<p>하지만 suspend된 작업이 actor 안에서 얌전히 차례를 기다릴 것이라는 보장은 되는 걸까요?</p>

<p>우리는 이미 그런 역할을 하는 키워드를 알고 있습니다.</p>

<p><img src="https://i.imgur.com/Xpv0i3w.png" alt="" /></p>

<p>actor의 외부에서는 <strong><code class="language-plaintext highlighter-rouge">await</code></strong> 키워드를 통해 해당 작업이 <strong>suspendable</strong>하다는 것을 명시해줄 수 있습니다.</p>

<p>하지만 actor의 내부에서는 이와 같은 키워드는 필요가 없죠.</p>

<p>모든 코드가 <strong>synchronous하게 실행</strong>되기 때문에 동시성 프로그래밍의 문제를 신경쓰지 않고 작업할 수 있습니다.</p>

<h3 id="actor-reentrancy">Actor Reentrancy</h3>

<p><img src="https://i.imgur.com/KBfgXuf.png" alt="" /></p>

<p>위 코드는 이미지를 캐싱하는 작업을 수행하는 <strong>actor</strong>입니다.</p>

<p>문제는 <code class="language-plaintext highlighter-rouge">await</code>에서 발생합니다.</p>

<p>이미지를 다운로드하는 과정은 시간이 오래 소요되는 작업이니 <code class="language-plaintext highlighter-rouge">await</code>을 사용하는 것은 올바른 접근입니다.</p>

<p><img src="https://i.imgur.com/twvj2ww.png" alt="" /></p>

<p>하지만 동시에 두 군데에서 <strong>같은 url의 이미지</strong>를 받아오길 원하고, 하나의 작업이 수행되는 동안 <strong>서버의 이미지가 교체</strong>되는 상황이 있다면 어떻게 될까요?</p>

<p>두 작업은 동시에 요청됐음에도 불구하고 <strong>다른 이미지</strong>를 받아오게 될겁니다.</p>

<p><img src="https://i.imgur.com/hZhXsLf.png" alt="" /></p>

<p>이 경우에는, 이미 url에 해당하는 이미지가 있다면 그 이미지를 불러와 사용하고, 없다면 새로운 이미지를 넣는 것으로 해결하였습니다.</p>

<p>이와 같이 actor 내부에서 <code class="language-plaintext highlighter-rouge">await</code>을 사용하는 것은 숨겨진 버그를 유발할 수 있기 때문에 주의가 필요합니다.</p>

<p>이런 과정을 actor에 재진입하여 작업을 수행한다고 해서 <strong>Actor Reentrancy</strong>라고 부릅니다.</p>

<p>다음 세 가지를 항상 생각해가며 코드를 짜봅시다.</p>

<ol>
  <li>되도록 synchronous하게 데이터를 mutate 시킨다.</li>
  <li><code class="language-plaintext highlighter-rouge">await</code>에서 suspend된 동안 state가 바뀔 수 있음을 생각한다.</li>
  <li><code class="language-plaintext highlighter-rouge">await</code> 후에 조건문 등을 통해 state가 예상범위 안인지 체크한다.</li>
</ol>

<h3 id="actor-isolation">Actor Isolation</h3>

<p>Actor는 다른 프로그램들과 <strong>독립적</strong>으로 있는 존재라고 했었죠?</p>

<p>따라서 외부에서 actor에 접근할 떄는 이런 독립성을 해치면서 접근할 수는 없습니다.</p>

<blockquote>
  <p>여기서부터 조금 아득해집니다.. 주의하세요… 🫠</p>
</blockquote>

<h4 id="protocol">Protocol</h4>

<p><img src="https://i.imgur.com/UfZjadS.png" alt="" /></p>

<p>이 경우 <code class="language-plaintext highlighter-rouge">Equatable</code> 메서드는 <strong><code class="language-plaintext highlighter-rouge">static</code></strong> 이고 파라미터로 받는 두 actor 타입 값의 외부에 있으니까 가능한 문법입니다.</p>

<p><img src="https://i.imgur.com/GhUS1Y5.png" alt="" /></p>

<p>반면 이 경우에는 허용되지 않습니다.</p>

<p><code class="language-plaintext highlighter-rouge">hash(into:)</code> 함수는 <strong>actor 내부</strong>에 들어가 <strong>값을 변경</strong>하고, <strong>async하지도 않기 때문</strong>입니다.</p>

<p>하지만 이상한 점이 있습니다. 😕</p>

<p>actor 내부에 들어가는 것은 맞지만, 실제로 actor가 갖고있는 값을 변경하는 것은 아니거든요..</p>

<p><img src="https://i.imgur.com/9WaS0jv.png" alt="" /></p>

<p>그런 경우에는 <code class="language-plaintext highlighter-rouge">nonisolated</code> 키워드를 붙여 해결할 수 있습니다.</p>

<p>하지만 끝이 아닙니다..</p>

<p>이 경우에는 사용하는 actor의 프로퍼티 <code class="language-plaintext highlighter-rouge">idNumber</code>가 <strong>immutable</strong>한 값이거든요.</p>

<p>하지만 mutable한 값을 사용하려고 하면…?</p>

<p><img src="https://i.imgur.com/YfVeSeO.png" alt="" /></p>

<p>어김없이 에러가 발생합니다.</p>

<p><strong>외부에서 mutable한 값에 접근</strong>하는 것은 <strong>Data Race</strong>를 유발할 수 있거든요.</p>

<h4 id="closure">Closure</h4>

<p>이번에는 클로저 안에서 실행되는 함수의 경우를 살펴봅시다.</p>

<p><img src="https://i.imgur.com/yqAMbvI.png" alt="" /></p>

<p>위 예시는 아무 문제가 없습니다.</p>

<p>독립된 공간에 있는 <code class="language-plaintext highlighter-rouge">read()</code> 함수 안에 있는 (마찬가지로 독립된 공간에 있는)<code class="language-plaintext highlighter-rouge">readSome()</code> 함수가 <strong>synchronous</strong>하기 때문에 <strong>순차적으로 실행</strong>되기 때문이죠!</p>

<p><img src="https://i.imgur.com/joyF9HO.png" alt="" /></p>

<p>그렇다면 이 경우는 어떨까요..</p>

<p><strong>Detached Task</strong>에 <code class="language-plaintext highlighter-rouge">read()</code> 함수가 있기 때문에 이 경우에는 클로저 안의 작업들이 <strong>독립된 공간에 있지 않고 밖으로</strong> 나가게 됩니다.</p>

<p>때문에 해당 클로저는 actor에 있지 않고, <strong><code class="language-plaintext highlighter-rouge">await</code></strong> 키워드를 붙여 <strong>비동기적</strong>으로 처리되어야 합니다.</p>

<p><img src="https://i.imgur.com/ka2pSN8.png" alt="" /></p>

<p>자 이 경우를 봅시다..</p>

<p><code class="language-plaintext highlighter-rouge">Book</code>이라는 인스턴스는 <code class="language-plaintext highlighter-rouge">class</code> 타입입니다. 참조 타입이니까 actor 안에 있지 못하고 <strong>외부</strong>에 위치해있죠.</p>

<p>actor 안에 참조 타입의 값이 있는 것 자체는 아무 문제가 없습니다.</p>

<p>문제는 해당 값에 <strong>접근</strong>을 할 때 발생하겠죠? (Data Race)</p>

<p>여기서 익숙한 키워드가 등장합니다.</p>

<ul>
  <li><strong>Sendable</strong></li>
</ul>

<p><strong>Sendable</strong> 타입은 다른 여러 actor들 사이에서 함께 사용될 수 있는 타입입니다.</p>

<p>어떤 값을 각자의 actor로 복사하고, 복<strong>사된 값을 독립적으로 처리</strong>할 수 있다면 해당 값은 <strong>Sendable</strong>하다고 할 수 있습니다.</p>

<p><strong>값 타입</strong>과 <strong>Actor 타입</strong>은 기본적으로 <strong>Sendable</strong>합니다.</p>

<p>하지만 <strong>클래스(참조 타입)</strong>의 경우에는 고려해야할 사항이 있죠..</p>

<ol>
  <li>클래스에 있는 <strong>모든 값들이 immutable(<code class="language-plaintext highlighter-rouge">let</code>)</strong>한 경우</li>
  <li>클래스 <strong>내부적으로 동기화(<code class="language-plaintext highlighter-rouge">lock</code>)를 구현</strong>한 경우</li>
</ol>

<p>하지만 대부분의 클래스는 그렇지 않기 때문에 Sendable이 아니라고 할 수 있습니다.</p>

<p>함수는 기본적으로는 Sendable하지 않지만 <strong><code class="language-plaintext highlighter-rouge">@Sendable</code> 함수</strong>와 같은 새로운 타입의 함수를 사용하면 Sendable합니다.</p>

<p><img src="https://i.imgur.com/lQtLpWi.png" alt="" /></p>

<p>Sendable은.. 예상하셨겠지만 사실 <strong>프로토콜</strong>입니다.</p>

<p>Swift에서 concurrent한 작업을 하기 위해서는 <strong>Sendable 프로토콜을 준수한 값</strong>들을 사용해야하는 것이죠..!</p>

<p>자.. 다시 클로저로 돌아가봅시다.</p>

<p><strong>클로저</strong>가 <strong>Sendable</strong>하려면 어떤 경우여야 할까요?</p>

<p>간단합니다. 클로저가 <strong>캡처하는 모든 값들이 Sendable</strong>해야하죠.</p>

<p>또 캡처한 값들이 <strong>mutable(<code class="language-plaintext highlighter-rouge">var</code>)</strong>하면 안됩니다.</p>

<p>그러면 Data Race가 발생할테니까요..</p>

<p>마지막으로 클로저가 <strong>synchronous</strong>한 경우에 actor에서 <strong>독립된 형태이면 안됩니다</strong>.</p>

<p>외부에서 접근이 가능해지니까요!</p>

<h3 id="main-actor">Main Actor</h3>

<p>마지막으로 살펴볼 게 있습니다.</p>

<p><strong>Main Actor</strong>라는 특수한 actor인데요, 이미 전에 한 번 언급된 적이 있었죠?</p>

<p>백그라운드에서 작업을 하다가 다시 메인쓰레드로 넘어와 UI를 업데이트해야 하는 상황..</p>

<p>아주 익숙하죠?</p>

<pre><code class="language-Swift">DispatchQueue.main.async {
  updateButton()
}
</code></pre>

<p>보통 위와 같이 <strong><code class="language-plaintext highlighter-rouge">DispatchQueue.main</code></strong>을 사용해오곤 했습니다.</p>

<p><img src="https://i.imgur.com/CcWieeY.png" alt="" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">@MainActor</code></strong>는 해당 작업이 <strong>메인쓰레드</strong>에서 이루어져야 한다는 것을 명시하는 키워드입니다.</p>

<p><code class="language-plaintext highlighter-rouge">DispatchQueue.main</code> 대신 사용하여 명시적으로 메인쓰레드에서 동작해야한다는 것을 컴파일러에게 알려줍시다..!</p>

<blockquote>
  <p>참고 문서</p>
</blockquote>

<p><a href="https://developer.apple.com/videos/play/wwdc2021/10254/">WWDC21 - Swift concurrency: Behind the Scenes</a></p>

<p><a href="https://developer.apple.com/videos/play/wwdc2021/10134/">WWDC21 - Explore structured concurrency in Swift</a></p>

<p><a href="https://developer.apple.com/videos/play/wwdc2021/10133/">WWDC21 - Protect mutable state with Swift actors</a></p>

<p><a href="https://sujinnaljin.medium.com/swift-async-await-concurrency-bd7bcf34e26f">naljin - Swift async / await &amp; concurrency</a></p>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><summary type="html"><![CDATA[Concurrency]]></summary></entry><entry><title type="html">25)🍎 Swift - Package</title><link href="/jekyll-theme-yat/swift/2023/03/10/Swift25.html" rel="alternate" type="text/html" title="25)🍎 Swift - Package" /><published>2023-03-10T00:00:00+00:00</published><updated>2023-03-10T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/03/10/Swift25</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/03/10/Swift25.html"><![CDATA[<h1 id="package-패키지">Package (패키지)</h1>

<p><img src="https://i.imgur.com/wiNIbnk.png" alt="" /></p>

<p>패키지란 프로젝트 내에서 사용하는 코드/리소스들을 재사용하기 쉽도록 묶어 정돈하거나 다른 개발자나 커뮤니티와 공유하기 위한 기능입니다.</p>

<p>Xcode는 이런 패키지 기능을 Swift Package Manager를 통해 쉽고 간편하게 사용할 수 있도록 지원하고 있습니다.</p>

<p>네 맞아요..</p>

<p>저희가 맨날 쓰던 그거요..</p>

<p>그러면 멋있고 화려한 RxSwift와 같은 라이브러리를 만들기 위해 시작해보죠?</p>

<h2 id="swift-package-만들기">Swift Package 만들기</h2>

<p><img src="https://docs-assets.developer.apple.com/published/ce439cc5d6ba4621ef3eb70fe9168526/creating-a-swift-package-with-xcode-1@2x.png" alt="Flowchart showing the development lifecycle for a Swift package." /></p>

<blockquote>
  <p>전반적인 패키지 생성 과정</p>
</blockquote>

<p><img src="https://i.imgur.com/adw5bti.png" alt="" /></p>

<p>패키지 만들기 정말 쉽습니다.</p>

<p>Xcode의 메뉴에서 <code class="language-plaintext highlighter-rouge">File ➡️ New ➡️ Package</code> 를 눌러줍시다.</p>

<p><img src="https://i.imgur.com/fxGMBSw.png" alt="" /></p>

<p>그러면 이렇게 프로젝트나 파일을 만드는 것과 같이 패키지를 생성하는 창이 보입니다.</p>

<p>저는 Favor 프로젝트에 패키지를 적용하기 위해 Add to와  Group도 설정해주었습니다.</p>

<p>그러면 비어있는 패키지 만들기 끝입니다.</p>

<p><img src="https://i.imgur.com/ZcS8ZSl.png" alt="" /></p>

<p>패키지를 생성하면 이런 구조의 파일들이 프로젝트에 추가됩니다. 각각을 한 번 알아볼까요?</p>

<ul>
  <li>README.md</li>
</ul>

<p>뭐 설명할 것도 없죠. 패키지에 대한 설명을 넣어주면 됩니다.</p>

<ul>
  <li>Package.swift</li>
</ul>

<p>흔히들 manifest라고 부르는 패키지에 대한 정보가 담긴 파일입니다. 이 파일 안에서 패키지의 name, products, targets, dependencies들을 설정해주게 됩니다.</p>

<ul>
  <li>Sources</li>
</ul>

<p>소스 파일들은 이 Sources 디렉토리 내부에 위치합니다. 그리고 Target이라는 하나의 이름 안에 관리됩니다.</p>

<ul>
  <li>Tests</li>
</ul>

<p>패키지에 대한 Unit Test 코드들이 여기에 해당됩니다.</p>

<h2 id="packageswift-작성">Package.swift 작성</h2>

<p>Favor 프로젝트는 세가지 패키지를 만들어 사용하기로 했습니다.</p>

<ul>
  <li>FavorCoreKit</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Foundation</code>의 <code class="language-plaintext highlighter-rouge">extension</code>들, OS와 밀접하게 닿아있는 기능들 (<code class="language-plaintext highlighter-rouge">PhotosUI</code>, <code class="language-plaintext highlighter-rouge">CoreGraphics</code> 등)을 담아둡니다.
보통 <code class="language-plaintext highlighter-rouge">BaseViewController</code>와 같은 <code class="language-plaintext highlighter-rouge">Base</code> 파일들도 여기에 담긴다고 하는데 아직 저희 프로젝트는 이런 파일들이 많지 않아서 (<code class="language-plaintext highlighter-rouge">BaseVC</code> 하나) 추가적인 회의를 통해 결정하기로  했습니다.</p>

<ul>
  <li>FavorUIKit</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">UIKit</code>의 <code class="language-plaintext highlighter-rouge">extension</code>들과 커스텀 UI 컴포넌트들, 폰트와 아이콘 같은 Resources들과 UI에 사용되는 상수 파일들이 포합됩니다.</p>

<ul>
  <li>FavorNetworkKit</li>
</ul>

<p>HTTP 통신과 같은 네트워크 작업에 필요한 파일들이 모두 포함됩니다. 저희 프로젝트는 <code class="language-plaintext highlighter-rouge">Moya</code>를 사용하기 때문에 <code class="language-plaintext highlighter-rouge">BaseTargetType</code>과 <code class="language-plaintext highlighter-rouge">API</code> 파일들을 여기에 넣어주었습니다.</p>

<p>이 중에서 FavorUIKit을 한 번 살펴보겠습니다.</p>

<pre><code class="language-Swift">// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
  name: "FavorUIKit",
  platforms: [
    .iOS(.v15)
  ],
  products: [
    // Products define the executables and libraries a package produces, and make them visible to other packages.
    .library(
      name: "FavorUIKit",
      targets: ["FavorUIKit"]),
  ],
  dependencies: [
    // Dependencies declare other packages that this package depends on.
    // .package(url: /* package url */, from: "1.0.0"),
    .package(url: "https://github.com/ReactiveX/RxSwift.git", .upToNextMajor(from: "6.5.0")),
    .package(url: "https://github.com/SnapKit/SnapKit.git", .upToNextMajor(from: "5.6.0")),
    .package(path: "../FavorCoreKit")
  ],
  targets: [
    // Targets are the basic building blocks of a package. A target can define a module or a test suite.
    // Targets can depend on other targets in this package, and on products in packages this package depends on.
    .target(
      name: "FavorUIKit",
      dependencies: [
        "RxSwift",
        .product(name: "RxCocoa", package: "RxSwift"),
        "SnapKit",
        "FavorCoreKit"
      ],
      resources: [
        .process("Resources")
      ]
    ),
    .testTarget(
      name: "FavorUIKitTests",
      dependencies: ["FavorUIKit"]),
  ]
)
</code></pre>

<h4 id="name">name</h4>
<p><code class="language-plaintext highlighter-rouge">name</code>은 말 그대로 패키지의 이름입니다.</p>

<h4 id="platforms">platforms</h4>
<p><code class="language-plaintext highlighter-rouge">platforms</code>는 패키지가 사용될 수 있는 플랫폼을 명시해둡니다. <code class="language-plaintext highlighter-rouge">.iOS</code>, <code class="language-plaintext highlighter-rouge">.macOS</code>와 같은 플랫폼 <code class="language-plaintext highlighter-rouge">case</code>와 <code class="language-plaintext highlighter-rouge">.v15</code>와 같은 버전 <code class="language-plaintext highlighter-rouge">case</code>를 넣어 적용할 수 있습니다.</p>

<h4 id="products">products</h4>
<p><code class="language-plaintext highlighter-rouge">products</code>는 패키지가 제공하는 프로덕츠들을 명시하는 곳입니다. <code class="language-plaintext highlighter-rouge">.library</code> 외에도 <code class="language-plaintext highlighter-rouge">.executable</code>, <code class="language-plaintext highlighter-rouge">.plugin</code>과 같은 <code class="language-plaintext highlighter-rouge">case</code>도 있습니다.</p>

<p>하나의 라이브러리에 여러개의 targets를 만들 수도 있습니다. 대표적으로 RxSwift의 경우 RxSwift 하나의 라이브러리에 RxRelay, RxCocoa 등의 여러 타겟들을 제공하고 있죠.</p>

<h4 id="dependencies">dependencies</h4>

<p>패키지가 사용하는 다른 패키지들을 명시합니다. 여기에 적힐 내용은 보통 라이브러리 리드미 파일에 적어두는 경우가 많으니 참고하여 적어주면 됩니다.</p>

<p>깃허브에 올라와있는 패키지의 경우 <code class="language-plaintext highlighter-rouge">.package(url:)</code>을 사용해주면 되고, 로컬 패키지의 경우 <code class="language-plaintext highlighter-rouge">.package(path:)</code>를 사용해줍니다.</p>

<p>뒤에 붙는 버전의 경우</p>

<ul>
  <li>from</li>
</ul>

<p>해당 버전 이상부터 사용합니다.</p>

<ul>
  <li>uptoNextMajor</li>
</ul>

<p>메이저 버전이 바뀌기 전까지 업데이트하며 사용합니다.
<code class="language-plaintext highlighter-rouge">ex) 5.0.0 ~ 6.0.0</code></p>

<ul>
  <li>uptoNextMinor</li>
</ul>

<p>마이너 버전이 바뀌기 전까지 업데이트하며 사용합니다.
<code class="language-plaintext highlighter-rouge">ex) 5.0.0 ~ 5.1.0</code></p>

<ul>
  <li>exact
해당 버전으로 고정하여 사용합니다.</li>
</ul>

<h4 id="targets">targets</h4>

<p>패키지에 사용된 타겟들을 각각 명시합니다.</p>

<p><code class="language-plaintext highlighter-rouge">dependencies</code>에는 보통 위의 dependencies에 적힌 패키지들이 적히고, 하나의 패키지에 타겟이 여러개인 경우 <code class="language-plaintext highlighter-rouge">.product(name: "RxCocoa", package: "RxSwift")</code>와 같이 각각 적어줍니다.</p>

<p><code class="language-plaintext highlighter-rouge">resources</code>에는 타겟에서 사용되는 리소스 파일들을  명시합니다.</p>

<p><img src="http://tech.kakao.com/wp-content/uploads/2022/05/11_swiftpm.png" alt="" /></p>

<p>단 <code class="language-plaintext highlighter-rouge">.xcassets</code>, <code class="language-plaintext highlighter-rouge">.storyboard</code>, <code class="language-plaintext highlighter-rouge">.xib</code>, <code class="language-plaintext highlighter-rouge">.nib</code> 파일등과 같은 리소스 파일들은 Xcode가 그 사용처가 분명하다고 판단하여 자동으로 패키징이 이루어집니다.</p>

<p><img src="http://tech.kakao.com/wp-content/uploads/2022/05/12_swiftpm.png" alt="" /></p>

<p>하지만 저희 프로젝트의 경우 폰트와 같은 자동으로 패키징되지 않는 타입의 리소스가 있기 떄문에 <code class="language-plaintext highlighter-rouge">.process("Resources")</code>와 같이 명시해주었습니다.</p>

<p>리소스 명시는 두가지 방법을 지원합니다.</p>

<ul>
  <li>process</li>
</ul>

<p>해당 디렉토리에 있는 모든 리소스를 하나의 depth로 평준화합니다.</p>

<p>플랫폼에 따라 Xcode가 최적화를 진행할 수 있다면 최적화를 진행해서 리소스 번들의 최상위 디렉토리에 복사합니다.</p>

<ul>
  <li>copy</li>
</ul>

<p>디렉토리 구조 그대로 복사하여 사용합니다.</p>

<p>디렉토리 구조를 굳이 유지해야하는게 아니라면 최적화도 진행되는 <code class="language-plaintext highlighter-rouge">process</code>가 사용된다고 합니다.</p>

<h2 id="접근제어자">접근제어자</h2>

<p>패키지화를 한 이상 접근제어자에 더욱 신경을 써주어야 합니다.</p>

<p>Swift에는 다섯가지 접근 제어자가 있습니다.</p>

<h4 id="open-public">open, public</h4>

<p>프로젝트 내의 모든 곳에서 접근할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">open</code>과 <code class="language-plaintext highlighter-rouge">public</code>의 차이가 패키징을 사용하면서 중요해집니다.</p>

<p><code class="language-plaintext highlighter-rouge">open</code>을 사용하면 다른 모듈에서 <code class="language-plaintext highlighter-rouge">overclass</code>를 허용합니다. 하지만 <code class="language-plaintext highlighter-rouge">public</code>은 이를 허용하지 않습니다.</p>

<p>따라서 <code class="language-plaintext highlighter-rouge">BaseViewController</code>와 같이 상속이 필요한 클래스의 경우 <code class="language-plaintext highlighter-rouge">open</code>으로 접근을 열어주어야 합니다.</p>

<h4 id="internal">internal</h4>

<p>아무 접근제어자도 작성하지 않으면 기본적으로 적용되는 접근제어자입니다. 작성된 모듈 안에서만 접근 가능합니다.</p>

<h4 id="fileprivate">fileprivate</h4>

<p>작성된 소스 파일 내부에서만 접근 가능합니다.</p>

<h4 id="private">private</h4>

<p>가장 제한적인 접근제어자입니다. 작성된 객체 내부에서만 접근 가능합니다.</p>

<h2 id="패키지-적용하기">패키지 적용하기</h2>

<p><img src="https://i.imgur.com/LYKKSNC.png" alt="" /></p>

<p>프로젝트의 앱 타겟에서 라이브러리 추가를 눌러줍니다.</p>

<p><img src="https://i.imgur.com/gLI60WK.png" alt="" /></p>

<p>Workspace 내부에 만들어두었기 때문에 패키지를 바로 선택할 수 있습니다.</p>

<p><img src="https://i.imgur.com/CBHCtA8.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">import</code>까지 해보면서 정상적으로 추가되었는지 확인해봅시다!</p>

<blockquote>
  <p>참고 문서</p>
</blockquote>

<p><a href="https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode">Apple - Creating a standalone Swift package with Xcode</a></p>

<p><a href="https://developer.apple.com/documentation/xcode/bundling-resources-with-a-swift-package">Apple - Bundling resources with a Swift package</a></p>

<p><a href="https://tech.kakao.com/2022/06/02/swift-package-manager/">KakaoTech - Swift Package Manager 적용기</a></p>

<p><a href="https://zeddios.tistory.com/1259">ZeddiOS - Copy와 Process의 차이점</a></p>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><category term="Favor" /><summary type="html"><![CDATA[Package (패키지)]]></summary></entry><entry><title type="html">24)🍎 Swift - Moya</title><link href="/jekyll-theme-yat/swift/2023/02/26/Swift24.html" rel="alternate" type="text/html" title="24)🍎 Swift - Moya" /><published>2023-02-26T00:00:00+00:00</published><updated>2023-02-26T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/02/26/Swift24</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/02/26/Swift24.html"><![CDATA[<h1 id="moya">Moya</h1>

<blockquote>
  <p>모야가 대체 모야?</p>
</blockquote>

<p>(아마 한국인이 작성한 모야 게시물 80%는 이걸로 시작할듯…)</p>

<p>그래서 모야는 뭘까요?</p>

<p>Moya는 <code class="language-plaintext highlighter-rouge">enum</code> 타입을 적극적으로 활용하여 네트워크 요청 레이어를 <code class="language-plaintext highlighter-rouge">type-safe</code>하게 래핑한 네트워킹 라이브러리입니다.</p>

<p>컴파일 타임에 엔드포인트 접근 관련 에러를 띄워주기 때문에 더욱 안전하고 간편하게 앱을 빌드할 수 있다는 장점이 있다고 해요!</p>

<h2 id="alamofire와의-관계">Alamofire와의 관계?</h2>

<p>Swift 언어를 처음 학습할 때 <code class="language-plaintext highlighter-rouge">URLSession</code>을 공부한 뒤에 네트워크 관련된 유용한 라이브러리가 많다는 사실을 알고 어떤 것이 있나 살펴보던 때가 있었습니다.</p>

<p>모두가 알고 있는 <code class="language-plaintext highlighter-rouge">Alamofire</code>, <code class="language-plaintext highlighter-rouge">Kingfisher</code>, <code class="language-plaintext highlighter-rouge">Moya</code> 등이 있었죠..</p>

<p>그 중에서 <code class="language-plaintext highlighter-rouge">Kingfisher</code>는 이미지 관련 라이브러리니 남는 건 <code class="language-plaintext highlighter-rouge">Alamofire</code>와 <code class="language-plaintext highlighter-rouge">Moya</code>였습니다.</p>

<p>아무것도 모르던 저는 <code class="language-plaintext highlighter-rouge">Moya</code>의 귀여운 이름에 끌려 무작정 공부를 시작했더랩죠..</p>

<p>무슨 말인지 하나도 이해하지 못하고 <code class="language-plaintext highlighter-rouge">Alamofire</code>로 후퇴했었는데요.. 당연한거였습니다.</p>

<p><code class="language-plaintext highlighter-rouge">Moya</code>의 네트워킹은 사실 <code class="language-plaintext highlighter-rouge">Alamofire</code>이기 때문이죠…!</p>

<p><img src="https://i.imgur.com/nbxtcTj.png" alt="" /></p>

<p>Dependency에 떡하니 박혀있는게 보이시죠..</p>

<p><img src="https://i.imgur.com/sjBahL4.png" alt="" /></p>

<p>사실 깃허브 설명란의 이미지에도 <code class="language-plaintext highlighter-rouge">Alamofire</code>가 하나의 계층을 떡하니 잡고 있는 걸 볼 수 있습니다..</p>

<h2 id="개념">개념</h2>

<p>모야를 이해하려면 세 가지 핵심 요소를 먼저 알아야합니다.</p>

<h3 id="provider">Provider</h3>

<p><code class="language-plaintext highlighter-rouge">MoyaProvider</code> 객체로 접근할 수 있는 메인 객체입니다.</p>

<p>네트워크 관련 기능을 사용하기 위해서는 무조건 이 <code class="language-plaintext highlighter-rouge">MoyaProvider</code> 객체를 생성하거나 주입받아야 합니다.</p>

<h3 id="target">Target</h3>

<p>API를 제공하는 서비스를 부르는 명칭입니다.</p>

<p>공개된 오픈 API일 수도 있고, 프로젝트 내부에서 사용되는 서버의 API일 수도 있겠죠.</p>

<p>이 <code class="language-plaintext highlighter-rouge">Target</code>은 <code class="language-plaintext highlighter-rouge">TargetType</code> <code class="language-plaintext highlighter-rouge">protocol</code>을 사용해서 정의해줄 수 있습니다.</p>

<h3 id="endpoint">Endpoint</h3>

<p><code class="language-plaintext highlighter-rouge">Endpoint</code>는 네트워킹 요청을 위해 필요한 정보들을 담는 객체입니다.</p>

<p>HTTP 메서드, request body / header 등의 정보들을 담고 있고, <code class="language-plaintext highlighter-rouge">Target</code> 또한 <code class="language-plaintext highlighter-rouge">MoyaProvider</code>에 의해 이 <code class="language-plaintext highlighter-rouge">Endpoint</code>로 변환되어 사용됩니다.</p>

<p>이 <code class="language-plaintext highlighter-rouge">Endpoint</code>를 커스텀하면 모든 종류의 네트워킹에 필요한 데이터 맵핑을 수행할 수 있다고 하네요.</p>

<h2 id="기초">기초</h2>

<p>공식 문서보다는 코데코의 예제가 쉬워보이니까 코데코의 예제로 진행해보겠습니다.</p>

<pre><code class="language-Swift">public enum Marvel {
  static private let publicKey = "PUBLIC_KEY"
  static private let privateKey = "PRIVATE_KEY"

  case comics
}
</code></pre>

<p>이렇게 <code class="language-plaintext highlighter-rouge">enum</code> 타입으로 API 서비스에 대한 정보를 넣어줄 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">case</code>에는 필요한 API 엔드포인트마다 정의해주면 됩니다.</p>

<pre><code class="language-Swift">enum MyService {
    case zen
    case showUser(id: Int)
    case createUser(firstName: String, lastName: String)
    case updateUser(id: Int, firstName: String, lastName: String)
    case showAccounts
}
</code></pre>

<p>이렇게요..!</p>

<p>연관값으로 넣어준 파라미터들은 리퀘스트시에 파라미터가 필요할 경우 넣어주는 것으로 편하게 사용할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">Target</code>으로 사용될 <code class="language-plaintext highlighter-rouge">enum</code>은 반드시 <code class="language-plaintext highlighter-rouge">TargetType</code> 프로토콜을 채택해야 한다고 했었죠?</p>

<pre><code class="language-Swift">extension Marvel: TargetType {
  public var baseURL: URL {
	//
  }

  public var path: String {
	//
  }

  public var method: Moya.Method {
	//
  }

  public var sampleData: Data {
	//
  }

  public var task: Moya.Task {
	//
  }

  public var headers: [String : String]? {
	//
  }
}
</code></pre>

<p>프로토콜을 채택하고 필요한 프로퍼티들을 자동으로 넣어주면 위와 같은 형태가 됩니다.</p>

<pre><code class="language-Swift">extension Marvel: TargetType {
  public var baseURL: URL {
    return URL(string: "https://gateway.marvel.com/v1/public")!
  }

  public var path: String {
    switch self {
    case .comics: return "/comics"
    }
  }

  public var method: Moya.Method {
    switch self {
    case .comics: return .get
    }
  }

  public var sampleData: Data {
    return Data()
  }

  public var task: Moya.Task { // TODO: 알맞는 옵션으로 변경
    return .requestPlain
  }

  public var headers: [String : String]? {
    return ["Content-Type": "application/json"]
  }

  public var validationType: ValidationType {
    return .successCodes
  }
}
</code></pre>

<h3 id="baseurl">baseURL</h3>

<p>API 서비스의 <code class="language-plaintext highlighter-rouge">baseURL</code>을 입력해줍니다.</p>

<h3 id="path">path</h3>

<p><code class="language-plaintext highlighter-rouge">baseURL</code> 뒤에 붙는 요청 API의 <code class="language-plaintext highlighter-rouge">path</code> 주소를 입력해줍니다.</p>

<p>예시의 경우 전체 API 요청 주소는 https://gateway.marvel.com/v1/public/comics 가 되겠죠!</p>

<h3 id="method">method</h3>

<p><code class="language-plaintext highlighter-rouge">path</code>에 맞는 HTTPS 통신 메서드를 반환해줍니다.</p>

<p>ex) <code class="language-plaintext highlighter-rouge">.get</code>, <code class="language-plaintext highlighter-rouge">.delete</code>, <code class="language-plaintext highlighter-rouge">.patch</code> 등</p>

<h3 id="sampledata">sampleData</h3>

<p>유닛 테스트를 할 때나 실제로 서버가 없을 경우, 이 <code class="language-plaintext highlighter-rouge">sampleData</code>로 가상의 데이터를 담아주면 해당 데이터를 반환값으로 받아옵니다.</p>

<p>필요하지 않을 경우  <code class="language-plaintext highlighter-rouge">Data()</code>를 반환하여 비어있는 데이터를 전달해줍니다!</p>

<h3 id="task">task</h3>

<p>요청에 파라미터를 포함하거나, 데이터를 포함하여 요청을 하는 등의 옵션들을 추가적으로 제공하여 HTTP 요청을 전송합니다.</p>

<p>API가 요구하는 양식이나 서버의 상태등에 따라 너무나 다양한 경우가 있으므로 우선 아무런 옵션을 넣지 않는 <code class="language-plaintext highlighter-rouge">.requestPlain</code>을 선택해주었습니다.</p>

<h3 id="headers">headers</h3>

<p>HTTP 헤더를 넣어줍니다.</p>

<p>예시에서는 가장 자주 쓰이는 <code class="language-plaintext highlighter-rouge">Content-Type: application/json</code>을 넣어주었습니다. (JSON 형식의 컨텐트)</p>

<h3 id="validationtype">validationType</h3>

<p>필수적으로 필요한 항목은 아니지만, 자주 쓰이는 항목입니다.</p>

<p><code class="language-plaintext highlighter-rouge">.successCodes</code>는 200..&lt;299 사이의 응답 코드를 받으면 통신을 성공했다고 처리하는 <code class="language-plaintext highlighter-rouge">case</code>입니다.</p>

<p>이 <code class="language-plaintext highlighter-rouge">Target</code>만 봐도 <code class="language-plaintext highlighter-rouge">Moya</code>가 대충 어떤 느낌으로 쓰이는 지 알 수 있을 것 같네요.</p>

<p>통신에 필요한 데이터들을 한 군데 모아두고 <code class="language-plaintext highlighter-rouge">switch-case</code>를 통해서 쉽게 요청 항목을 선택할 수 있을 것 같습니다.</p>

<p>https://developer.marvel.com/documentation/authorization</p>

<p>이번에 사용하는 마블 API의 문서를 살펴보고, <code class="language-plaintext highlighter-rouge">task</code> 부분을 채워줍시다.</p>

<p>Client-Side 앱은 사전에 인증이 되어 있어야 한다는군요.</p>

<p>Server-Side 방식으로 진행해줍니다.</p>

<pre><code class="language-Swift">public var task: Task {
  let ts = "\(Date().timeIntervalSince1970)"
  let hash = (ts + Marvel.privateKey + Marvel.publicKey).md5
  let authParams = ["apikey": Marvel.publicKey, "ts": ts, "hash": hash]
  
  switch self {
  case .comics:
	return .requestParameters(
	  parameters: [
		"format": "comic",
		"formatType": "comic",
		"orderBy": "-onsaleDate",
		"dateDescriptor": "lastWeek",
		"limit": 50] + authParams,
	  encoding: URLEncoding.default)
  }
}
</code></pre>

<p>이제 실제로 API request를 보내봅시다.</p>

<pre><code class="language-Swift">let provider = MoyaProvider&lt;Marvel&gt;()

provider.request(.comics) { result in
  switch result {
  case .success(let response):
	do {
	  print(try response.mapJSON())
	} catch {
	  // error handling
	}
  case .failure:
	// error handling
  }
}
</code></pre>

<p>위와 같이 짧고 간결하게 통신 요청을 보낼 수 있습니다.</p>

<p><img src="https://i.imgur.com/vxiOPZu.png" alt="" /></p>

<p>엄청나게 많은 데이터들이 들어오는군요..</p>

<p>이 데이터들을 감싸고 <code class="language-plaintext highlighter-rouge">View</code>에 적용하는 내용은 다른 HTTP 통신들과 같습니다.</p>

<p><code class="language-plaintext highlighter-rouge">Moya</code>는 RxSwift와도 아주 잘 어울립니다.</p>

<pre><code class="language-Swift">provider.rx.requestWithProgress(.zen).subscribe { event in
    switch event {
    case .next(let progressResponse):
        if let response = progressResponse.response {
            // do something with response
        } else {
            print("Progress: \(progressResponse.progress)")
        }
    case .error(let error):
        // handle the error
    default:
        break
    }
}
</code></pre>

<p>이런식으로 기본적으로 Rx화도 되어있거든요. (패키지를 설치할 때 <code class="language-plaintext highlighter-rouge">Moya/RxSwift</code>도 함께 설치해주어야 합니다.)</p>

<p>대략적인 사용 방법을 알았으니 실전에 적용해보기 위해 떠나보도록 하겠습니다.</p>

<blockquote>
  <p>참고 문서</p>
</blockquote>

<p><a href="https://www.kodeco.com/5121-moya-tutorial-for-ios-getting-started">Kodeco - # Moya Tutorial for iOS: Getting Started</a></p>

<p><a href="https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md">Moya - Basic Usage</a></p>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><category term="Moya" /><summary type="html"><![CDATA[Moya]]></summary></entry><entry><title type="html">23)🍎 Swift - RxSwift Traits</title><link href="/jekyll-theme-yat/swift/2023/02/23/Swift23.html" rel="alternate" type="text/html" title="23)🍎 Swift - RxSwift Traits" /><published>2023-02-23T00:00:00+00:00</published><updated>2023-02-23T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/02/23/Swift23</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/02/23/Swift23.html"><![CDATA[<h1 id="traits">Traits</h1>

<p><code class="language-plaintext highlighter-rouge">Traits</code>는 <code class="language-plaintext highlighter-rouge">Observable</code>의 한 종류라고 볼 수 있습니다.</p>

<p>Traits는 UI 영역에서 복잡하고 다양한 기능이 있는 <code class="language-plaintext highlighter-rouge">Observable</code> 대신 사용되기 위해 만들어졌습니다.</p>

<p>따라서 RxCocoa와 아주 밀접한 관련이 있지만, 몇몇 기능들은 RxSwift 전반적으로 사용될 수 있기 때문에 RxSwift와 RxCocoa에 나누어 구현되었다고 합니다.</p>

<h3 id="등장-이유">등장 이유</h3>

<p>Traits를 왜 사용해야하는지부터 알아보도록 하겠습니다.</p>

<p>Traits는 <code class="language-plaintext highlighter-rouge">Observable</code> 시퀀스가 안전하게 통신될 수 있도록 돕습니다.</p>

<p>모든 방면에서 사용될 수 있는 <code class="language-plaintext highlighter-rouge">Observable</code>을 대신하여 UI 처리에 특화된 기능과 문법을 제공합니다.</p>

<p>따라서 Traits는 <code class="language-plaintext highlighter-rouge">Observable</code>이 제공하는 기능의 일부를 떼어낸 것과 다름없기 때문에 사용할지 말지의 여부는 사용자에게 달려있다고 합니다!</p>

<h3 id="기본-개념">기본 개념</h3>

<p>Traits는 단순히 하나의 <code class="language-plaintext highlighter-rouge">read-only</code>한 <code class="language-plaintext highlighter-rouge">Observable</code>을 감싸고 있는 <code class="language-plaintext highlighter-rouge">struct</code>입니다.</p>

<pre><code class="language-Swift">struct Single&lt;Element&gt; {
	let source: Observable&lt;Element&gt;
}

struct Driver&lt;Element&gt; {
	let source: Observable&lt;Element&gt;
}
</code></pre>

<p>Traits를 <code class="language-plaintext highlighter-rouge">Observable</code>로 돌려놓고 싶을 때는 <code class="language-plaintext highlighter-rouge">.asObservable()</code>로 간단하게 처리할 수 있습니다.</p>

<h2 id="rxswift-traits">RxSwift Traits</h2>

<h3 id="single">Single</h3>

<p>Single은 무조건 하나의 값 또는 에러를 방출합니다.</p>

<p>지속적인 값이 아니라 딱 한 번의 결과값이 필요할 떄 사용됩니다.</p>

<p>한 번의 값만을 방출하기 떄문에 <code class="language-plaintext highlighter-rouge">.completed</code>가 없습니다.</p>

<p>사용되기 가장 좋은 곳은 HTTP 통신을 할 때이며, request에 하나의 응답만이 돌아올 때 사용하면 유용합니다.</p>

<pre><code class="language-Swift">func getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; {
	return Single&lt;[String: Any]&gt;.create { single in
		let task = URLSession.dataTask(with: URL(string: "https://api.github.com/\(repo)")! { data, _, error in
			if let error {
				single(.failure(error))
				return
			}

			guard let data,
				let json = try? JSONSerialization.jsonObject(with: data, option: .mutableLeaves),
				let result = json as? [String: Any] else {
					single(.failure(DataError.cantParseJSON))
					return	  
			}

			single(.success(result))
		}
		task.resume()

		return Disposables.create { task.cancel() }
	}
}
</code></pre>

<pre><code class="language-Swift">getRepo("ReactiveX/RxSwift")
	.subscribe(onSuccess: { json in
			print("JSON: ", json)
		},
		onError: { error in
			print("Error: ", error)
		})
	.disposed(by: self.disposeBag)
</code></pre>

<h3 id="completable">Completable</h3>

<p>Completable은 <code class="language-plaintext highlighter-rouge">.completed</code>나 <code class="language-plaintext highlighter-rouge">.error</code>만을 방출합니다.</p>

<p>한마디로 값(<code class="language-plaintext highlighter-rouge">element</code>)을 방출하지 않습니다.</p>

<p>작업의 내용은 중요하지 않고, 성공/실패 여부만 중요한 경우에 사용됩니다.</p>

<pre><code class="language-Swift">func cacheLocally() -&gt; Completable {
	return Completable.create { completable in
		guard success else {
			completable(.error(CacheError.failedCaching))
			return Disposables.create { }
		}

		completable(.completed)
		return Disposables.create { }
	}
}
</code></pre>

<pre><code class="language-Swift">cacheLocally()
	.subscribe(onCompleted: {
		print("Completed with no error.")
	},
	onError: { error in
		print("Completed with an error: \(error.localizedDescription)")
	})
	.disposed(by: self.disposebag)
</code></pre>

<h3 id="maybe">Maybe</h3>

<p>Maybe는 Single과 Completable의 중간에 있는 Trait입니다.</p>

<p>하나의 값을 방출하거나 방출 없이 <code class="language-plaintext highlighter-rouge">.complete</code>되거나 <code class="language-plaintext highlighter-rouge">.error</code>를 방출할 수 있습니다.</p>

<pre><code class="language-Swift">func generateString() -&gt; Maybe&lt;String&gt; {
	return Maybe&lt;String&gt;.create { maybe in
		maybe(.success("RxSwift"))
		// or
		maybe(.completed)
		// or
		maybe(.error(error))

		return Disposables.create { }
	}
}
</code></pre>

<pre><code class="language-Swift">generateString()
	.subscribe(onSuccess: { element in
		print("Completed with element \(element)")
	},
	.onError { error in
		print("Completed with an error \(error.localizedDescription)")
	},
	onCompleted: {
		print("Completed with no element")
	})
	.disposed(by: self.disposeBag)
</code></pre>

<h2 id="rxcocoa-traits">RxCocoa Traits</h2>

<h3 id="driver">Driver</h3>

<p>가장 많이 사용되는 Trait입니다.</p>

<p>UI 레이어만을 위해 특별하게 개발된 기능입니다.</p>

<p>특징을 정리해보면 아래와 같습니다.</p>

<ul>
  <li>에러가 방출하지 않습니다</li>
  <li><code class="language-plaintext highlighter-rouge">observe</code>가 Main Scheduler에서 이루어집니다.</li>
  <li>side effect를 공유합니다.</li>
</ul>

<pre><code class="language-Swift">let results = query.rx.text
	.throttle(.milliseconds(300), scheduler: MainScheduler.instance)
	.flatMapLatest { query in
		fetchAutoCompleteItems(query)
	}

results
	.map { "\($0.count)" }
	.bind(to: resultCount.rx.text)
	.disposed(by: self.disposeBag)

results
	.bind(to: resultsTableView.rx.items(cellIdentifier: "Cell")) { _, result, cell in
		cell.textLabel?.text = "\(result)"
	}
	.disposed(by: self.disposeBag)
</code></pre>

<p>위 예시는 세가지 문제점들을 가지고 있습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">fetchAutoCompleteItems</code>가 에러를 방출할 경우, UI에 바인딩되어 있던 것들이 모두 unbind되면서 이후의 쿼리들에 더 이상 UI가 변화하지 않을 것입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">fetchAutoCompleteItems</code>가 메인쓰레드가 아닌 백그라운드 쓰레드에 결과를 반환할 경우, UI에 결과값을 바인딩하는 작업이 백그라운드 쓰레드에서 일어날 수 있고, 이는 예기치 않은 크래시를 발생시킬 수 있습니다.</li>
  <li>결과값이 두 개의 UI 컴포넌트(TableView, UILabel)에 바인딩되어 있기 때문에 각각이 따로 HTTP request를 요청해 불필요한 중복 요청이 발생합니다.</li>
</ol>

<p>이를 해결한 코드는 아래와 같습니다.</p>

<pre><code class="language-Swift">let results = query.rx.text
	.throttle(.milliseconds(300), scheduler: MainScheduler.instance)
	.flatMapLatest { query in
		fetchAutoCompleteItems(query)
			.observeOn(MainScheduler.instance)
			.catchErrorJustReturn([])
	}
	.share(replay: 1)
</code></pre>

<p>예시에서는 이런 과정이 쉬울 수 있으나, 실전에서 프로젝트가 커짐에 따라 이런 사소한 문제점들을 발견하는 것은 어려울 수 있습니다.</p>

<p>따라서 RxCocoa는 이런 문제들을 해결한 UI 레이어 전용의 Trait을 제공하는데, 그것이 바로 Driver인 것 입니다.</p>

<pre><code class="language-Swift">let results = query.rx.text.asDriver()
	.throttle(.milliseconds(300), scheduler: MainScheduler.instance)
	.flatMapLatest { query in
		fetchAutoCompleteItems(query)
			.asDriver(onErrorJustReturn: [])
	}

results
	.map { "\($0.count)" }
	.drive(resultCount.rx.text)
	.disposed(by: self.disposeBag)

results
	.drive(resultsTableView.rx.items(cellIdentifier: "Cell")) { _, result, cell in
		cell.textLabel?.text = "\(result)"
	}
	.disposed(by: self.disposeBag)
</code></pre>

<p>총 세 군데만 주목하면 됩니다!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">query.rx.text.asDriver()</code></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">asDriver</code> 메서드는 <code class="language-plaintext highlighter-rouge">ControlProperty</code>를 <code class="language-plaintext highlighter-rouge">Driver</code>로 변환합니다.</p>

<p><code class="language-plaintext highlighter-rouge">Driver</code>는 <code class="language-plaintext highlighter-rouge">ControlProperty</code>의 모든 프로퍼티를 갖기 때문에 따로 신경쓸 부분은 없이 변환만 하면 그대로 사용할 수 있습니다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">.asDriver(onErrorJustReturn: [])</code></p>
</blockquote>

<p>이전에 살펴봤던 다음 세 가지 조건만 만족한다면, 어떤 <code class="language-plaintext highlighter-rouge">Observable</code>이던 <code class="language-plaintext highlighter-rouge">Driver</code>로 변환할 수 있습니다.</p>

<ul>
  <li>에러가 방출하지 않습니다</li>
  <li><code class="language-plaintext highlighter-rouge">observe</code>가 Main Scheduler에서 이루어집니다.</li>
  <li>side effect를 공유합니다. (<code class="language-plaintext highlighter-rouge">.share(replay:, scope:)</code>)</li>
</ul>

<pre><code class="language-Swift">let safeSequence = xs
	.observeOn(MainScheduler.instance)
	.catchErrorJustReturn(onErrorJustReturn)
	.share(replay: 1, scope: .whileConnected)
return Driver(raw: safeSequence)
</code></pre>

<p>정리해보면 위 과정과 <code class="language-plaintext highlighter-rouge">asDriver(onErrorJustReturn: [])</code>은 동일합니다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">.drive()</code></p>
</blockquote>

<p>마지막으로 <code class="language-plaintext highlighter-rouge">bind(to:)</code> 대신 <code class="language-plaintext highlighter-rouge">drive()</code>를 사용합니다.</p>

<p><code class="language-plaintext highlighter-rouge">drive()</code>를 사용함으로서 UI에 데이터를 안전하게 바인딩할 수 있습니다.</p>

<h3 id="signal">Signal</h3>

<p>구독과 동시에 가장 마지막 이벤트를 <code class="language-plaintext highlighter-rouge">replay</code>하지 않는다는 점 외에는 Driver와 동일합니다.</p>

<p>하지만 sequence를 공유한다는 점은 변하지 않기 때문에 <code class="language-plaintext highlighter-rouge">share</code> 메서드를 통해 원할 때는 값을 공유받을 수 있습니다.</p>

<h2 id="controlproperty--controlevent">ControlProperty / ControlEvent</h2>

<h3 id="controlproperty">ControlProperty</h3>

<p>UI 컴포넌트의 프로퍼티를 내용으로 갖는 <code class="language-plaintext highlighter-rouge">Observable</code>/<code class="language-plaintext highlighter-rouge">ObservableType</code> 입니다.</p>

<ul>
  <li>실패하지 않습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">share(replay: 1)</code>
    <ul>
      <li>Stateful 합니다. (구독과 동시에 마지막 값을 한 번 방출합니다.)</li>
    </ul>
  </li>
  <li>에러를 발생시키지 않습니다.</li>
  <li>메인 쓰레드에서 동작합니다.</li>
</ul>

<pre><code class="language-Swift">extension Reactive where Base: UISearchBar {
	public var value: ControlProperty&lt;String?&gt; {
		let source: Observable&lt;String?&gt; = Observable.deferred { [weak searchBar = self.base as UISearchBar] () -&gt; Observable&lt;String?&gt; in
			let text = searchBar?.text
			return (searchBar?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) ?? Observable.empty())
				.map { a in
					return a[1] as? String
				}
				.startWith(text)
		}

		let bindingObserver = Binder(self.base) { (searchBar, text: String?) in
			searchBar.text = text
		}

		return ControlProperty(values: source, valueSink: bindingObserver)
	}
}
</code></pre>

<h3 id="controlevent">ControlEvent</h3>

<p>UI 컴포넌트의 이벤트를 내용으로 갖는 <code class="language-plaintext highlighter-rouge">Observable</code>/<code class="language-plaintext highlighter-rouge">ObservableType</code> 입니다.</p>

<ul>
  <li>실패하지 않습니다.</li>
  <li>구독이 이루어졌을 때 초기값을 방출하지 않습니다.</li>
  <li>에러를 방출하지 않습니다.</li>
  <li>메인 쓰레드에서 동작합니다.</li>
</ul>

<pre><code class="language-Swift">extension Reactive where Base: UICollectionView {
	public var itemSelected: ControlEvent&lt;IndexPath&gt; {
		let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:)))
			.map { a in
				return a[1] as! IndexPath
			}

		return ControlEvent(events: source)
	}
}
</code></pre>

<h1 id="참고-링크">참고 링크</h1>

<p><a href="https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Traits.md">RxSwift Traits</a></p>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><category term="RxSwift" /><summary type="html"><![CDATA[Traits]]></summary></entry><entry><title type="html">22)🍎 Swift - Compositional Layout.02</title><link href="/jekyll-theme-yat/swift/2023/01/31/Swift22.html" rel="alternate" type="text/html" title="22)🍎 Swift - Compositional Layout.02" /><published>2023-01-31T00:00:00+00:00</published><updated>2023-01-31T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/01/31/Swift22</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/01/31/Swift22.html"><![CDATA[<h2 id="supplementary-item">Supplementary Item</h2>

<p>CollectionView를 사용하다보면 자주 사용하게 되는 요소들이 있습니다.</p>

<p>Badges, Headers, Footers라고 불리는 이것들은 리스트의 앞이나 뒤에 붙어 전체적인 리스트에 대한 정보를 제공해줍니다.</p>

<h3 id="badges">Badges</h3>

<p><code class="language-plaintext highlighter-rouge">CompositionalLayout</code>에서는 이런 SupplementaryItem들을 사용하기 더욱 쉽게 Anchor 개념을 도입했습니다.</p>

<p><img src="https://i.imgur.com/IvAOVeC.png" width="500" /></p>

<p>SupplementaryItem과 CollectionView의 시각적인 관계로서 이들의 위치를 정해준다는 개념입니다.</p>

<p>개념 자체도 굉장히 쉽죠?</p>

<p>적용도 동일하게 매우 쉽게 구현되었습니다.</p>

<pre><code class="language-Swift">let badgeAnchor = NSCollectionLayoutAnchor(
	edges: [.top, .trailing],
	fractionalOffset: CGPoint(x: 0.3, y: -0.3)
)
let badgeSize = NSCollectionLayoutSize(
	widthDimension: .absolute(20),
	heightDimension: .absolute(20)
)
let badge = NSCollectionLayoutSupplementaryItem(
	layoutSize: badgeSize,
	elementKind: "badge",
	containerAnchor: badgeAnchor
)
let item = NSCollectionLayoutItem(
	layoutSize: itemSize,
	supplementaryItems: [badge]
)
</code></pre>

<p>여기서 적용된 <code class="language-plaintext highlighter-rouge">badge</code>라는 <code class="language-plaintext highlighter-rouge">Item</code>은 우측 상단에 위치하고 20x20의 사이즈를 갖는다는 것을 쉽게 알 수 있죠.</p>

<h3 id="header--footer">Header &amp; Footer</h3>

<p>Header와 Footer는 Badges와는 다른 점이 있습니다.</p>

<p>Badges는 <code class="language-plaintext highlighter-rouge">Item</code>의 특정 위치에 겹쳐보이는 요소지만, Header와 Footer는 <code class="language-plaintext highlighter-rouge">Item</code>을 밀어내고 공간을 차지하면서 위치하는 요소라는 점입니다.</p>

<p>따라서 Header와 Footer는 <code class="language-plaintext highlighter-rouge">Boundary</code>라는 추가적인 기능을 갖고 있습니다.</p>

<pre><code class="language-Swift">let header = NSCollectionLayoutBoundarySupplementaryItem(
	contentSize: headerSize,
	elementKind: "header",
	alignment: .top
)
let footer = NSCollectionLayoutBoundarySupplementaryItem(
	layoutSize: footerSize,
	elementKind: "footer",
	alignment: .bottom
)

header.pinToVisibleBounds = true
section.boundarySupplementaryItems = [header, footer]
</code></pre>

<p><code class="language-plaintext highlighter-rouge">pinToVisibleBounds</code> 프로퍼티를 사용해 흔히 말하는 Sticky Header 또한 만들기 쉬워졌습니다.</p>

<h3 id="decoration-view">Decoration View</h3>

<p><code class="language-plaintext highlighter-rouge">ScrollView</code>들의 배경을 꾸며주는 <code class="language-plaintext highlighter-rouge">DecorationView</code> 또한 아래처럼 사용할 수 있습니다.</p>

<pre><code class="language-Swift">let background = NSCollectionLayoutDecorationItem.backgorund(elementKind: "background")
section.backgroundItems = [background]

layout.register(
	MyCoolDecorationView.self,
	forDecorationViewOfKind: "background"
)	
</code></pre>

<h2 id="estimated-self-sizing">Estimated Self-Sizing</h2>

<p><code class="language-plaintext highlighter-rouge">Item</code>들의 요소들의 크기가 정해지지 않고 변화하는 경우가 있습니다.</p>

<p>컨텐츠가 있거나 없는 경우가 있을수도 있고, OS의 텍스트 크기를 변경함에 따라 <code class="language-plaintext highlighter-rouge">size</code>에 변화가 생길수도 있죠.</p>

<p><code class="language-plaintext highlighter-rouge">size</code>를 설정해줄 때 <code class="language-plaintext highlighter-rouge">.estimated</code>을 활용하면 이에 대해 유연한 대응이 가능해집니다.</p>

<pre><code class="language-Swift">let headerSize = NSCollectionLayoutSize(
	widthDimension: .fractionalWidth(1.0),
	heightDimension: .estimated(44.0)
)
let header = NSCollectionLayoutBoundarySupplementaryitem(
	layoutSize: headerSize,
	elementKind: "header",
	alignment: .top
)
header.pinToVisibleBounds = true
section.boundarySupplementaryItems = [header, footer]
</code></pre>

<p>위 예시의 경우 <code class="language-plaintext highlighter-rouge">Item</code>의 높이를 컨텐츠의 크기 변화에 대응시킬 수 있는 것이죠.</p>

<h2 id="group-안에-group-넣기">Group 안에 Group 넣기</h2>

<p>CollectionView가 복잡해지면서 <code class="language-plaintext highlighter-rouge">Group</code> 안에 다른 <code class="language-plaintext highlighter-rouge">Group</code>을 넣을 일이 생길 수도 있겠죠.</p>

<p>사실 <code class="language-plaintext highlighter-rouge">NSCollectionLayoutGroup</code>은 <code class="language-plaintext highlighter-rouge">NSCollectionLayoutItem</code>을 상속받은 하위타입입니다.</p>

<p>다른 말로, <code class="language-plaintext highlighter-rouge">Group</code>을 모아서 다른 <code class="language-plaintext highlighter-rouge">Group</code>을 만들수도 있다는 의미죠.</p>

<p>이런 Nesting에는 제한이 없기 때문에 상당히 다양한 형태의 디자인들을 만들 수 있게 되었습니다.</p>

<p><img src="https://i.imgur.com/ZHvtvEJ.png" width="300" /></p>

<p>이런 형태를 만드려면 어떻게 만들면 될까요?</p>

<pre><code class="language-Swift">let leadingItem = NSCollectionLayoutItem(
	layoutSize: leadingItemSize
)
let trailingItem = NSCollectionLayoutItem(
	layoutSize: trailingItemSize
)
let trailingGroup = NSCollectionLayoutGroup.vertical(
	layoutSize: trailingGroupSize,
	subitem: trailingItem,
	count: 2
)
let containerGroup = NSCollectionLayoutGroup.horizontal(
	layoutSize: containerGroupSize,
	subitems: [leadingItem, trailingGroup]
)
</code></pre>

<p>사실 굉장히 직관적으로 구성할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">leadingItem</code>과 <code class="language-plaintext highlighter-rouge">trailingItem</code> 둘이 묶인 <code class="language-plaintext highlighter-rouge">trailingGroup</code>을 <code class="language-plaintext highlighter-rouge">containerGroup</code>으로 묶은 형태입니다.</p>

<h2 id="collectionview를-collectionview에-넣기">CollectionView를 CollectionView에 넣기</h2>

<p><code class="language-plaintext highlighter-rouge">CollectionView</code> 안에 또 다른 <code class="language-plaintext highlighter-rouge">CollectionView</code>가 있을 경우, 스크롤하는 방향이 바뀌기 때문에 부자연스러운 동작을 보일 수 있습니다.</p>

<p>이런 경우를 해결하기 위해서는</p>

<pre><code class="language-Swift">section.orthogonalScrollingBehavior = .continuous
</code></pre>

<p>이 한 줄의 코드를 추가해주면 해결됩니다.</p>

<pre><code class="language-Swift">enum UICollectionLayoutSectionOrthogonalScrollingBehavior: Int {
	case none
	case continuous
	case continuousGroupLeadingBoundary
	case paging
	case groupPaging
	case groupPagingCentered
}
</code></pre>

<p>이렇게 두개의 <code class="language-plaintext highlighter-rouge">continuous</code> 옵션과 3개의 <code class="language-plaintext highlighter-rouge">paging</code> 옵션이 있으니 원하는 값을 찾아 넣어봅시다.</p>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><summary type="html"><![CDATA[Supplementary Item]]></summary></entry><entry><title type="html">21)🍎 Swift - Compositional Layout.01</title><link href="/jekyll-theme-yat/swift/2023/01/29/Swift21.html" rel="alternate" type="text/html" title="21)🍎 Swift - Compositional Layout.01" /><published>2023-01-29T00:00:00+00:00</published><updated>2023-01-29T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/01/29/Swift21</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/01/29/Swift21.html"><![CDATA[<h1 id="compositional-layout">Compositional Layout</h1>

<blockquote>
  <p>높은 반응성을 갖고 유연한 UI 조정이 가능한 item들을 조합하여 사용하는 레이아웃입니다.</p>
</blockquote>

<p>애플이 Compositional Layout을 소개하면서 대표적으로 예시를 든 앱이 App Store와 사진 앱입니다.</p>

<p><img src="https://i.imgur.com/HVZBa7K.gif" /></p>

<p>여러가지 형태의 레이아웃들이 줄지어 있지만, 이 화면은 단 하나의 <code class="language-plaintext highlighter-rouge">CollectionView</code>로 이루어져있다고 합니다.</p>

<p>기존의 <code class="language-plaintext highlighter-rouge">FlowLayout</code>을 사용했다면 각기 다른 레이아웃에 따라 여러개의 <code class="language-plaintext highlighter-rouge">CollectionView</code>를 사용했어야 했지만 <code class="language-plaintext highlighter-rouge">CompositionalLayout</code>을 사용하면 하나의 <code class="language-plaintext highlighter-rouge">CollectionView</code>로 처리할 수 있다는 것이죠.</p>

<p>그러면서도 이전보다 쉬운 API로 구현이 가능하고, 빠르고 메모리 최적화에 더 우수하다고 합니다.</p>

<h2 id="기본-개념">기본 개념</h2>

<p><code class="language-plaintext highlighter-rouge">CompositionalLayout</code>은 세 가지의 핵심 요소에 집중하면 됩니다.</p>

<p>가장 작은 단위인 <strong><code class="language-plaintext highlighter-rouge">Item</code>이 모여서 <code class="language-plaintext highlighter-rouge">Group</code></strong> 이 되고, 하나의 줄(row)를 형성합니다.</p>

<p>이 <strong><code class="language-plaintext highlighter-rouge">Group</code>들은 다시 한번 모여서 <code class="language-plaintext highlighter-rouge">Section</code></strong> 을 이룹니다. 이렇게 만들어진 모든 <code class="language-plaintext highlighter-rouge">Section</code>을 <code class="language-plaintext highlighter-rouge">Layout</code>이 담고 있는 것이죠.</p>

<p><img src="https://i.imgur.com/pBUzta2.png" width="550" /></p>

<h3 id="size">Size</h3>

<p><code class="language-plaintext highlighter-rouge">CompositionalLayout</code>이 갖고 있는 이 모든 요소들은 각각의 <code class="language-plaintext highlighter-rouge">size</code>를 갖고 있습니다.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">size</code>는 모두가 알고있듯이 <code class="language-plaintext highlighter-rouge">width</code>와 <code class="language-plaintext highlighter-rouge">height</code>, 두 가지 속성으로 이루어져 있습니다.</p>

<pre><code class="language-Swift">class NSCollectionLayoutSize {
	init(
		widthDimension: NSCollectionLayoutDimension,
		heightDimension: NSCollectionLayoutDimension
	)
}
</code></pre>

<p>하지만 주의할 점은 이 <code class="language-plaintext highlighter-rouge">width</code>와 <code class="language-plaintext highlighter-rouge">height</code>는 스칼라 값이 아닙니다.</p>

<p>그래서 <code class="language-plaintext highlighter-rouge">Float</code>와 같은 타입이 아니라 <code class="language-plaintext highlighter-rouge">NSCollectionLayoutDimension</code> 타입의 값을 파라미터로 취합니다.</p>

<pre><code class="language-Swift">class NSCollectionLayoutDimension {
	class func fractionalWidth(_ fractionalWidth: CGFloat) -&gt; Self
	class func fractionalHeight(_ fractionalHeight: CGFloat) -&gt; Self
	class func absolute(_ absoluteDimension: CGFloat) -&gt; Self
	class func estimated(_ estimatedDimension: CGFloat) -&gt; Self
}
</code></pre>

<p>총 네 가지 타입으로 구분할 수 있고, 각각을 쉽게 설명하면 다음과 같습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fractional</code>: 상위 컴포넌트(컨테이너)의 크기에 비례하여 크기를 가질 때 사용됩니다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.fractionalWidth(0.5)</code>, <code class="language-plaintext highlighter-rouge">.fractionalHeight(0.3)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">absolute</code>: 고정된 값의 크기를 가질 때 사용됩니다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.absolute(200)</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">estimated</code>: 고정된 값으로 시작되지만 크기가 변동될 때 사용됩니다.
    <ul>
      <li>.estimated(200)</li>
    </ul>
  </li>
</ul>

<h3 id="item">Item</h3>

<p><code class="language-plaintext highlighter-rouge">Item</code>은 화면에 렌더링되는 요소입니다.</p>

<p><code class="language-plaintext highlighter-rouge">cell</code>이나 <code class="language-plaintext highlighter-rouge">supplementary</code>가 여기에 해당됩니다.</p>

<pre><code class="language-Swift">class NSCollectionLayoutItem {
	convenience init(layoutSize: NSCollectionLayoutSize)
	var contentInsets: NSDirectionalEdgeInsets
}
</code></pre>

<p>초기화할 때 <code class="language-plaintext highlighter-rouge">size</code>를 정해줘야하고, <code class="language-plaintext highlighter-rouge">contentInsets</code>를 통해 inset도 정해줄 수가 있네요.</p>

<h3 id="group">Group</h3>

<p><code class="language-plaintext highlighter-rouge">Group</code>은 레이아웃으로서의 가장 기본적인 단위가 되는 요소입니다.</p>

<p><code class="language-plaintext highlighter-rouge">Group</code>은 <code class="language-plaintext highlighter-rouge">.horizontal</code>, <code class="language-plaintext highlighter-rouge">.vertical</code>, <code class="language-plaintext highlighter-rouge">.custom</code>의 세가지 형태로 정의해줄 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">Group</code>을 하나의 작은 <code class="language-plaintext highlighter-rouge">FlowLayout</code>이라고 생각해보면 이해가 쉽습니다.</p>

<p>가로 혹은 세로 한쪽 방향으로 쭉 이어지는 레이아웃이니까요.</p>

<p>한 쪽 방향으로만 진행되는 <code class="language-plaintext highlighter-rouge">Group</code>이 싫다면 <code class="language-plaintext highlighter-rouge">.custom</code>을 사용해 직접 구현해줄 수도 있습니다.</p>

<pre><code class="language-Swift">class NSCollectionLayoutGroup: NSCollectionLayoutItem {
	class func horizontal(
		layoutSize: NSCollectionLayoutSize,
		subitems: [NSCollectionLayoutItem]) -&gt; Self
	class func vertical(
		layoutSize: NSCollectionLayoutSize,
		subitems: [NSCollectionLayoutItem]) -&gt; Self
	class func custom(
		layoutSize: NSCollectionLayoutSize,
		itemProvider: NSCollectionLayoutGroupCustomItemProvider) -&gt; Self
}
</code></pre>

<h3 id="section">Section</h3>

<p><code class="language-plaintext highlighter-rouge">Section</code>은 말 그대로 <code class="language-plaintext highlighter-rouge">Section</code>을 기준으로 나열되는 <code class="language-plaintext highlighter-rouge">CollectionView</code>의 <code class="language-plaintext highlighter-rouge">Section</code>입니다.</p>

<p>기존에 사용하던 Layout들의 <code class="language-plaintext highlighter-rouge">Section</code>과 동일한 개념입니다.</p>

<p><code class="language-plaintext highlighter-rouge">dataSource</code>로부터 <code class="language-plaintext highlighter-rouge">Item</code>의 개수를 받아와 <code class="language-plaintext highlighter-rouge">Section</code>을 구성합니다.</p>

<pre><code class="language-Swift">class NSCollectionLayoutSection {
	convenience init(layoutGroup: NSCollectionLayoutGroup)
	var contentInsets: NSDirectionalEdgeInsets
}
</code></pre>

<h3 id="layout">Layout</h3>

<p>그렇다면 레이아웃을 초기화해줄때는 어떻게 하면 될까요?</p>

<p>애플은 두 가지 방법을 제공하고 있습니다.</p>

<pre><code class="language-Swift">class UICollectionViewCompositionalLayout: UICollectionViewLayout {
	init(section: NSCollectionLayoutSection)
	init(sectionProvider: @escaping SectionProvider)
}
</code></pre>

<h4 id="initsection-nscollectionlayoutsection"><code class="language-plaintext highlighter-rouge">init(section: NSCollectionLayoutSection)</code></h4>

<p>레이아웃의 섹션을 직접 지정해주는 방식입니다.</p>

<p>쉽고 간단하지만 현재 사용되는 레이아웃 방식과 차별성이 거의 없습니다.</p>

<h4 id="initsectionprovider-escaping-sectionprovider"><code class="language-plaintext highlighter-rouge">init(sectionProvider: @escaping SectionProvider)</code></h4>

<p><code class="language-plaintext highlighter-rouge">Compositional</code>하게 <code class="language-plaintext highlighter-rouge">Section</code>들을 구성해주려면 이 방식을 사용해야 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">@escaping</code> 클로저가 보이시죠?</p>

<p>이 클로저 안에서 각 <code class="language-plaintext highlighter-rouge">Section</code>마다의 독립적인 설정을 해줄 수 있습니다.</p>

<p>정확히 해당 과정이 어떻게 이루어지는가는 활용 예시에서 다시 한번 보도록 하겠습니다.</p>

<h2 id="활용-예시">활용 예시</h2>

<h3 id="간단한-테이블-리스트">간단한 테이블 리스트</h3>

<pre><code class="language-Swift">private func configureLayout() -&gt; UICollectionViewLayout {
	let itemSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(1.0),
		heightDimension: .fractionalHeight(1.0)
	)
	let item = NSCollectionLayoutItem(layoutSize: itemSize)

	let groupSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(1.0),
		heightDimension: .absolute(44)
	)
	let group = NSCollectionLayoutGroup.horizontal(
		layoutSize: groupSize,
		subItems: [item]
	)

	let section = NSCollectionLayoutSection(group: group)

	let layout = UICollectionViewCompositionalLayout(section: section)
	return layout
}
</code></pre>

<p><img src="https://i.imgur.com/bJqs3XR.png" width="300" /></p>

<p>가장 간단한 형태의 Layout이라고 볼 수 있습니다.</p>

<p>한가지 주목할 점은 이 경우에 각 cell의 <code class="language-plaintext highlighter-rouge">size</code>를 <code class="language-plaintext highlighter-rouge">Item</code>이 아니라 <strong><code class="language-plaintext highlighter-rouge">Group</code>을 활용</strong>해서 정해주었다는 점입니다.</p>

<p><code class="language-plaintext highlighter-rouge">.horizontal</code> 방향의 <code class="language-plaintext highlighter-rouge">Group</code>에는 각각 하나의 <code class="language-plaintext highlighter-rouge">Item</code>만을 갖고 있는 형태이기 때문에 활용할 수 있는 방법입니다.</p>

<p>그래서 <code class="language-plaintext highlighter-rouge">itemSize</code>의 크기는 <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code> 모두 <code class="language-plaintext highlighter-rouge">.fractional(1.0)</code>으로 그룹을 꽉 채워주었죠.</p>

<p>대신 <code class="language-plaintext highlighter-rouge">groupSize</code>의 크기를 <code class="language-plaintext highlighter-rouge">width</code>는 <code class="language-plaintext highlighter-rouge">.fractional(1.0)</code>, <code class="language-plaintext highlighter-rouge">height</code>를 <code class="language-plaintext highlighter-rouge">.absolute(44)</code>로 지정해주어 가로를 꽉 채우지만 높이는 44로 고정시켜주었습니다.</p>

<h3 id="한-줄의-개수가-5개로-고정된-그리드">한 줄의 개수가 5개로 고정된 그리드</h3>

<p><img src="https://i.imgur.com/id866Ai.png" width="300" /></p>

<p><img src="https://i.imgur.com/AuPyn68.png" width="500" /></p>

<p>이번에는 무조건 한 줄에 무조건 5개의 cell이 들어가고, 정사각형의 형태를 가져야 하는 그리드 형식의 컬렉션뷰입니다.</p>

<p>이 경우는 위에서 사용했던 코드에서 <code class="language-plaintext highlighter-rouge">size</code> 값만 변경해주는 것 만으로도 쉽게 구현할 수 있습니다.</p>

<pre><code class="language-Swift">private func configureLayout() -&gt; UICollectionViewLayout {
	let itemSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(0.2),
		heightDimension: .fractionalHeight(1.0)
	)
	let item = NSCollectionLayoutItem(layoutSize: itemSize)

	let groupSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(1.0),
		heightDimension: .fractionalWidth(0.2)
	)
	let group = NSCollectionLayoutGroup.horizontal(
		layoutSize: groupSize,
		subItems: [item]
	)

	let section = NSCollectionLayoutSection(group: group)

	let layout = UICollectionViewCompositionalLayout(section: section)
	return layout
}
</code></pre>

<p>각 아이템들의 <strong><code class="language-plaintext highlighter-rouge">width</code>는 그룹 넓이의 20%</strong>(<code class="language-plaintext highlighter-rouge">.fractionalWidth(0.2)</code>)로, 각 그룹들의 <strong><code class="language-plaintext highlighter-rouge">height</code>는 섹션 넓이의 20%</strong>(<code class="language-plaintext highlighter-rouge">.fractionalWidth(0.2)</code>)로 지정해주어 정사각형의 형태를 만들어주었습니다.</p>

<p><img src="https://i.imgur.com/OkozR85.png" width="300" /></p>

<p>그러면 위와 같이 <code class="language-plaintext highlighter-rouge">inset</code>을 주고 싶을땐 어떻게 줄 수 있을까요?</p>

<pre><code class="language-Swift">private func configureLayout() -&gt; UICollectionViewLayout {
	let itemSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(0.2),
		heightDimension: .fractionalHeight(1.0)
	)
	let item = NSCollectionLayoutItem(layoutSize: itemSize)
	item.contentInsets = NSDirectionalEdgeInsets(top: 5, leading: 5, bottom: 5, trailing: 5)

	let groupSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(1.0),
		heightDimension: .fractionalWidth(0.2)
	)
	let group = NSCollectionLayoutGroup.horizontal(
		layoutSize: groupSize,
		subItems: [item]
	)

	let section = NSCollectionLayoutSection(group: group)

	let layout = UICollectionViewCompositionalLayout(section: section)
	return layout
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">item.contentInsets = NSDirectionalEdgeInsets(top: 5, leading: 5, bottom: 5, trailing: 5)</code> 이 부분만 추가해주면 됩니다!</p>

<p><code class="language-plaintext highlighter-rouge">inset</code>의 장점은 Layout의 변화 없이도 실제로 보여지는 각 cell의 크기를 변경해줄 수 있다는 점입니다.</p>

<p><img src="https://i.imgur.com/FRRUZMe.png" width="300" /></p>

<p>이번에는 비슷하지만 그리드 형태지만 다른 방식으로 구현해봅시다.</p>

<pre><code class="language-Swift">private func configureLayout() -&gt; UICollectionViewLayout {
	let itemSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(1.0),
		heightDimension: .fractionalHeight(1.0)
	)
	let item = NSCollectionLayoutItem(layoutSize: itemSize)

	let groupSize = NSCollectionLayoutSize(
		widthDimension: .fractionalWidth(1.0),
		heightDimension: .absolute(44)
	)
	let group = NSCollectionLayoutGroup.horizontal(
		layoutSize: groupSize,
		repeatingSubItem: item,
		count: 2
	)
	let spacing: CGFloat = 10.0
	group.interItemSpacing = .fixed(spacing)

	let section = NSCollectionLayoutSection(group: group)
	section.interGroupSpacing = spacing
	section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 10, bottom: 0, trailing: 10)

	let layout = UICollectionViewCompositionalLayout(section: section)
	return layout
}
</code></pre>

<p>이 경우에 <code class="language-plaintext highlighter-rouge">itemSize</code>의 <code class="language-plaintext highlighter-rouge">width</code>와 <code class="language-plaintext highlighter-rouge">height</code>를 모두 <code class="language-plaintext highlighter-rouge">.fractional(1.0)</code>으로 주었지만, 이 값은 아래의 <code class="language-plaintext highlighter-rouge">Group</code> 설정에서 override됩니다.</p>

<pre><code class="language-Swift">let group = NSCollectionLayoutGroup.horizontal(
	layoutSize: groupSize,
	subItem: item,
	count: 2
)
</code></pre>

<p>이렇게 <code class="language-plaintext highlighter-rouge">Item</code>의 개수를 그룹별로 지정해주면, <code class="language-plaintext highlighter-rouge">CompositionalLayout</code>이 알아서 <code class="language-plaintext highlighter-rouge">Item</code>의 크기를 결정해줍니다.</p>

<h3 id="여러개의-section을-갖는-경우">여러개의 Section을 갖는 경우</h3>

<p>지금까지는 <code class="language-plaintext highlighter-rouge">Section</code>이 하나인 경우, 즉 <code class="language-plaintext highlighter-rouge">FlowLayout</code>으로도 별 어려움 없이 구현할 수 있었던 경우들이였습니다.</p>

<p><code class="language-plaintext highlighter-rouge">CompositionalLayout</code>이 이걸 위해서 등장한 건 아니였죠.</p>

<p>여러개의 <code class="language-plaintext highlighter-rouge">Section</code>을 갖고, 각각을 관리할 수 있는 경우를 살펴봅시다.</p>

<p><img src="https://i.imgur.com/854peYX.png" width="300" /></p>

<pre><code class="language-Swift">func createLayout() -&gt; UICollectionViewLayout {
	let layout = UICOllectionViewCompositionalLayout { sectionIndex: Int, layoutEnvironment: NSCollectionLayoutEnvironment -&gt; NSCollectionLayoutSection? in
		guard let sectionLayoutKind = SectionLayoutKind(rawValue: sectionIndex) else { return nil }
		let columns = sectionLayoutKind.columnCount

		// 위 경우와 마찬가지로 아래 group 설정에서 override됨
		let itemSize = NSCollectionLayoutSize(
			widthDimension: .fractionalWidth(1.0),
			heightDimension: .fractionalHeight(1.0)
		)
		let item = NSCollectionLayoutItem(layoutSize: itemSize)
		item.contentInsets = NSDirectionalEdgeInsets(top: 2, leading: 2, bottom: 2, trailing: 2)

		let groupHeight = columns == 1 ?
			NSCollectionLayoutDimension.absolute(44) :
			NSCollectionLayoutDimension.fractionalWidth(0.2)
		let groupSize = NSCollectionLayoutSize(
			widthDimension: .fractionalWidth(1.0),
			heightDimension: groupHeight
		)
		let group = NSCollectionLayoutGroup.horizontal(
			layoutSize: groupSize,
			subitem: item,
			count: columns
		)
	}
}
</code></pre>

<p>굉장히 굉장히 길어 보이지만 핵심은 하나입니다.</p>

<pre><code class="language-Swift">let layout = UICollectionViewCompositionalLayout { sectionIndex: Int, layoutEnvironment: NSCollectionLayoutEnvironment -&gt; NSCollectionLayoutSection? in
	// 
}
</code></pre>

<p>이 부분이죠.</p>

<p>이 모든 설정들은 <code class="language-plaintext highlighter-rouge">SectionProvider</code> 클로저 안에 있습니다.</p>

<p>그리고 두 개의 파라미터를 제공합니다.</p>

<p><code class="language-plaintext highlighter-rouge">sectionIndex</code>는 말 그대로 <code class="language-plaintext highlighter-rouge">Section</code>의 index고, <code class="language-plaintext highlighter-rouge">layoutEnvironment</code>는 size나 display scale과 같은 container의 프로퍼티들을 제공해주는 프로토콜입니다.</p>

<p><code class="language-plaintext highlighter-rouge">SectionLayoutKind</code>는 <code class="language-plaintext highlighter-rouge">sectionIndex</code> 값을 파라미터로 받아 <code class="language-plaintext highlighter-rouge">Section</code>의 종류를 결정해주고, 하나의 column에 몇개의 <code class="language-plaintext highlighter-rouge">Item</code>이 들어가는지를 정해주는 <code class="language-plaintext highlighter-rouge">enum</code> 타입입니다.</p>

<pre><code class="language-Swift">enum SectionLayoutKind: Int, CaseIterable {
	case list, grid5, grid3

	var columnCount: Int {
		switch self {
		case .grid3:
			return 3
		case .grid5:
			return 5
		case .list:
			return 1
		}
	}
}
</code></pre>

<p>이렇게 <code class="language-plaintext highlighter-rouge">Section</code>의 index에 따라서 여러 종류의 Layout을 지정해줄 수 있습니다.</p>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><summary type="html"><![CDATA[Compositional Layout]]></summary></entry><entry><title type="html">20)🍎 Swift - RxFlow.02</title><link href="/jekyll-theme-yat/swift/2023/01/28/Swift20.html" rel="alternate" type="text/html" title="20)🍎 Swift - RxFlow.02" /><published>2023-01-28T00:00:00+00:00</published><updated>2023-01-28T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/01/28/Swift20</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/01/28/Swift20.html"><![CDATA[<h1 id="rxflow">RxFlow</h1>

<p>험난한 길이 예상되지만 가봅시다..</p>

<p>깃허브와 같은 순서대로 해봅시다.</p>

<h3 id="step-정의">Step 정의</h3>

<pre><code class="language-Swift">import RxFlow

enum FavorStep: Step {
	case signInIsRequired
}
</code></pre>

<p>우선 로그인 Step만 만들어주었습니다.</p>

<h3 id="flow-정의">Flow 정의</h3>

<pre><code class="language-Swift">import UIKit

import RxFlow

final class AppFlow: Flow {

	var root: Presentable { self.rootViewController }

	private lazy var rootViewController: UINavigationController = {
		let navigationController = UINavigationController()
		return navigationController
	}()

	init() { }

	func navigate(to step: Step) -&gt; FlowContributors {
		guard let step = step as? FavorStep else { return .none }

		switch step {
			case .signInIsRequired:
				return self.navigateToAuth()
		}
	}
}

private extension AppFlow {

	func navigateToAuth() -&gt; FlowContributors {
		let selectSignInVC = SelectSignInViewController()
		return .one(
			flowContributor: .contribute(
				withNextPresentable: selectSignInVC, 
				withNextStepper: OneStepper(withSingleStep: FavorStep.signInIsRequired)
			)
		)
	}

}
</code></pre>

<hr />

<p>학습 중… 🚜</p>

<hr />]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><category term="Favor" /><summary type="html"><![CDATA[RxFlow]]></summary></entry><entry><title type="html">19)🍎 Swift - RxFlow.01</title><link href="/jekyll-theme-yat/swift/2023/01/27/Swift19.html" rel="alternate" type="text/html" title="19)🍎 Swift - RxFlow.01" /><published>2023-01-27T00:00:00+00:00</published><updated>2023-01-27T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2023/01/27/Swift19</id><content type="html" xml:base="/jekyll-theme-yat/swift/2023/01/27/Swift19.html"><![CDATA[<h1 id="rxflow">RxFlow</h1>

<p>Favor 프로젝트는 ReactorKit을 사용하여 MVVM-C패턴에 RxSwift를 적극적으로 활용하고 있습니다.</p>

<p>하지만 저희 프로젝트에서 Reactive하지 못한 부분이 하나 있었습니다.</p>

<p>바로 Coordinator 부분인데요..</p>

<p>하위 Coordinator를 종료하기 위해서는 상위 Coordinator에 접근해야만 하는 현상을 발견헀습니다.</p>

<p>바로 아래 코드처럼요..</p>

<pre><code class="language-Swift">self.coordinator.parentCoordinator?.finish(childCoordinator: self.coordinator)
</code></pre>

<p>한눈에 봐도 굉장히 깔끔해보이지 않습니다. 😵</p>

<p><code class="language-plaintext highlighter-rouge">현재 코디네이터 ➡️ 상위 코디네이터</code>에 접근을 한 뒤 다시 <code class="language-plaintext highlighter-rouge">현재 코디네이터를 종료하는 메서드를 실행</code>하는 것은 굉장히 좋지 않은 접근이라고 생각했습니다.</p>

<p>때문에 두 가지 방법을 고안해보았는데요.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">delegate</code> 패턴을 사용하여 하위 코디네이터에서 직접적으로 상위 코디네이터에 접근하는 것을 방지</li>
</ul>

<pre><code class="language-Swift">extension AppCoordinator: CoordinatorFinishDelegate {
  func coordinatorDidFinish(childCoordinator: some Coordinator) {
    self.finish(childCoordinator: childCoordinator)
    
    self.navigationController.viewControllers.removeAll()
    
    switch childCoordinator.self {
    case is AuthCoordinator:
      self.showTabBarFlow()
    case is TabBarCoordinator:
      self.showAuthFlow()
    default:
      break
    }
  }
}
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">override</code>를 활용하여 추가 로직 구현 방식으로 접근</li>
</ul>

<pre><code class="language-Swift">  override func finish(childCoordinator: some Coordinator) {
    super.finish(childCoordinator: childCoordinator)
    
    self.navigationController.viewControllers.removeAll()
    
    switch childCoordinator.self {
    case is AuthCoordinator:
      self.showTabBarFlow()
    case is TabBarCoordinator:
      self.showAuthFlow()
    default:
      break
    }
  }
</code></pre>

<p>사실 완벽하게 동일한 로직이지만 접근 방법의 차이를 갖고 있고, 어떤 방식이 더 나을까를 고민하던 중에</p>

<p><code class="language-plaintext highlighter-rouge">delegate</code> 패턴을 사용하는 방식이 “위임”한다는 로직 측면에서는 직관적이지만 코드 가시성 측면에서는 복잡하다는 의견으로 귀결되었습니다.</p>

<p><code class="language-plaintext highlighter-rouge">delegate</code> 패턴을 어떻게 하면 더 쉽게 사용할 수 있을까를 고민하던 중에 <code class="language-plaintext highlighter-rouge">rx</code>를 활용하면 되지 않을까라는 생각에 라이브러리를 찾아보게 되었고, <code class="language-plaintext highlighter-rouge">RxFlow</code>를 발견하게 되었습니다!</p>

<h2 id="-rxflow란">❓ RxFlow란</h2>

<p>공식 GitHub 설명은 <code class="language-plaintext highlighter-rouge">RxFlow</code>를 다음과 같이 설명하고 있습니다.</p>

<blockquote>
  <p>RxFlow는 <code class="language-plaintext highlighter-rouge">Reactive Flow</code>를 활용하여 Coordinator 패턴을 구현한 iOS 앱을 위한 navigation 라이브러리이다.</p>
</blockquote>

<p>요약하면 “코디네이터 패턴에 <code class="language-plaintext highlighter-rouge">rx</code>를 접목시켰다.” 정도겠네요.</p>

<p><code class="language-plaintext highlighter-rouge">RxFlow</code>는 Coordinator 패턴을 Reactive화 시킨 것이기 때문에 Coordinator 패턴의 장단점을 먼저 설명하고 있습니다.</p>

<h3 id="-장점">😊 장점</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">UIViewController</code>에서 네비게이션 코드를 분리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">UIViewController</code>를 다른 화면 전환 상황에서도 재사용할 수 있다.</li>
  <li>의존성 주입을 쉽게 이룰 수 있다.</li>
</ul>

<h3 id="-단점">😭 단점</h3>
<ul>
  <li>코디네이터 패턴의 기본적인 로직들은 앱을 bootstrap할 때마다 작성해주어야 한다.</li>
  <li>코디네이터 패턴 스택의 교류 과정에서 boilerplate 코드가 많이 발생할 수 있다.</li>
</ul>

<p>그렇다면 <code class="language-plaintext highlighter-rouge">RxFlow</code>는 어떤 발전을 이루었다고 주장하고 있을까요?</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Flows</code>를 활용하여 네비게이션을 좀 더 명확하게 발전시켰다.</li>
  <li><code class="language-plaintext highlighter-rouge">FlowCoordinator</code>를 기본적으로 제공하여 <code class="language-plaintext highlighter-rouge">Flows</code> 사이의 네비게이션을 제어할 수 있다.</li>
  <li>네비게이션 액션들이 Reactive하게 이루어진다.</li>
</ul>

<p>그리고 아래는 <code class="language-plaintext highlighter-rouge">RxFlow</code>를 이해하기 위해 알아두어야 할 6가지 용어들입니다.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Flow</code>: 각각의 <code class="language-plaintext highlighter-rouge">Flow</code>는 앱의 <strong>네비게이션 공간</strong>들을 정의합니다. 이 공간은 네비게이션 <strong>액션들이 선언되는 곳</strong>입니다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Step</code>: <code class="language-plaintext highlighter-rouge">Step</code>은 네비게이션까지 이어질 수 있는 <strong>state를 표현하기 위한 방법</strong>입니다. <strong><code class="language-plaintext highlighter-rouge">Flow</code>와 <code class="language-plaintext highlighter-rouge">Step</code>을 조합</strong>하면 <strong>가능한 모든 네비게이션 액션을 설명</strong>할 수 있습니다. <code class="language-plaintext highlighter-rouge">Step</code>은 (<code class="language-plaintext highlighter-rouge">id</code>나 <code class="language-plaintext highlighter-rouge">URL</code> 같은) 내부적인 값들을 지니고 있을 수도 있어 이 값들을 <code class="language-plaintext highlighter-rouge">Flow</code>에 선언되어 있는 화면들에 전달할 수도 있습니다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Stepper</code>: <strong><code class="language-plaintext highlighter-rouge">Flow</code> 안에서 <code class="language-plaintext highlighter-rouge">Step</code>을 발생</strong>시킬 수 있다면, 그 어떤 것도 <code class="language-plaintext highlighter-rouge">Stepper</code>라고 불릴 수 있습니다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Presentable</code>: <strong>Present 될 수 있는 어떤 것</strong>을 추상적으로 표현한 개념입니다. (기본적으로 <code class="language-plaintext highlighter-rouge">UIViewController</code>와 <code class="language-plaintext highlighter-rouge">Flow</code>가 <code class="language-plaintext highlighter-rouge">Presentable</code>한 객체입니다.)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FlowContributor</code>: 어떤 것들이 <code class="language-plaintext highlighter-rouge">Flow</code> 안에서 새로운 <code class="language-plaintext highlighter-rouge">Step</code>을 만들어낼 수 있을지를 <code class="language-plaintext highlighter-rouge">FlowCoordinator</code>에게 알려주는 간단한 데이터 구조입니다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FlowCoordinator</code>: 개발자가 적절한 <code class="language-plaintext highlighter-rouge">Flow</code>와 <code class="language-plaintext highlighter-rouge">Step</code>을 조합하여 가능한 네비게이션을 정의하면, <code class="language-plaintext highlighter-rouge">FlowCoordinator</code>는 앱의 모든 네비게이션을 제어하기 위해 이 조합들을 섞습니다. <code class="language-plaintext highlighter-rouge">FlowCoordinator</code>는 <code class="language-plaintext highlighter-rouge">RxFlow</code>에 의해 제공되어 개발자가 직접 구현하지 않아도 됩니다.</p>
  </li>
</ul>

<h2 id="사용-예시">사용 예시</h2>

<p><img src="https://raw.githubusercontent.com/RxSwiftCommunity/RxFlow/develop/Resources/RxFlow.gif" /></p>

<p>공식 문서는 위와 같은 영화 정보앱을 예시로 들어 설명하고 있습니다.</p>

<p>하나씩 살펴볼게요..! 😉</p>

<h3 id="step-정의">Step 정의</h3>

<p>우선 <code class="language-plaintext highlighter-rouge">Step</code>을 정의해주어야 합니다.</p>

<p>한 가지 주의할 점은 <code class="language-plaintext highlighter-rouge">Step</code>은 앱의 상태를 나타내는 요소이기 때문에 어디로 navigation이 이루어질 지와 같은 <strong>특정적인 요소들은 <code class="language-plaintext highlighter-rouge">Step</code>이 아니라 <code class="language-plaintext highlighter-rouge">Flow</code>에서</strong> 정해줘야 한다고 합니다.</p>

<p>예를 들어 <code class="language-plaintext highlighter-rouge">showMovieDetail(withID: Int)</code>는 영화를 선택했을 때 영화의 세부 정보를 보여주는 매우 특정된 케이스이기 때문에 바람직하지 않습니다.</p>

<p>대신 <code class="language-plaintext highlighter-rouge">movieIsPicked(withID: Int)</code>와 같이 조금 더 <strong>독립적인 케이스</strong>를 추가해줘야 합니다. 이런 식으로 정의해주면 영화가 선택됐을 때 영화의 세부 정보 화면을 불러오는 것 말고도 다른 조건에서 다른 액션을 추가해줄 수 있습니다.</p>

<p>아래와 같이 <code class="language-plaintext highlighter-rouge">enum</code> 타입으로 정의하는 것을 추천하고 있습니다.</p>

<pre><code class="language-Swift">enum DemoStep: Step {
	// Login
	case loginIsRequired
	case userIsLoggedIn

	// Onboarding
	case onboardingIsRequired
	case onboardingIsComplete

	// Home
	case dashboardIsRequired

	// Movies
	case moviesAreRequired
	case movieIsPicked(withID: Int)
	case castIsPicked(withID: Int)

	// Settings
	case settingsAreRequired
	case settingsAreComplete
}
</code></pre>

<h3 id="flow-정의">Flow 정의</h3>

<p><code class="language-plaintext highlighter-rouge">Flow</code> 정의는 두 가지를 필수적으로 해줘야합니다.</p>

<ul>
  <li>네비게이션의 근간이 되는 root <code class="language-plaintext highlighter-rouge">Presentable</code>을 선언해줍니다.</li>
  <li><code class="language-plaintext highlighter-rouge">navigate(to:)</code> 메서드를 구현함으로서 <code class="language-plaintext highlighter-rouge">Step</code>을 네비게이션 액션으로 변환해주는 기능을 구현합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">navigate(to:)</code> 메서드는 <code class="language-plaintext highlighter-rouge">FlowContributos</code>를 리턴합니다.</p>

<p><code class="language-plaintext highlighter-rouge">.one(flowContributor: .contribute(withNextPresentable: viewController, withNextStepper: viewController.viewModel))</code>
의 형태로 리턴을 하면 되는데요.. 각 파라미터는 다음과 같습니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">viewController</code>: 모두가 아는바와 같이 <code class="language-plaintext highlighter-rouge">Presentable</code>이고, LifeCycle에 따라 연결된 <code class="language-plaintext highlighter-rouge">Stepper</code>(<code class="language-plaintext highlighter-rouge">ViewModel</code>)가 <code class="language-plaintext highlighter-rouge">Step</code>을 emit하는 것에 영향을 줍니다.
    <ul>
      <li>예를 들어 <code class="language-plaintext highlighter-rouge">Presentable</code>이 hidden(present되지 않은 상황)일 경우, <code class="language-plaintext highlighter-rouge">Stepper</code>가 <code class="language-plaintext highlighter-rouge">Step</code>을 emit한다고 해도 해당 emit은 효력이 없습니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">viewModel</code>: <code class="language-plaintext highlighter-rouge">Stepper</code>로서 연결된 <code class="language-plaintext highlighter-rouge">Presentable</code>의 LifeCycle에 영향을 받으며, <code class="language-plaintext highlighter-rouge">Step</code>을 emit함으로서 <code class="language-plaintext highlighter-rouge">Flow</code>안에서 네비게이션에 기여합니다.</li>
</ul>

<p>부가적으로 <code class="language-plaintext highlighter-rouge">Flow</code>는 View Controller를 instantiate 해줄 때 이루어지는 의존성 주입에 이용될 수도 있습니다.</p>

<pre><code class="language-Swift">class WatchedFlow: Flow {
	var root: Presentable {
		return self.rootViewController
	}

	private let rootViewController = UINavigationController()
	private let services: AppServices

	init(withServices services: AppServices) {
		self.services = services
	}

	func navigate(to step: Step) -&gt; FlowContributors {
		guard let step = step as? DemoStep else { return .none }

		switch step {
		case .moviesAreRequired:
			return self.navigateToMovieListScreen()
		case .movieIsPicked(let movieID):
			return self.navigateToMovieDetailScreen(with: movieID)
		case .castIsPicked(let castID):
			return self.navigateToCastDetailScreen(with: castID)
		default:
			return .none
		}
	}
}

private extension WatchedFlow {

	func navigateToMovieListScreen() -&gt; FlowContributors {
		let viewController = WatchedViewController.instantiate(withViewModel: WatchedViewModel(), andServices: self.services)
		viewController.title = "Watched"

		self.rootViewController.pushViewController(viewController, animated: true)
		return .one(flowContributor: .contribute(withNextPresentable: viewController, withNextStepper: viewController.viewModel))
	}

	func navigateToMovieDetailScreen(with movieID: Int) -&gt; FlowContributors {
		// ...
	}

	func navigateToCastDetailScreen(with castID: Int) -&gt; FlowContributors {
		// ...
	}
}
</code></pre>

<h3 id="stepper-정의">Stepper 정의</h3>

<p><code class="language-plaintext highlighter-rouge">Stepper</code>는 <code class="language-plaintext highlighter-rouge">protocol</code>이기 때문에 어떤 것이든 될 수 있다고 합니다. ViewController가 될 수도 있고, ViewModel이 될 수도 있죠.</p>

<p>하지만 ViewModel 같이 로직을 분리할 수 있는 곳에 사용하는 것이 적절합니다.</p>

<p>RxFlow는 <code class="language-plaintext highlighter-rouge">OneStepper</code>라는 <code class="language-plaintext highlighter-rouge">Stepper</code> 클래스를 기본으로 구현하여 제공하고 있습니다. 아래와 같이 생겼는데요..</p>

<pre><code class="language-Swift">public class OneStepper: Stepper {
	public let steps = PublishRelay&lt;Step&gt;()
	private let singleStep: Step

	public init(withSingleStep singleStep: Step) {
		self.singleStep = singleStep
	}

	public var initialStep: Step {
		return self.singleStep
	}
}
</code></pre>

<p>이 <code class="language-plaintext highlighter-rouge">OneStepper</code>는 초기화와 동시에 오직 하나의 <code class="language-plaintext highlighter-rouge">Step</code>을 emit하는 것을 유일한 로직으로 갖는 <code class="language-plaintext highlighter-rouge">Stepper</code>입니다.</p>

<p>새로운 <code class="language-plaintext highlighter-rouge">Flow</code>를 생성하고 첫 <code class="language-plaintext highlighter-rouge">Step</code>을 실행할 때 유용하다고 합니다.</p>

<p>아래 <code class="language-plaintext highlighter-rouge">Stepper</code>는 <code class="language-plaintext highlighter-rouge">pick(movieID:)</code> 메서드가 실행될 때마다 <code class="language-plaintext highlighter-rouge">DemoStep.movieIsPicked(withID)</code>를 emit합니다.</p>

<p>해당 <code class="language-plaintext highlighter-rouge">Step</code>이 emit되면, 위의 <code class="language-plaintext highlighter-rouge">WatchedFlow</code>에서 <code class="language-plaintext highlighter-rouge">navigate(to step:)</code> 메서드가 실행되고, 결과적으로 <code class="language-plaintext highlighter-rouge">navigateToMovieDetailScreen(withmovieID: Int)</code> 메서드가 실행되게 됩니다.</p>

<pre><code class="language-Swift">class WatchedViewModel: Stepper {
	let movies: [MovieViewModel]
	let steps = PublishRelay&lt;Step&gt;()

	init(with service: MovieService) {
		self.movies = service.watchedMovies().map({ movie -&gt; MovieViewModel in
			return MovieViewModel(id: movie.id, title: movie.title, image: movie.image)
		})
	}

	// 영화가 pick 됐을 때 새로운 Step을 emit합니다.
	// 이 emit은 WatchedFlow에서 네비게이션 액션을 촉발합니다.
	public func pick(movieID: Int) {
		self.steps.accept(DemoStep.movieIsPicked(withID: movieID))
	}
}
</code></pre>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><category term="Favor" /><summary type="html"><![CDATA[RxFlow]]></summary></entry><entry><title type="html">18)🍎 Swift - 다운샘플링</title><link href="/jekyll-theme-yat/swift/2022/12/27/Swift18.html" rel="alternate" type="text/html" title="18)🍎 Swift - 다운샘플링" /><published>2022-12-27T00:00:00+00:00</published><updated>2022-12-27T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2022/12/27/Swift18</id><content type="html" xml:base="/jekyll-theme-yat/swift/2022/12/27/Swift18.html"><![CDATA[<h1 id="다운샘플링으로-메모리-효율적인-이미지-처리하기">다운샘플링으로 메모리 효율적인 이미지 처리하기</h1>

<p>이전 게시물에서 알아보았던 <code class="language-plaintext highlighter-rouge">PHPicker</code>를 사용해서 이미지를 처리하던 중 아래와 같은 에러를 마주쳤습니다.</p>

<p><img src="https://i.imgur.com/PIZF0mw.png" alt="" /></p>

<p>Swift가 허용한 4,194,304 바이트보다 큰 데이터를 UserDefaults에 저장할 수 없다는 에러입니다.</p>

<p>UserDefaults는 작은 데이터들을 저장할 목적으로 만들어진 것이기 때문에 위와 같은 에러는 자연스러운 현상인 듯 합니다.</p>

<p>지금 저장하려는 이미지는 원본 이미지 그 자체였으니 당연히 용량이 컸을 것이고, 이미지의 용량을 줄이려면 보통 이미지 크기를 줄이겠다는 생각부터 하겠죠?</p>

<p><strong>이미지 크기의 축소</strong>는 가장 직관적으로 이미지 용량을 줄이고 메모리 가용률도 높이는 좋은 방법 중 하나입니다.</p>

<p>그래서 저도 이미지를 줄일 수 있는 방법부터 찾아보게 되었죠.</p>

<h2 id="이미지-리사이즈시의-cpu와-메모리-동작">이미지 리사이즈시의 CPU와 메모리 동작</h2>

<p>하지만 공부를 한 지 얼마 지나지 않아 단순히 이미지를 줄이는 방법은 좋은 방법이 아니고, 오히려 앱이 기기에 과부하를 더 줄 수 있다는 사실을 깨달았습니다.</p>

<p>그 까닭은 2018년에 진행된 WWDC2018에서 찾아볼 수 있었습니다.</p>

<p><a href="https://developer.apple.com/wwdc18/219">Image and Graphics Best Practices - WWDC18 - Videos - Apple Developer</a></p>

<p>이미 이미지 처리 게시물들에서 많이 다루고 있고 iOS의 화면 표현 방법을 학습해볼 수 있는 세션입니다.</p>

<p>아래는 <code class="language-plaintext highlighter-rouge">UIGraphicsImageRenderer</code>를 사용하여 <code class="language-plaintext highlighter-rouge">PHPicker</code>를 통해 받은 이미지 여러개의 크기를 줄이는 코드입니다.</p>

<p><img src="https://i.imgur.com/qZZB9BM.png" alt="" /></p>

<pre><code class="language-Swift">var images: [UIImage] = []

var result in results {
	result.itemProvider.loadObject(ofClass: UIImage.self) { object, error in
		guard let image = object as? UIImage else { return }
		guard let resizedImage: UIImage = UIGraphicsImageRenderer(size: CGSize(width: 2_000, height: 2_000)).image { context in
			image.draw(in: CGRect(origin: CGPoint.zero, size: newSize))
		} else { return }
		images.append(resizedImage)
	}
}
</code></pre>

<p>단순히 보기에는 아무런 문제가 없어보이죠.</p>

<p>문제는 두 번에 걸쳐서 발생합니다.</p>

<h3 id="1-원본을-로드한다">1. 원본을 로드한다.</h3>

<pre><code class="language-Swift">guard let image = object as? UIImage else { return }
</code></pre>

<p>첫 번째 문제입니다.</p>

<p>이미지 사이즈를 줄이는 목적이 무엇이였나요?</p>

<p>메모리에 부하를 덜 주기 위해서였죠.</p>

<p>위 방법은 성공적으로 수행만 된다면 그 이후에는 메모리 사용률을 낮춰줄겁니다.</p>

<p>그런데 이미지 크기를 줄이기 위해서 우선 원본 이미지를 한 번 로드해주어야 합니다.</p>

<p>그 한 번 로드하는 과정에서 백그라운드 작업들을 종료시키거나 심하면 앱 자체를 종료시키는 현상이 발생할 수 있습니다.</p>

<p>실제로 위 코드만 봐도 <code class="language-plaintext highlighter-rouge">PHPicker</code>는 선택한 데이터를 <code class="language-plaintext highlighter-rouge">UIImage</code> 타입으로서 제공하지 않습니다.</p>

<p>굳이 크기가 큰 그 데이터를 아무런 처리 없이 <code class="language-plaintext highlighter-rouge">UIImage</code>로 바로 변환하여 사용하고 있었던 것이죠!</p>

<h3 id="2-작은-이미지를-직접-그린다">2. 작은 이미지를 <strong>직접 그린다</strong>.</h3>

<pre><code class="language-Swift">image.draw(in: CGRect(origin: .zero, size: newSize))
</code></pre>

<p>두 번째 문제입니다.</p>

<p>위 방법은 이미지를 불러와 그 이미지의 작은 버전을 <code class="language-plaintext highlighter-rouge">draw</code> 메서드를 사용하여 직접 그려줘야 하는 방법입니다.</p>

<p>그래픽 작업을 하는 것이기 때문에 CPU와 메모리 두 하드웨어 모두에게 작업을 부여하는 것이고, 이 또한 메모리 부하를 줄이는 것과는 거리가 먼 것을 알 수 있습니다.</p>

<h2 id="다운-샘플링">다운 샘플링</h2>

<p>그러면 단순히 이미지를 리사이징 하는 방법 외에 어떤 방법이 있을까요?</p>

<p><img src="https://i.imgur.com/QEsP6KF.png" alt="" /></p>

<p>바로 데이터를 <code class="language-plaintext highlighter-rouge">UIImage</code>로 바로 변환하여 사용하는 것이 아니라 <code class="language-plaintext highlighter-rouge">CGImage</code> 타입의 데이터를 사용하여 디코딩할 파일(data buffer) 자체의 사이즈를 줄이는 다운샘플링 방법이 있습니다.</p>

<p>다만 이 방법은 <code class="language-plaintext highlighter-rouge">Core Graphics</code>이라는 한 층 더 low-level한 내용을 사용하기 때문에 코드가 좀 더 길고 복잡합니다.</p>

<pre><code class="language-Swift">func downsample(at url: URL, to pointSize: CGSize, scale: CGFloat) -&gt; Data? {

	let sourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary

	guard let source = CGImageSourceCreateWithURL(url as CFURL, sourceOptions) else { return nil }

	let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale

	let downsampleOptions = [
		kCGImageSourceCreateThumbnailFromImageAlways: true,
		kCGImageSourceCreateThumbnailWithTransform: true,
		kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels
	] as CFDictionary

	guard let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOptions) else { return nil }

	let data = NSMutableData()

	guard let imageDestination = CGImageDestinationCreateWithData(data, UTType.jpeg.identifier as CFString, 1, nil) else { return nil }

	let isPNG: Bool = {
		guard let utType = cgImage.utType else { return false }
		return (utType as String) == UTType.png.identifier
	}()

	let destinationProperties = [
		kCGImageDestinationLossyCompressionQuality: isPNG ? 1.0 : 0.75
	] as CFDictionary

	CGImageDestinationAddImage(imageDestination, cgImage, destinationProperties)
	CGImageDestinationFinalize(imageDestination)

	return data as Data
}
</code></pre>

<blockquote>
  <p>어질어질하쥬..? 😵</p>
</blockquote>

<p>복잡해 보이지만 두 파트로 나눌 수 있습니다. 한 번 살펴봅시다.</p>

<h3 id="1-cgimage-생성">1. <strong>CGImage</strong> 생성</h3>

<pre><code class="language-Swift">let sourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary
guard let source = CGImageSourceCreateWithURL(url as CFURL, sourceOptions) else { return nil }

let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale
let downsampleOptions = [
	kCGImageSourceCreateThumbnailFromImageAlways: true,  
	kCGImageSourceShouldCacheImmediately: true,
	kCGImageSourceCreateThumbnailWithTransform: true,
	kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels
] as CFDictionary

guard let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOptions) else { return nil }
</code></pre>

<p>downsampling의 핵심이 되는 부분입니다.</p>

<p>사실상 필수적인 로직들은 이 안에 다 있습니다.</p>

<p>Option flag를 정의해주고 해당 옵션을 통해 <code class="language-plaintext highlighter-rouge">CGImage</code>를 생성해주는 방식입니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">kCGImageSourceShouldCache: false</code>
    <ul>
      <li>이미지 소스에  대한 참조값만을 생성하고 <code class="language-plaintext highlighter-rouge">CGImageSource</code>가 생성되는 즉시 디코딩을 진행하지 않습니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">kCGImageSourceShouldCacheImmediately: true</code>
    <ul>
      <li>앞선 옵션과는 반대로 다운샘플링 로직이 시작됨과 동시에 디코딩 작업을 수행합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">kCGImageSourceCreateThumbnailWithTransform: true</code>
    <ul>
      <li>다운샘플링된 이미지를 원본 이미지와 같은 형태를 갖도록 합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="2-png-퀄리티-보존">2. PNG 퀄리티 보존</h3>

<pre><code class="language-Swift">let data = NSMutableData()

guard let imageDestination = CGImageDestinationCreateWithData(data, UTType.jpeg.identifier as CFString, 1, nil) else { return nil }

let isPNG: Bool = {
	guard let utType = cgImage.utType else { return false }
	return (utType as String) == UTType.png.identifier
}()

let destinationProperties = [
	kCGImageDestinationLossyCompressionQuality: isPNG ? 1.0 : 0.75
] as CFDictionary

CGImageDestinationAddImage(imageDestination, cgImage, destinationProperties)
CGImageDestinationFinalize(imageDestination)

return data as Data
</code></pre>

<p>이 부분은 사실 선택적으로 구현하면 되는 부분입니다.</p>

<p><code class="language-plaintext highlighter-rouge">PNG</code> 확장자는 보통 스크린샷과 같이 이미지의 품질이 중요한 이미지들에 사용됩니다.</p>

<p>이러한 이미지의 품질이 손상된다면 이미지에 포함된 텍스트 등의 시인성, 가독성이 중요한 요소들에 영향이 갈 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">PNG</code> 확장자라면 1.0의 손상 없는 압축을, 그 외의 확장자라면 0.75의 압축률로 데이터를 디코딩하였습니다.</p>

<h4 id="phpicker와의-사용"><code class="language-plaintext highlighter-rouge">PHPicker</code>와의 사용</h4>

<p>이전 <code class="language-plaintext highlighter-rouge">PHPicker</code>를 사용할 때는 아래와 같은 코드를 사용하였습니다.</p>

<pre><code class="language-Swift">itemProvider.loadObject(ofClass: UIImage.self) { image, error in
	// do something
}
</code></pre>

<p>이번 게시물에서 사용한 방법은 <code class="language-plaintext highlighter-rouge">URL</code> 타입으로 이미지를 받기 때문에 아래와 같이 사용해야 합니다.</p>

<pre><code class="language-Swift">itemProvider.loadFileRepresentation(forTypeIdentifier: UTType.image.identifier) { url, error in
	// do something
}
</code></pre>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><summary type="html"><![CDATA[다운샘플링으로 메모리 효율적인 이미지 처리하기]]></summary></entry><entry><title type="html">17)🍎 Swift - Property Wrapper</title><link href="/jekyll-theme-yat/swift/2022/12/26/Swift17.html" rel="alternate" type="text/html" title="17)🍎 Swift - Property Wrapper" /><published>2022-12-26T00:00:00+00:00</published><updated>2022-12-26T00:00:00+00:00</updated><id>/jekyll-theme-yat/swift/2022/12/26/Swift17</id><content type="html" xml:base="/jekyll-theme-yat/swift/2022/12/26/Swift17.html"><![CDATA[<h1 id="property-wrapper">Property Wrapper</h1>

<p>오늘은 UserDefaults를 어떻게 하면 조금이라도 더 편하게 사용할 수 있을까 고민하다가 아주 좋은 친구를 발견했습니다.</p>

<p>바로 Property Wrapper라는 친구인데요.</p>

<p>이 친구는 SwiftUI와 Combine의 기능을 UIKit에서도 적용할 수 있도록 Swift 5.1버전에 등장했습니다.</p>

<p>많은 게시물에서 SwiftUI의 <code class="language-plaintext highlighter-rouge">@State</code>를 예시로 들며 설명하고 있는데, 저는 경험이 없어서.. 넘어가구요…</p>

<p>이름을 보면 프로퍼티를 감싸서 뭔가를 하는 친구인 것 같죠?</p>

<p>바로 알아보도록 하겠습니다.</p>

<h2 id="용도">용도</h2>

<p>일단 어떤 개념으로 사용되는 건지부터 알아봅시다.</p>

<p>Swift에는 <code class="language-plaintext highlighter-rouge">lazy</code>프로퍼티 라는 것이 있습니다.</p>

<p>해당 프로퍼티가 사용될 때 로드를 시작하도록 해주는 키워드이죠.</p>

<p>이 <code class="language-plaintext highlighter-rouge">lazy</code> 키워드는 모든 키워드들에 붙일 수 있고 동일한 동작을 합니다.</p>

<p>만약 이 키워드가 없다면 해당 기능을 구현하기 위해서 어떤 과정을 밟게 될까요?</p>

<pre><code class="language-Swift">func getMyClass() -&gt; MyClass {
	if self.myVar == nil {
		self.myVar = MyClass()
	}
	return self.myVar
}
</code></pre>

<p>위와 같이 해당 프로퍼티가 초기화가 됐는지 확인을 한 후에 값을 불러오는 함수를 만들어 모든 프로퍼티에 직접 구현하며 적용시켜주어야 할 거에요.</p>

<p>다행히도 위 동작을 우리는</p>

<pre><code class="language-Swift">lazy var myClass = MyClass()
</code></pre>

<p>이렇게 간편하게 구현할 수 있습니다.</p>

<p>Property Wrapper는 <code class="language-plaintext highlighter-rouge">lazy</code>와 같이 동일한 동작을 하는 프로퍼티들에 대해서 공통적으로 미리 구현된 동작들을 부여할 수 있는 기능입니다.</p>

<h2 id="정의">정의</h2>

<p>프로퍼티를 감싸는 기능이기 때문에 우선 프로퍼티를 가질 수 있는 class, struct, enum 앞에 <code class="language-plaintext highlighter-rouge">@propertyWrapper</code>를 붙여 정의합니다.</p>

<p>예시로 UserDefaults로 자동으로 동기화 작업을 하는 프로퍼티를 만들어보겠습니다.</p>

<pre><code class="language-Swift">@propertyWrapper
struct UserDeafult&lt;T&gt; {
	var key: String
	var defaultValue: T
}
</code></pre>

<p>그런데 이렇게까지만 하면 해당 프로퍼티에 변경이 있을 때마다 어떤 작업이 실행되는지에 대한 명시가 없죠.</p>

<p>그래서 에러가 발생하고, 그 에러를 살펴보면 <code class="language-plaintext highlighter-rouge">wrappedValue</code>가 정의되지 않았다는 것을 알 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">wrappedValue</code>를 정의해주고,  <code class="language-plaintext highlighter-rouge">get-set</code>을 사용하여 해당 프로퍼티가 변경될 때마다 발생하는 로직을 넣어줍니다.</p>

<pre><code class="language-Swift">var wrappedValue: T {
	get {
		UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
	}
	set {
		UserDefaults.standard.set(newValue, forKey: key)
	}
}
</code></pre>

<p>이제 합쳐볼까요?</p>

<pre><code class="language-Swift">@propertyWrapper
struct UserDefault&lt;T&gt; {
	var key: String
	var defaultValue: T

	var wrappedValue: T {
		get {
			UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
		}
		set {
			UserDefaults.standard.get(newValue, forKey: key)
		}
	}
}
</code></pre>

<h2 id="사용">사용</h2>

<p>자 그럼 적용은 어떻게 할까요?</p>

<p><code class="language-plaintext highlighter-rouge">lazy</code>와 마찬가지로 앞에 명시해주면 됩니다.</p>

<pre><code class="language-Swift">struct AppData {
	@UserDefault(key: "isLoggedIn", defaultValue: false)
	static var isLoggedIn: Bool

	@UserDefault(key: "username", defaultValue: "")
	static var username: String
}

AppData.isLoggedIn = true
print(AppData.isLoggedIn) // true

print(AppData.username) // ""
</code></pre>

<p>조금 더 나아가서 커스텀 타입에도 적용될 수 있도록 바꿔봅시다.</p>

<pre><code class="language-Swift">@propertyWrapper
struct UserDefault&lt;T: Codable&gt; {
	// key와 default 값은 바뀔 일이 없으니 let으로 변경
	private let key: String
	private let defaultValue: T

	init(key: String, defaultValue: T) {
		self.key = key
		self.defaultValue = defaultValue
	}

	var wrappedValue: T {
		get {
			guard let data = Userdefaults.standard.object(forKey: key) as? Data else {
				return defaultValue
			}
			let value = try? JSONDecoder().decode(T.self, from: data)
			return value ?? defaultValue
		}
		set {
			let data = try? JSONEncoder().encode(newValue)
			UserDefaults.standard.set(data, forKey: key)
		}
	}
}
</code></pre>

<p>이렇게 자동으로 UserDefaults로 값을 동기화시켜주는 Property Wrapper를 만들고 적용해보았습니다.</p>

<h3 id="참고-게시물">참고 게시물</h3>

<p><a href="https://medium.com/better-programming/create-the-perfect-userdefaults-wrapper-using-property-wrapper-42ca76005ac8"># Create the Perfect UserDefaults Wrapper Using Property Wrapper</a></p>]]></content><author><name>이창준</name></author><category term="Swift" /><category term="Swift" /><category term="iOS" /><summary type="html"><![CDATA[Property Wrapper]]></summary></entry></feed>